{"meta":{"title":"LeonChow","subtitle":"","description":"","author":"Chow","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"git设置代理","slug":"git设置代理","date":"2025-05-31T12:30:17.000Z","updated":"2025-05-31T12:32:14.318Z","comments":true,"path":"2025/05/31/git设置代理/","permalink":"http://example.com/2025/05/31/git%E8%AE%BE%E7%BD%AE%E4%BB%A3%E7%90%86/","excerpt":"","text":"临时设置打开 Git Bash，使用命令临时设定socks代理: 123git config --global http.proxy &#x27;socks5://127.0.0.1:socks5端口号&#x27; git config --global https.proxy &#x27;socks5://127.0.0.1:socks5端口号&#x27; 或者http代理： 123git config --global http.proxy &#x27;http://127.0.0.1:http端口号&#x27; git config --global https.proxy &#x27;https://127.0.0.1:https端口号&#x27; 永久设置若想要设置代理永久生效，则可以把它写入 .gitconfig 文件中。 使用 vi 打开 .gitconfig 文件： 1vi ~/.gitconfig 写入下列配置(建议在最末写入)： 123456789[http] proxy = socks5://127.0.0.1:socks5端口号proxy = http://127.0.0.1:http端口号 [https] proxy = socks5://127.0.0.1:socks5端口号proxy = https://127.0.0.1:http端口号 修改后重启 git ，使配置生效： 1git config -l --global 查看当前代理： 1git config -l 可以看到自己所配置的端口信息，则说明配置成功。 原文链接：https://blog.csdn.net/m0_57567093/article/details/127455214","categories":[],"tags":[]},{"title":"关于CheatEngine提示DBVM无法启动以及VMware提示此平台不支持虚拟化的解决方案","slug":"关于CheatEngine提示DBVM无法启动以及VMware提示此平台不支持虚拟化的解决方案","date":"2025-05-31T12:19:17.000Z","updated":"2025-05-31T12:28:12.469Z","comments":true,"path":"2025/05/31/关于CheatEngine提示DBVM无法启动以及VMware提示此平台不支持虚拟化的解决方案/","permalink":"http://example.com/2025/05/31/%E5%85%B3%E4%BA%8ECheatEngine%E6%8F%90%E7%A4%BADBVM%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8%E4%BB%A5%E5%8F%8AVMware%E6%8F%90%E7%A4%BA%E6%AD%A4%E5%B9%B3%E5%8F%B0%E4%B8%8D%E6%94%AF%E6%8C%81%E8%99%9A%E6%8B%9F%E5%8C%96%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/","excerpt":"","text":"环境 windows11 24h2 其它系统应该是通用 步骤1 首先打开控制面板-程序-启动或关闭Windows功能 像这样关闭这些: 然后再找到服务禁用以下功能 之后再设置里面搜索内核隔离然后把内核隔离的所有选项关闭 重启电脑尝试即可 若还是不行请看步骤2 步骤2 [来自](VMware Workstation：如何解决打开虚拟机出现“此平台不支持虚拟化的Intel VT-x&#x2F;EPT”的报错问题 - VM技术库)运行msinfo32.exe命令，确认Windows 11的宿主机是否开启了VBS，如果”基于虚拟化的安全“那一行后面显示是“未启用”，本文内容不适合。如果显示“正在运行”，请继续第2步。 之后执行以下脚本 写出一个bat文件即可 记得要管理员运行 123456789101112131415161718192021222324252627282930@echo offdism /Online /Disable-Feature:microsoft-hyper-v-all /NoRestartdism /Online /Disable-Feature:IsolatedUserMode /NoRestartdism /Online /Disable-Feature:Microsoft-Hyper-V-Hypervisor /NoRestartdism /Online /Disable-Feature:Microsoft-Hyper-V-Online /NoRestartdism /Online /Disable-Feature:HypervisorPlatform /NoRestartREM ===========================================mountvol X: /scopy %WINDIR%\\System32\\SecConfig.efi X:\\EFI\\Microsoft\\Boot\\SecConfig.efi /Ybcdedit /create &#123;0cb3b571-2f2e-4343-a879-d86a476d7215&#125; /d &quot;DebugTool&quot; /application osloaderbcdedit /set &#123;0cb3b571-2f2e-4343-a879-d86a476d7215&#125; path &quot;\\EFI\\Microsoft\\Boot\\SecConfig.efi&quot;bcdedit /set &#123;bootmgr&#125; bootsequence &#123;0cb3b571-2f2e-4343-a879-d86a476d7215&#125;bcdedit /set &#123;0cb3b571-2f2e-4343-a879-d86a476d7215&#125; loadoptions DISABLE-LSA-ISO,DISABLE-VBSbcdedit /set &#123;0cb3b571-2f2e-4343-a879-d86a476d7215&#125; device partition=X:mountvol X: /dbcdedit /set hypervisorlaunchtype offecho.echo.echo.echo.echo =======================================================echo 当前操作已完成，接下来请关闭此窗口并重启电脑，然后根据屏幕提示完成剩下操作。echo 等到windows重启完成会弹出一个黑框 狂按F3即可pause &gt; nulecho.echo. 这样就是成功了 亲测有效 脚本没问题 本人也是被这个问题困扰了很久很久","categories":[],"tags":[]},{"title":"PWN-简单栈溢出","slug":"PWN-简单栈溢出","date":"2025-05-30T06:58:02.000Z","updated":"2025-05-30T13:58:51.952Z","comments":true,"path":"2025/05/30/PWN-简单栈溢出/","permalink":"http://example.com/2025/05/30/PWN-%E7%AE%80%E5%8D%95%E6%A0%88%E6%BA%A2%E5%87%BA/","excerpt":"PWN-简单栈溢出介绍pwn这门课程简单来说就是通过二进制的形式去找到某台服务器存在哪些漏洞 与web不同的是他大部分的知识都是基于汇编组成的 在 CTF-Wiki 里面的介绍则是这样的: 栈溢出指的是程序向栈中某个变量中写入的字节数超过了这个变量本身所申请的字节数，因而导致与其相邻的栈中的变量的值被改变。这种问题是一种特定的缓冲区溢出漏洞，类似的还有堆溢出，bss 段溢出等溢出方式。栈溢出漏洞轻则可以使程序崩溃，重则可以使攻击者控制程序执行流程。此外，我们也不难发现，发生栈溢出的基本前提是： 程序必须向栈上写入数据。 写入的数据大小没有被良好地控制。","text":"PWN-简单栈溢出介绍pwn这门课程简单来说就是通过二进制的形式去找到某台服务器存在哪些漏洞 与web不同的是他大部分的知识都是基于汇编组成的 在 CTF-Wiki 里面的介绍则是这样的: 栈溢出指的是程序向栈中某个变量中写入的字节数超过了这个变量本身所申请的字节数，因而导致与其相邻的栈中的变量的值被改变。这种问题是一种特定的缓冲区溢出漏洞，类似的还有堆溢出，bss 段溢出等溢出方式。栈溢出漏洞轻则可以使程序崩溃，重则可以使攻击者控制程序执行流程。此外，我们也不难发现，发生栈溢出的基本前提是： 程序必须向栈上写入数据。 写入的数据大小没有被良好地控制。 则 栈的介绍如下： 基本栈介绍 ¶ 栈是一种典型的后进先出 (Last in First Out) 的数据结构，其操作主要有压栈 (push) 与出栈 (pop) 两种操作，如下图所示（维基百科）。两种操作都操作栈顶，当然，它也有栈底。 高级语言在运行时都会被转换为汇编程序，在汇编程序运行过程中，充分利用了这一数据结构。每个程序在运行时都有虚拟地址空间，其中某一部分就是该程序对应的栈，用于保存函数调用信息和局部变量。此外，常见的操作也是压栈与出栈。需要注意的是，程序的栈是从进程地址空间的高地址向低地址增长的。 这些是简单的栈介绍 首先 栈是一种特殊的数据结构 他存储了 function runtime 的参数、变量和返回地址他在一次函数调用中是不可或缺的重要部分，其中软件的架构又分为两种 x86 和 x64 这两种在参数和变量的在栈存储形式上有些不同 例如 x86 的所有参数通过 栈 从右到左依次压入 可用以下代码作为示例 使用 visual stdio 编译 x86 版本观查栈 123456789101112131415#include &lt;iostream&gt;int func(int _param1, int _param2, int _param3, int _param4, int _param5) &#123; return _param1 + _param2 + _param3 + _param4 + _param5;&#125;int main()&#123; func(1, 2, 3, 4, 5); std::cout &lt;&lt; &quot;helloworld\\n&quot;; getchar();&#125; 如图所示 我们定位到了 main 函数 然后我们在 func 处下断点 我们让他继续执行到func 执行到 call的时候我们观察栈的变化 如图所示 这是一个从低地址到高地址的显示方式 但是在入栈的时候 他是 从高地址到低地址从右往左参数依次入栈 然后我们进入call继续查看 进入call的同时我们发现 他先是压入了一个地址 这个地址就是 call 所在地址 + 5 的字节 所以call xxxxxxxx就等效于 push eip + 5 call的机器码占用一个字节 然而地址占用4个字节 其次又跳转到了 后面的地址处 所以call指令做了两件事 先是压入一个返回地址 接着又是进行了一次 jmp 跳转 然后我们接着看 在跳转过来的函数头部我们发现了两条指令 push ebp mov ebp esp 那么这是什么意思呢？ 其实是 典型的 x86 函数栈帧初始化 首先将当前的 ebp 寄存器的值压入栈 也就是保存上个函数的栈底地址 (push ebp) 之后把上个函数的栈顶作为当前函数的栈底 (mov ebp esp) 之后就是进行一系类的加法操作 到了 pop ebp的时候 就要销毁此栈帧恢复上一个函数的栈帧了 然而我们可以发现 函数参数是通过 ebp + n*4 的方式进行访问的 这很关键 直到执行到 ret 我们会发现 他的效果就等于 jmp esp 为什么这么说 我们接着分析栈 我们可以发现现在 esp=ebp 为什么说 ret 是 jmp [esp]呢 因为我们执行完 pop ebp 他就变成了这样 也就是返回到刚才call保存的返回值了 接着我们来看下x64的栈 x64分为两种编译器 在 Linux、FreeBSD、macOS 中普遍使用 System V AMD64 ABI 前六个整型或指针参数依次保存在 RDI, RSI, RDX, RCX, R8 和 R9 寄存器中，如果还有更多的参数的话才会保存在栈上。 内存地址不能大于 0x00007FFFFFFFFFFF，6 个字节长度，否则会抛出异常。 但在Windows上是 Microsoft x64 calling convention 也称作： Windows x64 ABI Windows x64 调用约定 他的参数入栈形式如下 前四个整型或指针参数依次保存在 RCX, RDX, R8, R9，如果还有更多的参数的话才会保存在栈上。 内存地址不能大于 0x00007FFFFFFFFFFF，6 个字节长度，否则会抛出异常。 🔍 System V AMD64 ABI vs Microsoft x64 ABI 对比 特性 System V AMD64 ABI (Linux&#x2F;macOS) Microsoft x64 ABI (Windows x64) 参数传递寄存器 RDI, RSI, RDX, RCX, R8, R9 RCX, RDX, R8, R9 返回值 RAX RAX 栈空间 被调用者必须保留 red zone（128 字节） 无 red zone（不能用栈下方空间） 调用者保存（volatile）寄存器 RAX, RCX, RDX, RSI, RDI, R8–R11 RAX, RCX, RDX, R8–R11 被调用者保存（callee-saved） RBX, RBP, R12–R15 RBX, RBP, RDI, RSI, R12–R15 参数超过寄存器 从第 7 个参数起压栈 从第 5 个参数起压栈 栈对齐要求 16 字节 16 字节 栈传参对齐方式 按参数自然大小 所有参数按 8 字节对齐 谁清理栈 被调用者使用 leave+ret 调用者清理（隐含对齐） 我这边就用Windows用作演示 我们也是执行到 func 下断点 然后我们进入这个call 我们会发现call的操作其实跟x86的call一样 也是 push RIP + 5 然后 jmp 地址 但是这个地址并不是一个绝对地址而是 相对地址。 相对地址跳转（RIP-relative） 🧮 实际跳转地址计算方式 123目标地址 = 下一条指令地址 + 偏移量偏移量 = 目标地址 - 下一条指令的地址下一条指令的地址 = 目标地址 - 偏移量 假设当前 EIP 为 0x1000，也就是 E8 的位置 E8 占 1 字节，后面是 4 字节偏移量，下一条指令的地址是： 10x1000 + 5 = 0x1005 加上偏移量 -0x97： 10x1005 - 0x97 = 0xF6E 为什么不用绝对地址？因为： 可重定位性更强：相对寻址无关内存基地址，适合代码段被加载到任意地址； 指令短：一个有符号 32 位偏移量足以跳转 ±2GB 的范围； 兼容 RIP-relative 模型：x64 强调基于 RIP 的寻址方式； 根据这张图我们可以计算下 偏移量 也就是 目标地址(00007FF76C6E15F0h) - 下一条地址(00007FF76C6E1687h) &#x3D; 偏移量(FFFF FFFF FFFF FF69h) 因为要的是一个32位整数 我们要 截断 也就是 FFFF FFFF FFFF FF69h &amp; FFFF FFFFh &amp; 相同为1 不同为0 120xFFFFFFFFFFFFFF69 = 11111111 11111111 11111111 11111111 11111111 11111111 11111111 011010010x00000000FFFFFFFF = 00000000 00000000 00000000 00000000 11111111 11111111 11111111 11111111 之后我们继续观察函数里面的内容 我们会发现 这边没有push rbp mov rbp rsp 这是为什么呢 其实这是编译器优化的结果 在 x64 系统下，编译器不一定使用帧指针（rbp），因为： x64 有更多寄存器可用（16 个通用寄存器），不需要保留 rbp； rbp 被当作普通寄存器用； 栈偏移通过 rsp + 偏移 就可以直接访问，不需要 rbp； 使用 rbp 反而浪费一个寄存器、增加指令数。 首先就是拿出来参数放到栈上进行一系列加法之后到 ret 这里就是 jmp [esp]的值了 至此对函数栈的简单介绍就到这里了 然后我们要思考一个问题 ​ 假如函数的参数的大小是八个字节 但是我们输入了过多的字符 导致该参数占用10个字节 这会导致什么问题呢？🤔 栈溢出没错 这就导致了过多的字符覆盖了低地址处的栈空间 然而这就是 栈溢出 这个问题导致的漏洞危害极大 如果我们可以把输入的字符覆盖到返回地址也就是call保存的返回值处 然后我们刚好可以构造出一段恶意代码 并且让他跳转到含有关键数据的函数 例如 system 或者 拿到了shell权限 对于我们的服务器来说是一场致命打击 💥 举个例子 假如我们手里刚好有一个这样的程序 刚好有一个可以被栈溢出的函数 我们可以用 gdb去测试一下 根据图中所示 我们可以先用gdb加载 然后再 main函数上下个断点 我们输入 r 执行 他断到了这里然后我们一直走到 gets 这个函数 为什么要走到 gets 呢 因为 gets 这个函数他是一个输入函数 他把值输入到了栈中 但是不限制输入大小 我们可以通过这个方式 去修改最后ret的值 在此之前我们需要通过 cyclic 指令生成一堆杂乱的数据 方便我们后续直接定位栈偏移 使用 ni 指令单步 执行到 ret 指令我们就继续使用 cyclic -l 去计算他的偏移 然后这时候我们拿到了偏移量 那么怎么构造他的shell呢 这时候我们就要用 pwntools 了 exp 如下所示 123456789101112# 载入库from pwn import * # 打开进程p = process(&#x27;ret2text&#x27;)# 附加调试器# gdb.attach(p) 可以观看流程# 构建 payloadpayload = b&#x27;a&#x27;*112+p32(0x804863A)# 发送payloadp.sendline(payload)# 用户交互p.interactive() 执行之后是这样的 结束","categories":[],"tags":[{"name":"PWN","slug":"PWN","permalink":"http://example.com/tags/PWN/"}]},{"title":"编码","slug":"编码","date":"2025-05-29T13:32:56.000Z","updated":"2025-05-30T13:59:21.730Z","comments":true,"path":"2025/05/29/编码/","permalink":"http://example.com/2025/05/29/%E7%BC%96%E7%A0%81/","excerpt":"编码ASCII编码 使用一个字节来表示字符串中的字符，称为ANSI字符串。 ASCII（American Standard Code for Information Interchange）是 美国信息交换标准代码，它使用 7 位 来表示一个字符，共定义了 128 个字符，范围是 0 ~ 127，包括： 英文字母（AZ，az） 数字（0~9） 标点符号（如 !、,、. 等） 控制字符（如换行符 \\n，回车 \\r） 2. 在 C 语言中的表现1234567#include &lt;stdio.h&gt;int main() &#123; char c = &#x27;A&#x27;; // 字符A的ASCII值是65 printf(&quot;字符: %c, ASCII码: %d\\n&quot;, c, c); return 0;&#125; 输出： 1字符: A, ASCII码: 65","text":"编码ASCII编码 使用一个字节来表示字符串中的字符，称为ANSI字符串。 ASCII（American Standard Code for Information Interchange）是 美国信息交换标准代码，它使用 7 位 来表示一个字符，共定义了 128 个字符，范围是 0 ~ 127，包括： 英文字母（AZ，az） 数字（0~9） 标点符号（如 !、,、. 等） 控制字符（如换行符 \\n，回车 \\r） 2. 在 C 语言中的表现1234567#include &lt;stdio.h&gt;int main() &#123; char c = &#x27;A&#x27;; // 字符A的ASCII值是65 printf(&quot;字符: %c, ASCII码: %d\\n&quot;, c, c); return 0;&#125; 输出： 1字符: A, ASCII码: 65 Unicode编码(双字节) Unicode是继ASCII字符编码后的另一种新型字符编码。严格意义上讲，ASCII码的每个字符使用7位表示Unicode则使用全16位表示一个字符。Unicode字符串中的每个字符均为双字节，所以又称为宽字符串。由于Unicode兼容ASCII字符，所以被大多数程序所支持，如Windows内核。Unicode的前128个字符码（十六进制，0x00000x007F）同ASCII码具有同样的字节值。比如，字母“a”的Unicode编码是0x0061，而“a”的ASCII编码是0x61。虽然占用的字节数不一样，但是两者的值是一样的。接下来的128个Unicode字符（代码为0x00800x00FF)是ISO8859-1对ASCII码的扩展。中国、日本和韩国的象形文字（总称为CJK）占用了0x3000~0x9FFF的代码。如“汉”字的Unicode编码是6C49h（其GB码为0BABAh)。 Unicode字符串不像ANSI字符串那样，保证用字符“\\0”结束；如果开发者在程序设计时以字符“\\0”作为Unicode字符串结尾的判断条件，就可能发生错误。 在汇编语言中，Unicode字符串被定义为一个结构体，它的定义如下： 12345typedef struct _UNICODE_STRING &#123; USHORT Length; //字符串长度 USHORT MaximumLength; //字符串缓冲区长度 PWSTR Buffer; //字符串缓冲区&#125; UNICODE_STRING, *PUNICODE_STRING; 由于我们无法保证Unicode字符串结尾一定是“\\0”，所以在结构体中，字段Length定义了字符串的长度。一个安全的字符串还必须限定字符的总长度，这由MaximumLength来实现。 UTF-8、UTF-16、UTF-32 是 Unicode 的编码方式 UTF-8：多字节，1~4 字节 UTF-16：2 或 4 字节 UTF-32：固定 4 字节（效率低，体积大） C 语言中的示例对比✅ Unicode 码点的概念（逻辑编号）12345678910#include &lt;wchar.h&gt;#include &lt;locale.h&gt;#include &lt;stdio.h&gt;int main() &#123; setlocale(LC_ALL, &quot;&quot;); wchar_t ch = L&#x27;你&#x27;; wprintf(L&quot;字符: %lc, Unicode码点: U+%04X\\n&quot;, ch, ch); return 0;&#125; 输出（在 UTF-8 环境中）： 1字符: 你, Unicode码点: U+4F60 多字节编码 多字节编码一般都是在 ASCII 的基础上进行扩展或兼容设计的。 🔷 一、为什么基于 ASCII 扩展？✅ 兼容性原则早期的系统、程序、协议都是基于 ASCII 设计的，为了不打破已有的英文文本和软件兼容性，后来设计的多字节编码（如 GBK、UTF-8）都： 保留 ASCII 范围（0x00 ~ 0x7F）作为单字节直接使用 超出 ASCII 的字符才用 多个字节组合表示 🔷 二、是如何在 ASCII 基础上扩展的？1. ASCII 基本规则 字符 二进制（7位） 十六进制 A 01000001 0x41 z 01111010 0x7A 空格 00100000 0x20 所有 ASCII 字符的最高位（第8位）都是 0 2. 多字节编码（如 UTF-8）的扩展方式UTF-8 保证： 0xxxxxxx 表示 ASCII → 保留单字节（最高位为 0） 非 ASCII → 多字节以 1xxxxxxx 开头（高位 1） UTF-8 编码示意： 编码字节数 前缀规则 可表示的字符范围 1字节 0xxxxxxx ASCII（U+0000 ~ U+007F） 2字节 110xxxxx 10xxxxxx U+0080 ~ U+07FF 3字节 1110xxxx 10xxxxxx 10xxxxxx U+0800 ~ U+FFFF 示例：“你” 字：Unicode &#x3D; U+4F60 UTF-8 编码 → 0xE4 0xBD 0xA0 3. GBK 等编码也是类似原则GBK： ASCII：0x00~0x7F，单字节直接使用 中文：0x81~0xFE 开头的多字节组合 示例： 字符 GBK 编码 A 0x41 “你” 0xC4 0xE3 🔷 三、可视化对比123456789diff复制编辑+----------------------+------------------------+| ASCII | 0x41 (A), 0x61 (a) |+----------------------+------------------------+| UTF-8 | A -&gt; 0x41 || | 你 -&gt; 0xE4 0xBD 0xA0 |+----------------------+------------------------+| GBK | A -&gt; 0x41 || | 你 -&gt; 0xC4 0xE3 |+----------------------+------------------------+ ✅ 结论： 多字节编码不会破坏 ASCII 表示方式，而是在此基础上扩展更高位字符。 🔷 四、C 语言验证例子：ASCII + 多字节输出1234567891011121314151617c复制编辑#include &lt;stdio.h&gt;int main() &#123; char *ascii = &quot;A&quot;; // ASCII 单字节 char *utf8 = &quot;你&quot;; // UTF-8 多字节 printf(&quot;ASCII 字符: %s\\n&quot;, ascii); printf(&quot;UTF-8 字符: %s\\n&quot;, utf8); printf(&quot;UTF-8 字节: &quot;); for (int i = 0; utf8[i] != &#x27;\\0&#x27;; i++) &#123; printf(&quot;%02X &quot;, (unsigned char)utf8[i]); &#125; printf(&quot;\\n&quot;); return 0;&#125; 输出： 123less复制编辑ASCII 字符: AUTF-8 字符: 你UTF-8 字节: E4 BD A0 🔷 五、总结一句话 多字节编码方案（如 UTF-8、GBK）都是在 ASCII 基础上添加高字节区域来扩展更多语言字符，同时保持对 ASCII 的完全兼容。","categories":[],"tags":[{"name":"编码","slug":"编码","permalink":"http://example.com/tags/%E7%BC%96%E7%A0%81/"}]},{"title":"PElearn","slug":"PElearn","date":"2025-05-29T13:31:56.000Z","updated":"2025-05-30T13:58:43.248Z","comments":true,"path":"2025/05/29/PElearn/","permalink":"http://example.com/2025/05/29/PElearn/","excerpt":"PE 学习笔记(一)先来几张图片放在最前面","text":"PE 学习笔记(一)先来几张图片放在最前面 引言本帖子大部分出自书籍 《Windows PE权威指南》因需要复习PE知识 故此记录 地址地址有四类，它们分别是：虚拟内存地址（VA)相对虚拟内存地址（RVA）文件偏移地址（FOA)特殊地址 扩展 32 位环境下的Windows内存管理32位CPU的寻址能力为4GB（即2²个字节)，但有些用户的物理内存达不到这个值。于是操作系统和CPU的内存管理单元共同作用，为用户提供了虚拟内存的管理机制。即分页机制。该机制可以让用户感觉自己好像在使用4GB的内存。 分页机制的基本原理是：操作系统假设一个进程独立拥有4GB内存，按照某个固定的大小（如4KB）将这4GB空间分成N（1M）个页。在某一时刻，所有这些页只有一部分和物理内存是对应的（所以这种机制允许物理内存比4GB小)。没有物理内存对应的页面被标记为脏(dirty)的页面，一般存储在一个名为“交换文件”的磁盘文件中。在WindowsXP系统中，交换文件为pagefile.sys，它位于系统盘的根目录，是一个系统隐藏文件。当系统需要读取未在内存中的数据时，这部分数据会将内存中不经常读写的页交换出内存，而把要读取的、位于交换文件中的页换进内存。通过这种存取机制可以让一个进程拥有比实际内存大得多的内存。利用这种机制管理的内存称为虚拟内存。 虚拟内存地址VA &#x3D; 进程基地址+相对虚拟内存地址 相对虚拟内存地址RVA &#x3D; 某个特定位置距离某个模块基地址的偏移量 关于VA和RVA的概念如图所示 假设模块2的基地址为0x01000000，而模块2中的某个位置距离模块2的基地址偏移为400h，那么值0x00000400就是模块2中某个位置的RVA，而值0x01000400是该位置的VA。记住，RVA是相对于模块而言的，VA是相对于整个地址空间而言的。注意RVA与具体模块相关，它有一个范围，该范围从模块的开始到模块结束，脱离开这个范围的RVA是无效的，称为越界。越界的RVA地址没有任何意义。 文件偏移地址文件偏移地址(File Offset Address, FOA) 和内存无关，它是指某个位置距离文件头的偏移。 特殊地址比较少见 其他数据目录 导出表 导入表 资源表 异常表 属性证书表 重定位表 调试数据 Architecture Global Ptr 线程局部存储 加载配置表 绑定导入表 IAT 延时导入表 CLR运行时头部 节主要是用来存放不同类型数据(代码、数据、常量、资源等) 不同节有不同的访问权限 对齐数据在内存中的对齐、数据在文件中的对齐、资源文件中资源数据的对齐 内存对齐节在内存中的对齐单位必须至少是一个页的大小 32位 &#x3D; 4kb (1000h) 64位&#x3D;8kb (2000h) 文件对齐节在文件中的对齐要小于内存中的对齐 通常会以一个物理扇区的大小作为对齐粒度的值也就是512字节 十六进制表示 (200h) 出于节约资源的考虑，操作系统允许节在内存和文件中的对齐尺寸不一致。这就直接造成了PE在文件中和在内存中的大小也会不一致。通常情况下，PE在内存中的尺寸要比在文件中的尺寸大。用户可以自己定义这些对齐的值。 如果内存对齐被定义为小于操作系统页的大小，则文件对齐和内存对齐的值必须一致！ 资源数据对齐资源文件中，资源字节码部分一般要求以双字（4个字节）方式对齐 PE文件结构 在十六位系统中 PE头和PE结构数据被当成是冗余数据 在32位系统中 刚好相反 即DOS头成为冗余数据 所谓冗余 是针对DOS头不参与 32位系统运行过程而言 尽管该部分不参与运行 但也不能把这些数据从PE结构中出去 因为DOS MZ头中有一个字段非常重要 即 IMAGE_DOS_HEADER.e_lfanew 没有他操作系统就定位不到标准的PE头部 可执行程序也就会被操作系统认为是非法的PE映像 定位标准PE头 由于DOS Stub的长度不固定 导致了DOS头也不是一个固定大小的数据结构 那么在WindowsPE中 既然把DOS头放在了PE的起始位置 如果去定位后面的标准PE头所在的位置呢 字段e_lfanew 即起这个作用 该字段的值是一个 相对偏移量 相对定位时需要加上DOS MZ 头的基地址 也就是说 通过以下公式可以得到PE头的绝对位置 1PE_start = DOS MZ 基地址 + IMAGE_DOS_HEADER.e_lfanew 大概分为五个部分 DOS MZ头 DOS Stub PE头 节表 节内容 PE头是由 IMAGE_FILE_HEADER.SizeOfOptionalHeader 来确定大小的 节的数量是由字段 IMAGE_FILE_HEADER.NumberOfSections来定义的 DOS Stub和节内容都是大小不确定的 节的内容大小不确定 一个标准的PE文件一般由四大部分组成: DOS头 PE头 节表 节内容 紧跟在DOS stub后面的是PE头标识 Signature 与大部分文件格式的头部结构一样 PE头部信息中有一个四字节的标识 该标识位于指针IMAGE_DOS_HEADER.e_lfanew 指向的位置 其内容固定 对应于ASCII码的字符串 “PE\\0\\0” 标准PE头 IMAGE_FILE_HEADER紧跟在PE头标识后 即位于IMAGE_DOS_HEADER 的 e_lfanew值+4的位置 由此位置开始的20个字节为数据结构标准PE头IMAGE_FILE_HEADER的内容 该结构在微软的官方文档中被称为标准通用对象文件格式 (Common Object File Format COFF)头 它记录了PE文件的全局属性 例如 PE文件的运行平台、PE文件类型、文件中存在节的总数等 定义如下： 123456789typedef struct _IMAGE_FILE_HEADER &#123; WORD Machine; // 平台 WORD NumberOfSections; // pe中节的数量 DWORD TimeDateStamp; // 文件创建日期和时间 DWORD PointerToSymbolTable; // 指向符号表(用于调试) DWORD NumberOfSymbols; // 符号表中的符号数量(用于调试) WORD SizeOfOptionalHeader; // 扩展头结构的长度 WORD Characteristics; // 文件属性&#125; IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER; 该结构可以用于判断PE文件是EXE还是DLL类型 不但可以通过该结构得到PE文件中节的总量，还可以当成对节区信息进行遍历操作时的循环次数 扩展PE头 IMAGE_OPTIONAL_HEADER32123456789101112131415161718192021222324252627282930313233typedef struct _IMAGE_OPTIONAL_HEADER &#123; WORD Magic; // 魔术字 BYTE MajorLinkerVersion; // 链接器版本号 BYTE MinorLinkerVersion; // 连接器次版本号 DWORD SizeOfCode; // 所有含代码的节的总大小 DWORD SizeOfInitializedData; // 所以含已初始化数据的节的总大小 DWORD SizeOfUninitializedData; // 所有含未初始化数据的节的大小 DWORD AddressOfEntryPoint; // 程序执行入口 RVA DWORD BaseOfCode; // 代码的节的起始RVA DWORD BaseOfData; // 数据的节的起始RVA DWORD ImageBase; // 程序的建议装载地址 DWORD SectionAlignment; // 内存中节的对齐粒度 DWORD FileAlignment; // 文件中节的对齐粒度 WORD MajorOperatingSystemVersion; // 操作系统的版本号 WORD MinorOperatingSystemVersion; // 操作系统的次版本号 WORD MajorImageVersion; // 该PE的版本号 WORD MinorImageVersion; // 该PE的次版本号 WORD MajorSubsystemVersion; // 所需子系统的版本号 WORD MinorSubsystemVersion; // 所需子系统的次版本号 DWORD Win32VersionValue; // 未用 DWORD SizeOfImage; // 内存中整个PE映像的尺寸 DWORD SizeOfHeaders; // 所有头+节表的大小 DWORD CheckSum; // 校验和 WORD Subsystem; // 文件的子系统 WORD DllCharacteristics; // DLL文件特征 DWORD SizeOfStackReserve; // 初始化时的栈大小 DWORD SizeOfStackCommit; // 初始化时实际提交的栈大小 DWORD SizeOfHeapReserve; // 初始化时保留的堆大小 DWORD SizeOfHeapCommit; // 初始化时实际提交的堆大小 DWORD LoaderFlags; // 与调试有关 DWORD NumberOfRvaAndSizes; // 下面的数据目录结构的项目数量 IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES]; //数据目录&#125; IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32; 文件执行的入口 文件被操作系统装入内存后的默认基地址 以及节在磁盘和内存中的对齐单位等信息 均可在此结构中找到 对该结构的某些数值改动都可以会造成PE文件的加载或运行失败 IMAGE_NT_HEADERS这个结构广义上的PE头 在标准PE文件中其大小为456个字节 他是以上两种结构的组好 即 IMAGE_NT_HEADERS &#x3D; 4个字节的PE标识 + IMAGE_FILE_HEADER+IMAGE_OPTIONAL_HEADER32 该结构的详细定义如下： 12345typedef struct _IMAGE_NT_HEADERS &#123; DWORD Signature; // PE头标识 IMAGE_FILE_HEADER FileHeader; // PE标准头 IMAGE_OPTIONAL_HEADER32 OptionalHeader; // PE扩展头&#125; IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32; 与DOS头一样 PE头开始也是一个标志 用一个双字的 “PE\\0\\0” 来命名 这也是PE头的由来 数据目录项 IMAGE_DATA_DIRECTORYIMAGE_OPTIONAL_HEADER32(扩展PE头) 结构的最后一个字段为 DataDriectory 该字段定义了PE文件中出现的所有不同类型的数据和目录信息 如前所述 应用程序中的数据被按照用途分成很多种类 导出表、导入表、资源、重定位等 在内存中，这些数据被操作系统以页为单位组织起来，并赋予不同的访问属性，在文件中，这些数据也同样被组织起来，按照不同类型分别存放在文件的指定位置，该结构就是用来描述这些不同类型的数据在文件(和内存)中位置及大小的 该数据目录中定义的数据类型一直是16种 PE种使用了一种称作 “数据目录项 IMAGE_DATA_DIRECTORY” 的数据结构来定义每种数据 该结构如下所示 只有两个字段 1234typedef struct _IMAGE_DATA_DIRECTORY &#123; DWORD VirtualAddress; // 数据的起始 RVA DWORD Size; // 数据块的长度&#125; IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY; 总的数据目录一共由16个相同的 IMAGE_DATA_DIRECTORY 结构连续排列在一起组成 索引 名称 说明 0 Export Table 导出表（程序导出的函数信息） 1 Import Table 导入表（程序导入的 DLL 和函数） 2 Resource Table 资源表（图标、对话框、字符串等） 3 Exception Table 异常处理表（SEH） 4 Certificate Table 数字签名证书表 5 Base Relocation 重定位表（Address Fixups） 6 Debug Directory 调试信息表（符号等） 7 Architecture 保留（未使用） 8 GlobalPtr 全局指针（MIPS） 9 TLS Table TLS 初始化数据表（线程本地存储） 10 Load Config Table 加载配置表（安全设置等） 11 Bound Import 绑定导入表（提前绑定信息） 12 IAT 导入地址表（Import Address Table） 13 Delay Import 延迟导入表（延迟加载 DLL） 14 COM Descriptor CLR 运行时头（托管程序） 15 Reserved 保留 1234567IMAGE_OPTIONAL_HEADER├── ...├── IMAGE_DATA_DIRECTORY DataDirectory[16]│ ├── DataDirectory[0] → Export Table│ ├── DataDirectory[1] → Import Table│ ├── DataDirectory[2] → Resource Table│ └── ... 常用的数据目录的用途如下： 数据目录项 作用 导入表 找到程序依赖的 DLL 和函数 导出表 提供外部调用函数的信息（如 DLL 导出函数） 资源表 程序图标、对话框等 GUI 元素 重定位表 可执行文件在加载时修正地址 TLS 表 多线程支持的线程本地变量数据 COM 描述符 .NET 程序的入口点（托管程序） 如果想在PE文件种寻找特定类型的数据 就需要从该结构开始 该结构每个字段后的偏移都是基于 IMAGE_NT_HEADERS 头的 节表项 IMAGE_SECTION_HEADER123456789101112131415typedef struct _IMAGE_SECTION_HEADER &#123; BYTE Name[IMAGE_SIZEOF_SHORT_NAME]; // 8个字节节名 union &#123; DWORD PhysicalAddress; DWORD VirtualSize; // 节区的尺寸 &#125; Misc; DWORD VirtualAddress; // 节区的RVA地址 DWORD SizeOfRawData; // 在文件中对齐后的尺寸 DWORD PointerToRawData; // 在文件中的偏移 DWORD PointerToRelocations; // 在OBJ文件中使用 DWORD PointerToLinenumbers; // 行号表的位置(供调试使用) WORD NumberOfRelocations; // 在OBJ文件中使用 WORD NumberOfLinenumbers; // 行号表中行号的数量 DWORD Characteristics; // 节的属性&#125; IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER; 该偏移是基于 IMAGE_SECTION_HEADER 头的","categories":[],"tags":[{"name":"PE","slug":"PE","permalink":"http://example.com/tags/PE/"}]}],"categories":[],"tags":[{"name":"PWN","slug":"PWN","permalink":"http://example.com/tags/PWN/"},{"name":"编码","slug":"编码","permalink":"http://example.com/tags/%E7%BC%96%E7%A0%81/"},{"name":"PE","slug":"PE","permalink":"http://example.com/tags/PE/"}]}