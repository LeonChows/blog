<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LeonChow</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2025-05-31T12:28:12.469Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Chow</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>关于CheatEngine提示DBVM无法启动以及VMware提示此平台不支持虚拟化的解决方案</title>
    <link href="http://example.com/2025/05/31/%E5%85%B3%E4%BA%8ECheatEngine%E6%8F%90%E7%A4%BADBVM%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8%E4%BB%A5%E5%8F%8AVMware%E6%8F%90%E7%A4%BA%E6%AD%A4%E5%B9%B3%E5%8F%B0%E4%B8%8D%E6%94%AF%E6%8C%81%E8%99%9A%E6%8B%9F%E5%8C%96%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>http://example.com/2025/05/31/%E5%85%B3%E4%BA%8ECheatEngine%E6%8F%90%E7%A4%BADBVM%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8%E4%BB%A5%E5%8F%8AVMware%E6%8F%90%E7%A4%BA%E6%AD%A4%E5%B9%B3%E5%8F%B0%E4%B8%8D%E6%94%AF%E6%8C%81%E8%99%9A%E6%8B%9F%E5%8C%96%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</id>
    <published>2025-05-31T12:19:17.000Z</published>
    <updated>2025-05-31T12:28:12.469Z</updated>
    
    <content type="html"><![CDATA[<h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><ul><li>windows11 24h2 其它系统应该是通用</li></ul><h1 id="步骤1"><a href="#步骤1" class="headerlink" title="步骤1"></a>步骤1</h1><ol><li><p>首先打开控制面板-程序-启动或关闭Windows功能 像这样关闭这些:</p><p><img src="/2025/05/31/%E5%85%B3%E4%BA%8ECheatEngine%E6%8F%90%E7%A4%BADBVM%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8%E4%BB%A5%E5%8F%8AVMware%E6%8F%90%E7%A4%BA%E6%AD%A4%E5%B9%B3%E5%8F%B0%E4%B8%8D%E6%94%AF%E6%8C%81%E8%99%9A%E6%8B%9F%E5%8C%96%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/image-20250531202152090.png" alt="image-20250531202152090"></p></li><li><p>然后再找到服务禁用以下功能</p><p><img src="/2025/05/31/%E5%85%B3%E4%BA%8ECheatEngine%E6%8F%90%E7%A4%BADBVM%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8%E4%BB%A5%E5%8F%8AVMware%E6%8F%90%E7%A4%BA%E6%AD%A4%E5%B9%B3%E5%8F%B0%E4%B8%8D%E6%94%AF%E6%8C%81%E8%99%9A%E6%8B%9F%E5%8C%96%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/image-20250531202227080.png" alt="image-20250531202227080"></p></li><li><p>之后再设置里面搜索内核隔离然后把内核隔离的所有选项关闭</p><p><img src="/2025/05/31/%E5%85%B3%E4%BA%8ECheatEngine%E6%8F%90%E7%A4%BADBVM%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8%E4%BB%A5%E5%8F%8AVMware%E6%8F%90%E7%A4%BA%E6%AD%A4%E5%B9%B3%E5%8F%B0%E4%B8%8D%E6%94%AF%E6%8C%81%E8%99%9A%E6%8B%9F%E5%8C%96%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/image-20250531202419509.png" alt="image-20250531202419509"></p></li><li><p>重启电脑尝试即可 若还是不行请看<strong>步骤2</strong></p></li></ol><h1 id="步骤2-来自-VMware-Workstation：如何解决打开虚拟机出现“此平台不支持虚拟化的Intel-VT-x-EPT”的报错问题-VM技术库"><a href="#步骤2-来自-VMware-Workstation：如何解决打开虚拟机出现“此平台不支持虚拟化的Intel-VT-x-EPT”的报错问题-VM技术库" class="headerlink" title="步骤2 [来自](VMware Workstation：如何解决打开虚拟机出现“此平台不支持虚拟化的Intel VT-x&#x2F;EPT”的报错问题 - VM技术库)"></a>步骤2 [来自](<a href="https://vmlib.com/virtualized-intel-vt-ept-not-supported/">VMware Workstation：如何解决打开虚拟机出现“此平台不支持虚拟化的Intel VT-x&#x2F;EPT”的报错问题 - VM技术库</a>)</h1><p>运行<strong>msinfo32.exe</strong>命令，确认Windows 11的宿主机是否开启了VBS，如果”<strong>基于虚拟化的安全</strong>“那一行后面显示是“<strong>未启用</strong>”，本文内容不适合。如果显示“<strong>正在运行</strong>”，请继续第2步。</p><p><img src="/2025/05/31/%E5%85%B3%E4%BA%8ECheatEngine%E6%8F%90%E7%A4%BADBVM%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8%E4%BB%A5%E5%8F%8AVMware%E6%8F%90%E7%A4%BA%E6%AD%A4%E5%B9%B3%E5%8F%B0%E4%B8%8D%E6%94%AF%E6%8C%81%E8%99%9A%E6%8B%9F%E5%8C%96%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/image-20250531202602321.png" alt="image-20250531202602321"></p><p>之后执行以下脚本 写出一个bat文件即可 记得要管理员运行</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"></span><br><span class="line">dism /Online /Disable-Feature:microsoft-hyper-v-all /NoRestart</span><br><span class="line">dism /Online /Disable-Feature:IsolatedUserMode /NoRestart</span><br><span class="line">dism /Online /Disable-Feature:Microsoft-Hyper-V-Hypervisor /NoRestart</span><br><span class="line">dism /Online /Disable-Feature:Microsoft-Hyper-V-Online /NoRestart</span><br><span class="line">dism /Online /Disable-Feature:HypervisorPlatform /NoRestart</span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">REM ===========================================</span></span><br><span class="line"></span><br><span class="line">mountvol X: /s</span><br><span class="line"><span class="built_in">copy</span> <span class="variable">%WINDIR%</span>\System32\SecConfig.efi X:\EFI\Microsoft\Boot\SecConfig.efi /Y</span><br><span class="line">bcdedit /create &#123;<span class="number">0</span>cb3b571-<span class="number">2</span>f2e-<span class="number">4343</span>-a879-d86a476d7215&#125; /d &quot;DebugTool&quot; /application osloader</span><br><span class="line">bcdedit /<span class="built_in">set</span> &#123;<span class="number">0</span>cb3b571-<span class="number">2</span>f2e-<span class="number">4343</span>-a879-d86a476d7215&#125; <span class="built_in">path</span> &quot;\EFI\Microsoft\Boot\SecConfig.efi&quot;</span><br><span class="line">bcdedit /<span class="built_in">set</span> &#123;bootmgr&#125; bootsequence &#123;<span class="number">0</span>cb3b571-<span class="number">2</span>f2e-<span class="number">4343</span>-a879-d86a476d7215&#125;</span><br><span class="line">bcdedit /<span class="built_in">set</span> &#123;<span class="number">0</span>cb3b571-<span class="number">2</span>f2e-<span class="number">4343</span>-a879-d86a476d7215&#125; loadoptions DISABLE-LSA-ISO,DISABLE-VBS</span><br><span class="line">bcdedit /<span class="built_in">set</span> &#123;<span class="number">0</span>cb3b571-<span class="number">2</span>f2e-<span class="number">4343</span>-a879-d86a476d7215&#125; device partition=X:</span><br><span class="line">mountvol X: /d</span><br><span class="line">bcdedit /<span class="built_in">set</span> hypervisorlaunchtype off</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span>.</span><br><span class="line"><span class="built_in">echo</span>.</span><br><span class="line"><span class="built_in">echo</span>.</span><br><span class="line"><span class="built_in">echo</span>.</span><br><span class="line"><span class="built_in">echo</span> =======================================================</span><br><span class="line"><span class="built_in">echo</span> 当前操作已完成，接下来请关闭此窗口并重启电脑，然后根据屏幕提示完成剩下操作。</span><br><span class="line"><span class="built_in">echo</span> 等到windows重启完成会弹出一个黑框 狂按F3即可</span><br><span class="line"><span class="built_in">pause</span> &gt; <span class="built_in">nul</span></span><br><span class="line"><span class="built_in">echo</span>.</span><br><span class="line"><span class="built_in">echo</span>.</span><br></pre></td></tr></table></figure><p>这样就是成功了 亲测有效 脚本没问题 本人也是被这个问题困扰了很久很久</p><p><img src="/2025/05/31/%E5%85%B3%E4%BA%8ECheatEngine%E6%8F%90%E7%A4%BADBVM%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8%E4%BB%A5%E5%8F%8AVMware%E6%8F%90%E7%A4%BA%E6%AD%A4%E5%B9%B3%E5%8F%B0%E4%B8%8D%E6%94%AF%E6%8C%81%E8%99%9A%E6%8B%9F%E5%8C%96%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/image-20250531202740359.png" alt="image-20250531202740359"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;环境&quot;&gt;&lt;a href=&quot;#环境&quot; class=&quot;headerlink&quot; title=&quot;环境&quot;&gt;&lt;/a&gt;环境&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;windows11 24h2 其它系统应该是通用&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;步骤1&quot;&gt;&lt;a href=&quot;#步骤1&quot; </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>PWN-简单栈溢出</title>
    <link href="http://example.com/2025/05/30/PWN-%E7%AE%80%E5%8D%95%E6%A0%88%E6%BA%A2%E5%87%BA/"/>
    <id>http://example.com/2025/05/30/PWN-%E7%AE%80%E5%8D%95%E6%A0%88%E6%BA%A2%E5%87%BA/</id>
    <published>2025-05-30T06:58:02.000Z</published>
    <updated>2025-05-30T13:58:51.952Z</updated>
    
    <content type="html"><![CDATA[<h1 id="PWN-简单栈溢出"><a href="#PWN-简单栈溢出" class="headerlink" title="PWN-简单栈溢出"></a>PWN-简单栈溢出</h1><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>pwn这门课程简单来说就是通过二进制的形式去找到某台服务器存在哪些漏洞 与web不同的是他大部分的知识都是基于汇编组成的 在 <a href="https://ctf-wiki.org/pwn/linux/user-mode/environment/">CTF-Wiki</a> 里面的介绍则是这样的:</p><blockquote><p>栈溢出指的是程序向栈中某个变量中写入的字节数超过了这个变量本身所申请的字节数，因而导致与其相邻的栈中的变量的值被改变。这种问题是一种特定的缓冲区溢出漏洞，类似的还有堆溢出，bss 段溢出等溢出方式。栈溢出漏洞轻则可以使程序崩溃，重则可以使攻击者控制程序执行流程。此外，我们也不难发现，发生栈溢出的基本前提是：</p><ul><li>程序必须向栈上写入数据。</li><li>写入的数据大小没有被良好地控制。</li></ul></blockquote><span id="more"></span><p>则 栈的介绍如下：</p><h2 id="基本栈介绍-¶"><a href="#基本栈介绍-¶" class="headerlink" title="基本栈介绍 ¶"></a>基本栈介绍 <a href="https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/stack-intro/#_2">¶</a></h2><blockquote><p>栈是一种典型的后进先出 (Last in First Out) 的数据结构，其操作主要有压栈 (push) 与出栈 (pop) 两种操作，如下图所示（维基百科）。两种操作都操作栈顶，当然，它也有栈底。</p><p><img src="/2025/05/30/PWN-%E7%AE%80%E5%8D%95%E6%A0%88%E6%BA%A2%E5%87%BA/image-20250530150427160.png" alt="image-20250530150427160"></p><p>高级语言在运行时都会被转换为汇编程序，在汇编程序运行过程中，充分利用了这一数据结构。每个程序在运行时都有虚拟地址空间，其中某一部分就是该程序对应的栈，用于保存函数调用信息和局部变量。此外，常见的操作也是压栈与出栈。需要注意的是，<strong>程序的栈是从进程地址空间的高地址向低地址增长的</strong>。</p></blockquote><p>这些是简单的栈介绍</p><p>首先 栈是一种特殊的数据结构 他存储了 function runtime 的参数、变量和返回地址他在一次函数调用中是不可或缺的重要部分，其中软件的架构又分为两种</p><p><code>x86</code> 和 <code>x64 </code></p><p>这两种在参数和变量的在栈存储形式上有些不同 例如</p><p><code>x86</code> 的所有参数通过 <strong>栈</strong> 从右到左依次压入 可用以下代码作为示例 使用 <code>visual stdio</code> 编译 x86 版本观查栈</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> _param1, <span class="type">int</span> _param2, <span class="type">int</span> _param3, <span class="type">int</span> _param4, <span class="type">int</span> _param5)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> _param1 + _param2 + _param3 + _param4 + _param5;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">func</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;helloworld\n&quot;</span>;</span><br><span class="line"><span class="built_in">getchar</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/2025/05/30/PWN-%E7%AE%80%E5%8D%95%E6%A0%88%E6%BA%A2%E5%87%BA/image-20250530151556007.png" alt="image-20250530151556007"></p><p>如图所示 我们定位到了 <code>main</code> 函数 然后我们在 <code>func </code> 处下断点 我们让他继续执行到<code>func</code> 执行到 <code>call</code>的时候我们观察栈的变化</p><p><img src="/2025/05/30/PWN-%E7%AE%80%E5%8D%95%E6%A0%88%E6%BA%A2%E5%87%BA/image-20250530151756664.png" alt="image-20250530151756664"></p><p>如图所示 这是一个从低地址到高地址的显示方式 但是在入栈的时候 他是 <strong>从高地址到低地址从右往左参数依次入栈</strong></p><p>然后我们进入call继续查看 进入call的同时我们发现 他先是压入了一个地址 这个地址就是 call 所在地址 + 5 的字节</p><p>所以<code>call xxxxxxxx</code>就等效于 <code>push eip + 5</code> call的机器码占用一个字节 然而地址占用4个字节 其次又跳转到了 后面的地址处 所以call指令做了两件事 先是压入一个返回地址 接着又是进行了一次 <code>jmp</code> 跳转 然后我们接着看</p><p>在跳转过来的函数头部我们发现了两条指令 <code>push ebp</code> <code>mov ebp esp</code> 那么这是什么意思呢？</p><p>其实是 <code>典型的 x86 函数栈帧初始化</code> </p><p>首先将当前的 <code>ebp</code> 寄存器的值压入栈 也就是保存上个函数的栈底地址 <code>(push ebp)</code></p><p>之后把上个函数的栈顶作为当前函数的栈底 <code>(mov ebp esp)</code></p><p>之后就是进行一系类的加法操作 到了 <code>pop ebp</code>的时候 就要销毁此栈帧恢复上一个函数的栈帧了</p><p>然而我们可以发现 函数参数是通过 <code>ebp + n*4</code> 的方式进行访问的 这很关键</p><p>直到执行到 <code>ret</code> 我们会发现 他的效果就等于 <code>jmp esp</code> 为什么这么说 我们接着分析栈</p><p><img src="/2025/05/30/PWN-%E7%AE%80%E5%8D%95%E6%A0%88%E6%BA%A2%E5%87%BA/1f47c933242f43f4df4ea7487f699fc3.png" alt="1f47c933242f43f4df4ea7487f699fc3"></p><p>我们可以发现现在 <code>esp=ebp</code> 为什么说 <code>ret</code> 是 <code>jmp [esp]</code>呢</p><p>因为我们执行完 <code>pop ebp</code> 他就变成了这样</p><p><img src="/2025/05/30/PWN-%E7%AE%80%E5%8D%95%E6%A0%88%E6%BA%A2%E5%87%BA/image-20250530153731951.png" alt="image-20250530153731951"></p><p>也就是返回到刚才call保存的返回值了 </p><p>接着我们来看下<code>x64</code>的栈 </p><p>x64分为两种编译器 在 <code>Linux、FreeBSD、macOS</code> 中普遍使用 <code>System V AMD64 ABI</code> </p><ul><li>前六个整型或指针参数依次保存在 <strong>RDI, RSI, RDX, RCX, R8 和 R9 寄存器</strong>中，如果还有更多的参数的话才会保存在栈上。</li><li>内存地址不能大于 0x00007FFFFFFFFFFF，<strong>6 个字节长度</strong>，否则会抛出异常。</li></ul><p>但在<code>Windows</code>上是 <code>Microsoft x64 calling convention</code> 也称作：</p><ul><li><p>Windows x64 ABI</p></li><li><p>Windows x64 调用约定</p></li></ul><p>他的参数入栈形式如下</p><ul><li><p>前四个整型或指针参数依次保存在 <strong>RCX, RDX, R8, R9</strong>，如果还有更多的参数的话才会保存在栈上。</p></li><li><p>内存地址不能大于 0x00007FFFFFFFFFFF，<strong>6 个字节长度</strong>，否则会抛出异常。</p></li></ul><h2 id="🔍-System-V-AMD64-ABI-vs-Microsoft-x64-ABI-对比"><a href="#🔍-System-V-AMD64-ABI-vs-Microsoft-x64-ABI-对比" class="headerlink" title="🔍 System V AMD64 ABI vs Microsoft x64 ABI 对比"></a>🔍 System V AMD64 ABI vs Microsoft x64 ABI 对比</h2><table><thead><tr><th>特性</th><th>System V AMD64 ABI (Linux&#x2F;macOS)</th><th>Microsoft x64 ABI (Windows x64)</th></tr></thead><tbody><tr><td>参数传递寄存器</td><td>RDI, RSI, RDX, RCX, R8, R9</td><td>RCX, RDX, R8, R9</td></tr><tr><td>返回值</td><td>RAX</td><td>RAX</td></tr><tr><td>栈空间</td><td>被调用者必须保留 <code>red zone</code>（128 字节）</td><td>无 red zone（不能用栈下方空间）</td></tr><tr><td>调用者保存（volatile）寄存器</td><td>RAX, RCX, RDX, RSI, RDI, R8–R11</td><td>RAX, RCX, RDX, R8–R11</td></tr><tr><td>被调用者保存（callee-saved）</td><td>RBX, RBP, R12–R15</td><td>RBX, RBP, RDI, RSI, R12–R15</td></tr><tr><td>参数超过寄存器</td><td>从第 7 个参数起压栈</td><td>从第 5 个参数起压栈</td></tr><tr><td>栈对齐要求</td><td>16 字节</td><td>16 字节</td></tr><tr><td>栈传参对齐方式</td><td>按参数自然大小</td><td>所有参数按 8 字节对齐</td></tr><tr><td>谁清理栈</td><td>被调用者使用 <code>leave</code>+<code>ret</code></td><td>调用者清理（隐含对齐）</td></tr></tbody></table><p>我这边就用Windows用作演示</p><p><img src="/2025/05/30/PWN-%E7%AE%80%E5%8D%95%E6%A0%88%E6%BA%A2%E5%87%BA/image-20250530160001909.png" alt="image-20250530160001909"></p><p>我们也是执行到 <code>func</code> 下断点 然后我们进入这个call</p><p>我们会发现call的操作其实跟x86的call一样 也是 <code>push RIP + 5</code> 然后 <code>jmp 地址</code></p><p>但是这个地址并不是一个绝对地址而是 <strong>相对地址</strong>。</p><p><strong>相对地址跳转（RIP-relative）</strong></p><h2 id="🧮-实际跳转地址计算方式"><a href="#🧮-实际跳转地址计算方式" class="headerlink" title="🧮 实际跳转地址计算方式"></a>🧮 实际跳转地址计算方式</h2><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">目标地址 = 下一条指令地址 + 偏移量</span><br><span class="line">偏移量 = 目标地址 - 下一条指令的地址</span><br><span class="line">下一条指令的地址 = 目标地址 - 偏移量</span><br></pre></td></tr></table></figure></blockquote><p>假设当前 <code>EIP</code> 为 <code>0x1000</code>，也就是 <code>E8</code> 的位置</p><p><code>E8</code> 占 1 字节，后面是 4 字节偏移量，下一条指令的地址是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x1000</span> + <span class="number">5</span> = <span class="number">0x1005</span></span><br></pre></td></tr></table></figure><p>加上偏移量 <code>-0x97</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x1005</span> - <span class="number">0x97</span> = <span class="number">0xF6E</span></span><br></pre></td></tr></table></figure><h2 id="为什么不用绝对地址？"><a href="#为什么不用绝对地址？" class="headerlink" title="为什么不用绝对地址？"></a>为什么不用绝对地址？</h2><p>因为：</p><ol><li><strong>可重定位性更强</strong>：相对寻址无关内存基地址，适合代码段被加载到任意地址；</li><li><strong>指令短</strong>：一个有符号 32 位偏移量足以跳转 ±2GB 的范围；</li><li><strong>兼容 RIP-relative 模型</strong>：x64 强调基于 <code>RIP</code> 的寻址方式；</li></ol><p>根据这张图我们可以计算下 <code>偏移量</code></p><p>也就是 目标地址(<code>00007FF76C6E15F0h</code>) - 下一条地址(<code>00007FF76C6E1687h</code>) &#x3D; 偏移量(<code>FFFF FFFF FFFF FF69h</code>)</p><p>因为要的是一个32位整数 我们要 截断 也就是 <code>FFFF FFFF FFFF FF69h</code> &amp; <code>FFFF FFFFh</code></p><p><code>&amp; 相同为1 不同为0</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0xFFFFFFFFFFFFFF69</span> = <span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11111111</span> <span class="number">01101001</span></span><br><span class="line"><span class="number">0x00000000FFFFFFFF</span> = <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11111111</span></span><br></pre></td></tr></table></figure><p>之后我们继续观察函数里面的内容</p><p><img src="/2025/05/30/PWN-%E7%AE%80%E5%8D%95%E6%A0%88%E6%BA%A2%E5%87%BA/image-20250530161550126.png" alt="image-20250530161550126"></p><p>我们会发现 这边没有<code>push rbp mov rbp rsp</code> 这是为什么呢</p><p>其实这是<strong>编译器优化</strong>的结果</p><p>在 <strong>x64 系统下，编译器不一定使用帧指针（<code>rbp</code>）</strong>，因为：</p><ul><li>x64 有更多寄存器可用（16 个通用寄存器），不需要保留 <code>rbp</code>；</li><li><code>rbp</code> 被当作普通寄存器用；</li><li>栈偏移通过 <code>rsp + 偏移</code> 就可以直接访问，不需要 <code>rbp</code>；</li><li>使用 <code>rbp</code> 反而浪费一个寄存器、增加指令数。</li></ul><p>首先就是拿出来参数放到栈上进行一系列加法之后到 <code>ret</code></p><p>这里就是 <code>jmp [esp]</code>的值了</p><p>至此对函数栈的简单介绍就到这里了 然后我们要思考一个问题 ​</p><p><strong>假如函数的参数的大小是八个字节 但是我们输入了过多的字符 导致该参数占用10个字节 这会导致什么问题呢？</strong>🤔</p><h1 id="栈溢出"><a href="#栈溢出" class="headerlink" title="栈溢出"></a>栈溢出</h1><p>没错 这就导致了过多的字符覆盖了低地址处的栈空间 然而这就是 <code>栈溢出</code>  这个问题导致的漏洞危害极大 如果我们可以把输入的字符覆盖到返回地址也就是call保存的返回值处 然后我们刚好可以构造出一段恶意代码 并且让他跳转到含有关键数据的函数 例如 system 或者 拿到了shell权限 对于我们的服务器来说是一场致命打击 💥</p><p>举个例子 假如我们手里刚好有一个这样的程序 刚好有一个可以被栈溢出的函数 我们可以用 <code>gdb</code>去测试一下</p><p><img src="/2025/05/30/PWN-%E7%AE%80%E5%8D%95%E6%A0%88%E6%BA%A2%E5%87%BA/image-20250530164438269.png" alt="image-20250530164438269"></p><p>根据图中所示 我们可以先用<code>gdb</code>加载 然后再 <code>main</code>函数上下个断点</p><p>我们输入 <code>r</code> 执行</p><p><img src="/2025/05/30/PWN-%E7%AE%80%E5%8D%95%E6%A0%88%E6%BA%A2%E5%87%BA/image-20250530164633031.png" alt="image-20250530164633031"></p><p>他断到了这里然后我们一直走到 <code>gets</code> 这个函数</p><p>为什么要走到 <code>gets</code> 呢 因为 <code>gets</code> 这个函数他是一个输入函数 他把值输入到了栈中 但是不限制输入大小 我们可以通过这个方式 去修改最后<code>ret</code>的值</p><p>在此之前我们需要通过 <code>cyclic</code> 指令生成一堆杂乱的数据 方便我们后续直接定位栈偏移</p><p><img src="/2025/05/30/PWN-%E7%AE%80%E5%8D%95%E6%A0%88%E6%BA%A2%E5%87%BA/image-20250530164851352.png" alt="image-20250530164851352"></p><p>使用 <code>ni</code> 指令单步</p><p>执行到 <code>ret</code> 指令我们就继续使用 <code>cyclic -l </code>去计算他的偏移</p><p><img src="/2025/05/30/PWN-%E7%AE%80%E5%8D%95%E6%A0%88%E6%BA%A2%E5%87%BA/image-20250530172005605.png" alt="image-20250530172005605"></p><p>然后这时候我们拿到了偏移量 那么怎么构造他的shell呢 这时候我们就要用 <code>pwntools</code> 了 <code>exp</code> 如下所示</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 载入库</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> * </span><br><span class="line"><span class="comment"># 打开进程</span></span><br><span class="line">p = process(<span class="string">&#x27;ret2text&#x27;</span>)</span><br><span class="line"><span class="comment"># 附加调试器</span></span><br><span class="line"><span class="comment"># gdb.attach(p) 可以观看流程</span></span><br><span class="line"><span class="comment"># 构建 payload</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">112</span>+p32(<span class="number">0x804863A</span>)</span><br><span class="line"><span class="comment"># 发送payload</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line"><span class="comment"># 用户交互</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>执行之后是这样的</p><p><img src="/2025/05/30/PWN-%E7%AE%80%E5%8D%95%E6%A0%88%E6%BA%A2%E5%87%BA/image-20250530172320533.png" alt="image-20250530172320533"></p><h1 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h1>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;PWN-简单栈溢出&quot;&gt;&lt;a href=&quot;#PWN-简单栈溢出&quot; class=&quot;headerlink&quot; title=&quot;PWN-简单栈溢出&quot;&gt;&lt;/a&gt;PWN-简单栈溢出&lt;/h1&gt;&lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;p&gt;pwn这门课程简单来说就是通过二进制的形式去找到某台服务器存在哪些漏洞 与web不同的是他大部分的知识都是基于汇编组成的 在 &lt;a href=&quot;https://ctf-wiki.org/pwn/linux/user-mode/environment/&quot;&gt;CTF-Wiki&lt;/a&gt; 里面的介绍则是这样的:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;栈溢出指的是程序向栈中某个变量中写入的字节数超过了这个变量本身所申请的字节数，因而导致与其相邻的栈中的变量的值被改变。这种问题是一种特定的缓冲区溢出漏洞，类似的还有堆溢出，bss 段溢出等溢出方式。栈溢出漏洞轻则可以使程序崩溃，重则可以使攻击者控制程序执行流程。此外，我们也不难发现，发生栈溢出的基本前提是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;程序必须向栈上写入数据。&lt;/li&gt;
&lt;li&gt;写入的数据大小没有被良好地控制。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="PWN" scheme="http://example.com/tags/PWN/"/>
    
  </entry>
  
  <entry>
    <title>编码</title>
    <link href="http://example.com/2025/05/29/%E7%BC%96%E7%A0%81/"/>
    <id>http://example.com/2025/05/29/%E7%BC%96%E7%A0%81/</id>
    <published>2025-05-29T13:32:56.000Z</published>
    <updated>2025-05-30T13:59:21.730Z</updated>
    
    <content type="html"><![CDATA[<h1 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h1><h1 id="ASCII编码"><a href="#ASCII编码" class="headerlink" title="ASCII编码"></a>ASCII编码</h1><blockquote><p>使用一个字节来表示字符串中的字符，称为ANSI字符串。</p><p>ASCII（American Standard Code for Information Interchange）是 <strong>美国信息交换标准代码</strong>，它使用 <strong>7 位</strong> 来表示一个字符，共定义了 128 个字符，范围是 <strong>0 ~ 127</strong>，包括：</p><p>英文字母（A<del>Z，a</del>z）</p><p>数字（0~9）</p><p>标点符号（如 <code>!</code>、<code>,</code>、<code>.</code> 等）</p><p>控制字符（如换行符 <code>\n</code>，回车 <code>\r</code>）</p><h3 id="2-在-C-语言中的表现"><a href="#2-在-C-语言中的表现" class="headerlink" title="2. 在 C 语言中的表现"></a>2. 在 C 语言中的表现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> c = <span class="string">&#x27;A&#x27;</span>;         <span class="comment">// 字符A的ASCII值是65</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;字符: %c, ASCII码: %d\n&quot;</span>, c, c);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">字符: A, ASCII码: <span class="number">65</span></span><br></pre></td></tr></table></figure></blockquote><span id="more"></span><h1 id="Unicode编码-双字节"><a href="#Unicode编码-双字节" class="headerlink" title="Unicode编码(双字节)"></a>Unicode编码(双字节)</h1><blockquote><p>Unicode是继ASCII字符编码后的另一种新型字符编码。严格意义上讲，ASCII码的每个字符使用7位表示Unicode则使用全16位表示一个字符。Unicode字符串中的每个字符均为双字节，所以又称为宽字符串。由于Unicode兼容ASCII字符，所以被大多数程序所支持，如Windows内核。Unicode的前128个字符码（十六进制，0x0000<del>0x007F）同ASCII码具有同样的字节值。比如，字母“a”的Unicode编码是0x0061，而“a”的ASCII编码是0x61。虽然占用的字节数不一样，但是两者的值是一样的。接下来的128个Unicode字符（代码为0x0080</del>0x00FF)是ISO8859-1对ASCII码的扩展。中国、日本和韩国的象形文字（总称为CJK）占用了0x3000~0x9FFF的代码。如“汉”字的Unicode编码是6C49h（其GB码为0BABAh)。 Unicode字符串不像ANSI字符串那样，保证用字符“\0”结束；如果开发者在程序设计时以字符“\0”作为Unicode字符串结尾的判断条件，就可能发生错误。</p><p>在汇编语言中，Unicode字符串被定义为一个结构体，它的定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_UNICODE_STRING</span> &#123;</span><br><span class="line">  USHORT Length;<span class="comment">//字符串长度</span></span><br><span class="line">  USHORT MaximumLength;<span class="comment">//字符串缓冲区长度</span></span><br><span class="line">  PWSTR  Buffer;<span class="comment">//字符串缓冲区</span></span><br><span class="line">&#125; UNICODE_STRING, *PUNICODE_STRING;</span><br></pre></td></tr></table></figure><p>由于我们无法保证Unicode字符串结尾一定是“\0”，所以在结构体中，字段Length定义<br>了字符串的长度。一个安全的字符串还必须限定字符的总长度，这由MaximumLength来实现。</p><ul><li>UTF-8、UTF-16、UTF-32 是 Unicode 的<strong>编码方式</strong><ul><li>UTF-8：多字节，1~4 字节</li><li>UTF-16：2 或 4 字节</li><li>UTF-32：固定 4 字节（效率低，体积大）</li></ul></li></ul><h2 id="C-语言中的示例对比"><a href="#C-语言中的示例对比" class="headerlink" title="C 语言中的示例对比"></a>C 语言中的示例对比</h2><h3 id="✅-Unicode-码点的概念（逻辑编号）"><a href="#✅-Unicode-码点的概念（逻辑编号）" class="headerlink" title="✅ Unicode 码点的概念（逻辑编号）"></a>✅ Unicode 码点的概念（逻辑编号）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;wchar.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;locale.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    setlocale(LC_ALL, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="type">wchar_t</span> ch = <span class="string">L&#x27;你&#x27;</span>;</span><br><span class="line">    wprintf(<span class="string">L&quot;字符: %lc, Unicode码点: U+%04X\n&quot;</span>, ch, ch);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出（在 UTF-8 环境中）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">字符: 你, Unicode码点: U+<span class="number">4F</span>60</span><br></pre></td></tr></table></figure></blockquote><h1 id="多字节编码"><a href="#多字节编码" class="headerlink" title="多字节编码"></a>多字节编码</h1><blockquote><p>多字节编码一般都是在 ASCII 的基础上进行扩展或兼容设计的。</p><h2 id="🔷-一、为什么基于-ASCII-扩展？"><a href="#🔷-一、为什么基于-ASCII-扩展？" class="headerlink" title="🔷 一、为什么基于 ASCII 扩展？"></a>🔷 一、为什么基于 ASCII 扩展？</h2><h3 id="✅-兼容性原则"><a href="#✅-兼容性原则" class="headerlink" title="✅ 兼容性原则"></a>✅ 兼容性原则</h3><p>早期的系统、程序、协议都是基于 ASCII 设计的，为了不打破已有的英文文本和软件兼容性，后来设计的多字节编码（如 GBK、UTF-8）都：</p><ul><li>保留 ASCII 范围（0x00 ~ 0x7F）作为<strong>单字节直接使用</strong></li><li>超出 ASCII 的字符才用 <strong>多个字节组合表示</strong></li></ul><hr><h2 id="🔷-二、是如何在-ASCII-基础上扩展的？"><a href="#🔷-二、是如何在-ASCII-基础上扩展的？" class="headerlink" title="🔷 二、是如何在 ASCII 基础上扩展的？"></a>🔷 二、是如何在 ASCII 基础上扩展的？</h2><h3 id="1-ASCII-基本规则"><a href="#1-ASCII-基本规则" class="headerlink" title="1. ASCII 基本规则"></a>1. ASCII 基本规则</h3><table><thead><tr><th>字符</th><th>二进制（7位）</th><th>十六进制</th></tr></thead><tbody><tr><td>A</td><td>01000001</td><td>0x41</td></tr><tr><td>z</td><td>01111010</td><td>0x7A</td></tr><tr><td>空格</td><td>00100000</td><td>0x20</td></tr></tbody></table><blockquote><p>所有 ASCII 字符的最高位（第8位）都是 <code>0</code></p></blockquote><hr><h3 id="2-多字节编码（如-UTF-8）的扩展方式"><a href="#2-多字节编码（如-UTF-8）的扩展方式" class="headerlink" title="2. 多字节编码（如 UTF-8）的扩展方式"></a>2. 多字节编码（如 UTF-8）的扩展方式</h3><p>UTF-8 保证：</p><ul><li><code>0xxxxxxx</code> 表示 ASCII → 保留单字节（最高位为 0）</li><li>非 ASCII → 多字节以 <code>1xxxxxxx</code> 开头（高位 1）</li></ul><h4 id="UTF-8-编码示意："><a href="#UTF-8-编码示意：" class="headerlink" title="UTF-8 编码示意："></a>UTF-8 编码示意：</h4><table><thead><tr><th>编码字节数</th><th>前缀规则</th><th>可表示的字符范围</th></tr></thead><tbody><tr><td>1字节</td><td><code>0xxxxxxx</code></td><td>ASCII（U+0000 ~ U+007F）</td></tr><tr><td>2字节</td><td><code>110xxxxx 10xxxxxx</code></td><td>U+0080 ~ U+07FF</td></tr><tr><td>3字节</td><td><code>1110xxxx 10xxxxxx 10xxxxxx</code></td><td>U+0800 ~ U+FFFF</td></tr></tbody></table><h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><p>“你” 字：Unicode &#x3D; U+4F60<br> UTF-8 编码 → <code>0xE4 0xBD 0xA0</code></p><hr><h3 id="3-GBK-等编码也是类似原则"><a href="#3-GBK-等编码也是类似原则" class="headerlink" title="3. GBK 等编码也是类似原则"></a>3. GBK 等编码也是类似原则</h3><p>GBK：</p><ul><li>ASCII：0x00~0x7F，单字节直接使用</li><li>中文：0x81~0xFE 开头的多字节组合</li></ul><h4 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h4><table><thead><tr><th>字符</th><th>GBK 编码</th></tr></thead><tbody><tr><td>A</td><td>0x41</td></tr><tr><td>“你”</td><td>0xC4 0xE3</td></tr></tbody></table><hr><h2 id="🔷-三、可视化对比"><a href="#🔷-三、可视化对比" class="headerlink" title="🔷 三、可视化对比"></a>🔷 三、可视化对比</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">diff复制编辑+----------------------+------------------------+</span><br><span class="line">| ASCII                |  0x41 (A), 0x61 (a)    |</span><br><span class="line">+----------------------+------------------------+</span><br><span class="line">| UTF-8                |  A -&gt; 0x41             |</span><br><span class="line">|                      |  你 -&gt; 0xE4 0xBD 0xA0  |</span><br><span class="line">+----------------------+------------------------+</span><br><span class="line">| GBK                  |  A -&gt; 0x41             |</span><br><span class="line">|                      |  你 -&gt; 0xC4 0xE3       |</span><br><span class="line">+----------------------+------------------------+</span><br></pre></td></tr></table></figure><p>✅ <strong>结论：</strong></p><blockquote><p>多字节编码不会破坏 ASCII 表示方式，而是在此基础上扩展更高位字符。</p></blockquote><hr><h2 id="🔷-四、C-语言验证例子：ASCII-多字节输出"><a href="#🔷-四、C-语言验证例子：ASCII-多字节输出" class="headerlink" title="🔷 四、C 语言验证例子：ASCII + 多字节输出"></a>🔷 四、C 语言验证例子：ASCII + 多字节输出</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">c复制编辑#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    char *ascii = &quot;A&quot;;     // ASCII 单字节</span><br><span class="line">    char *utf8 = &quot;你&quot;;     // UTF-8 多字节</span><br><span class="line"></span><br><span class="line">    printf(&quot;ASCII 字符: %s\n&quot;, ascii);</span><br><span class="line">    printf(&quot;UTF-8 字符: %s\n&quot;, utf8);</span><br><span class="line"></span><br><span class="line">    printf(&quot;UTF-8 字节: &quot;);</span><br><span class="line">    for (int i = 0; utf8[i] != &#x27;\0&#x27;; i++) &#123;</span><br><span class="line">        printf(&quot;%02X &quot;, (unsigned char)utf8[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">less复制编辑ASCII 字符: A</span><br><span class="line">UTF-8 字符: 你</span><br><span class="line">UTF-8 字节: E4 BD A0</span><br></pre></td></tr></table></figure><hr><h2 id="🔷-五、总结一句话"><a href="#🔷-五、总结一句话" class="headerlink" title="🔷 五、总结一句话"></a>🔷 五、总结一句话</h2><blockquote><p><strong>多字节编码方案（如 UTF-8、GBK）都是在 ASCII 基础上添加高字节区域来扩展更多语言字符，同时保持对 ASCII 的完全兼容。</strong></p></blockquote></blockquote>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;编码&quot;&gt;&lt;a href=&quot;#编码&quot; class=&quot;headerlink&quot; title=&quot;编码&quot;&gt;&lt;/a&gt;编码&lt;/h1&gt;&lt;h1 id=&quot;ASCII编码&quot;&gt;&lt;a href=&quot;#ASCII编码&quot; class=&quot;headerlink&quot; title=&quot;ASCII编码&quot;&gt;&lt;/a&gt;ASCII编码&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;使用一个字节来表示字符串中的字符，称为ANSI字符串。&lt;/p&gt;
&lt;p&gt;ASCII（American Standard Code for Information Interchange）是 &lt;strong&gt;美国信息交换标准代码&lt;/strong&gt;，它使用 &lt;strong&gt;7 位&lt;/strong&gt; 来表示一个字符，共定义了 128 个字符，范围是 &lt;strong&gt;0 ~ 127&lt;/strong&gt;，包括：&lt;/p&gt;
&lt;p&gt;英文字母（A&lt;del&gt;Z，a&lt;/del&gt;z）&lt;/p&gt;
&lt;p&gt;数字（0~9）&lt;/p&gt;
&lt;p&gt;标点符号（如 &lt;code&gt;!&lt;/code&gt;、&lt;code&gt;,&lt;/code&gt;、&lt;code&gt;.&lt;/code&gt; 等）&lt;/p&gt;
&lt;p&gt;控制字符（如换行符 &lt;code&gt;&#92;n&lt;/code&gt;，回车 &lt;code&gt;&#92;r&lt;/code&gt;）&lt;/p&gt;
&lt;h3 id=&quot;2-在-C-语言中的表现&quot;&gt;&lt;a href=&quot;#2-在-C-语言中的表现&quot; class=&quot;headerlink&quot; title=&quot;2. 在 C 语言中的表现&quot;&gt;&lt;/a&gt;2. 在 C 语言中的表现&lt;/h3&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title function_&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;type&quot;&gt;char&lt;/span&gt; c = &lt;span class=&quot;string&quot;&gt;&amp;#x27;A&amp;#x27;&lt;/span&gt;;         &lt;span class=&quot;comment&quot;&gt;// 字符A的ASCII值是65&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&amp;quot;字符: %c, ASCII码: %d&#92;n&amp;quot;&lt;/span&gt;, c, c);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;输出：&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;字符: A, ASCII码: &lt;span class=&quot;number&quot;&gt;65&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="编码" scheme="http://example.com/tags/%E7%BC%96%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>PElearn</title>
    <link href="http://example.com/2025/05/29/PElearn/"/>
    <id>http://example.com/2025/05/29/PElearn/</id>
    <published>2025-05-29T13:31:56.000Z</published>
    <updated>2025-05-30T13:58:43.248Z</updated>
    
    <content type="html"><![CDATA[<h1 id="PE-学习笔记-一"><a href="#PE-学习笔记-一" class="headerlink" title="PE 学习笔记(一)"></a>PE 学习笔记(一)</h1><p>先来几张图片放在最前面</p><p><img src="/2025/05/29/PElearn/PE%E7%BB%93%E6%9E%841.jpeg" alt="PE结构1"></p><span id="more"></span><p><img src="/2025/05/29/PElearn/PE%E7%BB%93%E6%9E%842.jpeg" alt="PE结构2"></p><p><img src="/2025/05/29/PElearn/PE%E7%BB%93%E6%9E%843.png" alt="PE结构3"></p><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>本帖子大部分出自书籍 《Windows PE权威指南》因需要复习PE知识 故此记录</p><h2 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h2><p>地址有四类，它们分别是：<br><strong>虚拟内存地址（VA)</strong><br><strong>相对虚拟内存地址（RVA）</strong><br><strong>文件偏移地址（FOA)</strong><br><strong>特殊地址</strong></p><h6 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h6><blockquote><p>32 位环境下的Windows内存管理<br>32位CPU的寻址能力为4GB（即2²个字节)，但有些用户的物理内存达不到这个值。<br>于是操作系统和CPU的内存管理单元共同作用，为用户提供了虚拟内存的管理机制。即分页机制。该机制可以让用户感觉自己好像在使用4GB的内存。</p><p>分页机制的基本原理是：<br>操作系统假设一个进程独立拥有4GB内存，按照某个固定的大小（如4KB）将这4GB空间分成N（1M）个页。在某一时刻，所有这些页只有一部分和物理内存是对应的（所以这种机制允许物理内存比4GB小)。没有物理内存对应的页面被标记为脏(dirty)的页面，一般存储在一个名为“交换文件”的磁盘文件中。在WindowsXP系统中，交换文件为pagefile.sys，它位于系统盘的根目录，是一个系统隐藏文件。当系统需要读取未在内存中的数据时，这部分数据会将内存中不经常读写的页交换出内存，而把要读取的、位于交换文件中的页换进内存。通过这种存取机制可以让一个进程拥有比实际内存大得多的内存。利用这种机制管理的<br>内存称为虚拟内存。</p></blockquote><h2 id="虚拟内存地址"><a href="#虚拟内存地址" class="headerlink" title="虚拟内存地址"></a>虚拟内存地址</h2><p><strong>VA &#x3D; 进程基地址+相对虚拟内存地址</strong></p><h2 id="相对虚拟内存地址"><a href="#相对虚拟内存地址" class="headerlink" title="相对虚拟内存地址"></a>相对虚拟内存地址</h2><p><strong>RVA &#x3D; 某个特定位置距离某个模块基地址的偏移量</strong></p><h3 id="关于VA和RVA的概念如图所示"><a href="#关于VA和RVA的概念如图所示" class="headerlink" title="关于VA和RVA的概念如图所示"></a>关于VA和RVA的概念如图所示</h3><p><img src="/2025/05/29/PElearn/%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="内存地址示意图.png"></p><p>假设模块2的基地址为0x01000000，而模块2中的某个位置距离模块2的基地址偏移为400h，那么值0x00000400就是模块2中某个位置的RVA，而值0x01000400是该位置的VA。记住，RVA是相对于模块而言的，VA是相对于整个地址空间而言的。注意RVA与具体模块相关，它有一个范围，该范围从模块的开始到模块结束，脱离开这个范围的RVA是无效的，称为越界。越界的RVA地址没有任何意义。</p><h2 id="文件偏移地址"><a href="#文件偏移地址" class="headerlink" title="文件偏移地址"></a>文件偏移地址</h2><p>文件偏移地址(File Offset Address, FOA) 和内存无关，它是<strong>指某个位置距离文件头的偏移。</strong></p><h2 id="特殊地址"><a href="#特殊地址" class="headerlink" title="特殊地址"></a>特殊地址</h2><p>比较少见</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="数据目录"><a href="#数据目录" class="headerlink" title="数据目录"></a>数据目录</h3><ul><li>导出表</li><li>导入表</li><li>资源表</li><li>异常表</li><li>属性证书表</li><li>重定位表</li><li>调试数据</li><li>Architecture</li><li>Global Ptr</li><li>线程局部存储</li><li>加载配置表</li><li>绑定导入表</li><li>IAT</li><li>延时导入表</li><li>CLR运行时头部</li></ul><h3 id="节"><a href="#节" class="headerlink" title="节"></a>节</h3><p>主要是用来存放不同类型数据(代码、数据、常量、资源等) 不同节有不同的访问权限</p><h3 id="对齐"><a href="#对齐" class="headerlink" title="对齐"></a>对齐</h3><p>数据在内存中的对齐、数据在文件中的对齐、资源文件中资源数据的对齐</p><h4 id="内存对齐"><a href="#内存对齐" class="headerlink" title="内存对齐"></a>内存对齐</h4><p><strong>节在内存中的对齐单位必须至少是一个页的大小 32位 &#x3D; 4kb (1000h) 64位&#x3D;8kb (2000h)</strong></p><h4 id="文件对齐"><a href="#文件对齐" class="headerlink" title="文件对齐"></a>文件对齐</h4><p><strong>节在文件中的对齐要小于内存中的对齐 通常会以一个物理扇区的大小作为对齐粒度的值也就是512字节 十六进制表示 (200h)</strong></p><p>出于节约资源的考虑，<strong>操作系统允许节在内存和文件中的对齐尺寸不一致</strong>。这就直接造成了<strong>PE在文件中和在内存中的大小也会不一致</strong>。通常情况下，<strong>PE在内存中的尺寸要比在文件中的尺寸大</strong>。用户可以自己定义这些对齐的值。</p><p><strong>如果内存对齐被定义为小于操作系统页的大小，则文件对齐和内存对齐的值必须一致！</strong></p><h4 id="资源数据对齐"><a href="#资源数据对齐" class="headerlink" title="资源数据对齐"></a>资源数据对齐</h4><p>资源文件中，资源字节码部分一般要求以双字（4个字节）方式对齐</p><h1 id="PE文件结构"><a href="#PE文件结构" class="headerlink" title="PE文件结构"></a>PE文件结构</h1><p><img src="/2025/05/29/PElearn/image-20250530200634595.png" alt="Windows DOS头 结构体"></p><p>在十六位系统中 PE头和PE结构数据被当成是冗余数据 在32位系统中 刚好相反 即DOS头成为冗余数据 所谓冗余 是针对DOS头不参与 32位系统运行过程而言 尽管该部分不参与运行 但也不能把这些数据从PE结构中出去 因为<code>DOS MZ</code>头中有一个字段非常重要 即 <code>IMAGE_DOS_HEADER.e_lfanew</code> 没有他操作系统就定位不到标准的PE头部 可执行程序也就会被操作系统认为是非法的PE映像</p><p>定位标准PE头</p><p>由于DOS Stub的长度不固定 导致了DOS头也不是一个固定大小的数据结构 那么在WindowsPE中 既然把DOS头放在了PE的起始位置 如果去定位后面的标准PE头所在的位置呢 字段e_lfanew 即起这个作用 该字段的值是一个 <strong>相对偏移量</strong> 相对定位时需要加上DOS MZ 头的基地址 也就是说 通过以下公式可以得到PE头的绝对位置 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PE_start = DOS MZ 基地址 + IMAGE_DOS_HEADER.e_lfanew</span><br></pre></td></tr></table></figure><p><img src="/2025/05/29/PElearn/image-20250530201624808.png" alt="PE结构划分"></p><p>大概分为五个部分 <code>DOS MZ头</code> <code>DOS Stub</code> <code>PE头</code> <code>节表</code> <code>节内容</code></p><p>PE头是由 IMAGE_FILE_HEADER.SizeOfOptionalHeader 来确定大小的</p><p>节的数量是由字段 IMAGE_FILE_HEADER.NumberOfSections来定义的 DOS Stub和节内容都是大小不确定的</p><p>节的内容大小不确定</p><p><img src="/2025/05/29/PElearn/image-20250530202216573.png" alt="程序员眼中的PE结构"></p><p>一个标准的PE文件一般由四大部分组成:</p><ol><li>DOS头</li><li>PE头</li><li>节表</li><li>节内容</li></ol><p><img src="/2025/05/29/PElearn/image-20250530202544824.png" alt="DOS头"></p><p>紧跟在DOS stub后面的是PE头标识 <code>Signature </code>与大部分文件格式的头部结构一样 PE头部信息中有一个四字节的标识 该标识位于指针IMAGE_DOS_HEADER.e_lfanew 指向的位置 其内容固定 对应于ASCII码的字符串 “PE\0\0”</p><h1 id="标准PE头-IMAGE-FILE-HEADER"><a href="#标准PE头-IMAGE-FILE-HEADER" class="headerlink" title="标准PE头 IMAGE_FILE_HEADER"></a>标准PE头 IMAGE_FILE_HEADER</h1><p>紧跟在PE头标识后 即位于IMAGE_DOS_HEADER 的 e_lfanew值+4的位置 由此位置开始的20个字节为数据结构标准PE头IMAGE_FILE_HEADER的内容 该结构在微软的官方文档中被称为<strong>标准通用对象文件格式 (Common Object File Format COFF)头 它记录了PE文件的全局属性</strong></p><p>例如 PE文件的运行平台、PE文件类型、文件中存在节的总数等 定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_IMAGE_FILE_HEADER</span> &#123;</span><br><span class="line">  WORD  Machine;<span class="comment">// 平台</span></span><br><span class="line">  WORD  NumberOfSections;<span class="comment">// pe中节的数量</span></span><br><span class="line">  DWORD TimeDateStamp;<span class="comment">// 文件创建日期和时间</span></span><br><span class="line">  DWORD PointerToSymbolTable;<span class="comment">// 指向符号表(用于调试)</span></span><br><span class="line">  DWORD NumberOfSymbols;<span class="comment">// 符号表中的符号数量(用于调试)</span></span><br><span class="line">  WORD  SizeOfOptionalHeader;<span class="comment">// 扩展头结构的长度</span></span><br><span class="line">  WORD  Characteristics;<span class="comment">// 文件属性</span></span><br><span class="line">&#125; IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;</span><br></pre></td></tr></table></figure><p>该结构可以用于判断PE文件是EXE还是DLL类型 不但可以通过该结构得到PE文件中节的总量，还可以当成对节区信息进行遍历操作时的循环次数</p><p><img src="/2025/05/29/PElearn/PE%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B%E8%A1%A8.png" alt="PE平台类型表"></p><p><img src="/2025/05/29/PElearn/%E6%96%87%E4%BB%B6%E5%B1%9E%E6%80%A7%E8%A1%A8.png" alt="PE文件属性表"></p><h1 id="扩展PE头-IMAGE-OPTIONAL-HEADER32"><a href="#扩展PE头-IMAGE-OPTIONAL-HEADER32" class="headerlink" title="扩展PE头 IMAGE_OPTIONAL_HEADER32"></a>扩展PE头 IMAGE_OPTIONAL_HEADER32</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_IMAGE_OPTIONAL_HEADER</span> &#123;</span><br><span class="line">  WORD                 Magic;<span class="comment">// 魔术字</span></span><br><span class="line">  BYTE                 MajorLinkerVersion;<span class="comment">// 链接器版本号</span></span><br><span class="line">  BYTE                 MinorLinkerVersion;<span class="comment">// 连接器次版本号</span></span><br><span class="line">  DWORD                SizeOfCode;<span class="comment">// 所有含代码的节的总大小</span></span><br><span class="line">  DWORD                SizeOfInitializedData;<span class="comment">// 所以含已初始化数据的节的总大小</span></span><br><span class="line">  DWORD                SizeOfUninitializedData;<span class="comment">// 所有含未初始化数据的节的大小</span></span><br><span class="line">  DWORD                AddressOfEntryPoint;<span class="comment">// 程序执行入口 RVA</span></span><br><span class="line">  DWORD                BaseOfCode;<span class="comment">// 代码的节的起始RVA</span></span><br><span class="line">  DWORD                BaseOfData;<span class="comment">// 数据的节的起始RVA</span></span><br><span class="line">  DWORD                ImageBase;<span class="comment">// 程序的建议装载地址</span></span><br><span class="line">  DWORD                SectionAlignment;<span class="comment">// 内存中节的对齐粒度</span></span><br><span class="line">  DWORD                FileAlignment;<span class="comment">// 文件中节的对齐粒度</span></span><br><span class="line">  WORD                 MajorOperatingSystemVersion;<span class="comment">// 操作系统的版本号</span></span><br><span class="line">  WORD                 MinorOperatingSystemVersion;<span class="comment">// 操作系统的次版本号</span></span><br><span class="line">  WORD                 MajorImageVersion;<span class="comment">// 该PE的版本号</span></span><br><span class="line">  WORD                 MinorImageVersion;<span class="comment">// 该PE的次版本号</span></span><br><span class="line">  WORD                 MajorSubsystemVersion;<span class="comment">// 所需子系统的版本号</span></span><br><span class="line">  WORD                 MinorSubsystemVersion;<span class="comment">// 所需子系统的次版本号</span></span><br><span class="line">  DWORD                Win32VersionValue;<span class="comment">// 未用</span></span><br><span class="line">  DWORD                SizeOfImage;<span class="comment">// 内存中整个PE映像的尺寸</span></span><br><span class="line">  DWORD                SizeOfHeaders;<span class="comment">// 所有头+节表的大小</span></span><br><span class="line">  DWORD                CheckSum;<span class="comment">// 校验和</span></span><br><span class="line">  WORD                 Subsystem;<span class="comment">// 文件的子系统</span></span><br><span class="line">  WORD                 DllCharacteristics;<span class="comment">// DLL文件特征</span></span><br><span class="line">  DWORD                SizeOfStackReserve;<span class="comment">// 初始化时的栈大小</span></span><br><span class="line">  DWORD                SizeOfStackCommit;<span class="comment">// 初始化时实际提交的栈大小</span></span><br><span class="line">  DWORD                SizeOfHeapReserve;<span class="comment">// 初始化时保留的堆大小</span></span><br><span class="line">  DWORD                SizeOfHeapCommit;<span class="comment">// 初始化时实际提交的堆大小</span></span><br><span class="line">  DWORD                LoaderFlags;<span class="comment">// 与调试有关</span></span><br><span class="line">  DWORD                NumberOfRvaAndSizes;<span class="comment">// 下面的数据目录结构的项目数量</span></span><br><span class="line">  IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES]; <span class="comment">//数据目录</span></span><br><span class="line">&#125; IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;</span><br></pre></td></tr></table></figure><p>文件执行的入口 文件被操作系统装入内存后的默认基地址 以及节在磁盘和内存中的对齐单位等信息 均可在此结构中找到 对该结构的某些数值改动都可以会造成PE文件的加载或运行失败</p><h1 id="IMAGE-NT-HEADERS"><a href="#IMAGE-NT-HEADERS" class="headerlink" title="IMAGE_NT_HEADERS"></a>IMAGE_NT_HEADERS</h1><p>这个结构广义上的PE头 在标准PE文件中其大小为456个字节 他是以上两种结构的组好 即</p><p>IMAGE_NT_HEADERS &#x3D; 4个字节的PE标识 + IMAGE_FILE_HEADER+IMAGE_OPTIONAL_HEADER32</p><p><img src="/2025/05/29/PElearn/image-20250530210301652.png" alt="PE结构"></p><p>该结构的详细定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_IMAGE_NT_HEADERS</span> &#123;</span><br><span class="line">  DWORD                   Signature;<span class="comment">// PE头标识</span></span><br><span class="line">  IMAGE_FILE_HEADER       FileHeader;<span class="comment">// PE标准头</span></span><br><span class="line">  IMAGE_OPTIONAL_HEADER32 OptionalHeader;<span class="comment">// PE扩展头</span></span><br><span class="line">&#125; IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32;</span><br></pre></td></tr></table></figure><p>与DOS头一样 PE头开始也是一个标志 用一个双字的 “PE\0\0” 来命名 这也是PE头的由来</p><h1 id="数据目录项-IMAGE-DATA-DIRECTORY"><a href="#数据目录项-IMAGE-DATA-DIRECTORY" class="headerlink" title="数据目录项 IMAGE_DATA_DIRECTORY"></a>数据目录项 IMAGE_DATA_DIRECTORY</h1><p>IMAGE_OPTIONAL_HEADER32(扩展PE头) 结构的最后一个字段为 <code>DataDriectory</code></p><p>该字段定义了PE文件中出现的所有不同类型的数据和目录信息 如前所述 应用程序中的数据被按照用途分成很多种类 <code>导出表、导入表、资源、重定位等</code> 在内存中，这些数据被<strong>操作系统以页为单位组织起来</strong>，并赋予不同的访问属性，在文件中，<strong>这些数据也同样被组织起来</strong>，按照<strong>不同类型分别存放在文件的指定位置，该结构就是用来描述这些不同类型的数据在文件(和内存)中位置及大小的</strong></p><p>该数据目录中定义的数据类型一直是16种</p><p>PE种使用了一种称作 “数据目录项 IMAGE_DATA_DIRECTORY” 的数据结构来定义每种数据</p><p>该结构如下所示 只有两个字段</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_IMAGE_DATA_DIRECTORY</span> &#123;</span><br><span class="line">  DWORD VirtualAddress;<span class="comment">// 数据的起始 RVA</span></span><br><span class="line">  DWORD Size;<span class="comment">// 数据块的长度</span></span><br><span class="line">&#125; IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;</span><br></pre></td></tr></table></figure><p>总的数据目录一共由16个相同的 IMAGE_DATA_DIRECTORY 结构连续排列在一起组成</p><p><img src="/2025/05/29/PElearn/image-20250530211044549.png" alt="数据目录结构示意图"></p><table><thead><tr><th>索引</th><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>0</td><td>Export Table</td><td>导出表（程序导出的函数信息）</td></tr><tr><td>1</td><td>Import Table</td><td>导入表（程序导入的 DLL 和函数）</td></tr><tr><td>2</td><td>Resource Table</td><td>资源表（图标、对话框、字符串等）</td></tr><tr><td>3</td><td>Exception Table</td><td>异常处理表（SEH）</td></tr><tr><td>4</td><td>Certificate Table</td><td>数字签名证书表</td></tr><tr><td>5</td><td>Base Relocation</td><td>重定位表（Address Fixups）</td></tr><tr><td>6</td><td>Debug Directory</td><td>调试信息表（符号等）</td></tr><tr><td>7</td><td>Architecture</td><td>保留（未使用）</td></tr><tr><td>8</td><td>GlobalPtr</td><td>全局指针（MIPS）</td></tr><tr><td>9</td><td>TLS Table</td><td>TLS 初始化数据表（线程本地存储）</td></tr><tr><td>10</td><td>Load Config Table</td><td>加载配置表（安全设置等）</td></tr><tr><td>11</td><td>Bound Import</td><td>绑定导入表（提前绑定信息）</td></tr><tr><td>12</td><td>IAT</td><td>导入地址表（Import Address Table）</td></tr><tr><td>13</td><td>Delay Import</td><td>延迟导入表（延迟加载 DLL）</td></tr><tr><td>14</td><td>COM Descriptor</td><td>CLR 运行时头（托管程序）</td></tr><tr><td>15</td><td>Reserved</td><td>保留</td></tr></tbody></table><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">IMAGE_OPTIONAL_HEADER</span><br><span class="line">├── ...</span><br><span class="line">├── IMAGE_DATA_DIRECTORY DataDirectory<span class="selector-attr">[16]</span></span><br><span class="line">│   ├── DataDirectory<span class="selector-attr">[0]</span>  → Export <span class="selector-tag">Table</span></span><br><span class="line">│   ├── DataDirectory<span class="selector-attr">[1]</span>  → Import <span class="selector-tag">Table</span></span><br><span class="line">│   ├── DataDirectory<span class="selector-attr">[2]</span>  → Resource <span class="selector-tag">Table</span></span><br><span class="line">│   └── ...</span><br></pre></td></tr></table></figure><p>常用的数据目录的用途如下：</p><table><thead><tr><th>数据目录项</th><th>作用</th></tr></thead><tbody><tr><td>导入表</td><td>找到程序依赖的 DLL 和函数</td></tr><tr><td>导出表</td><td>提供外部调用函数的信息（如 DLL 导出函数）</td></tr><tr><td>资源表</td><td>程序图标、对话框等 GUI 元素</td></tr><tr><td>重定位表</td><td>可执行文件在加载时修正地址</td></tr><tr><td>TLS 表</td><td>多线程支持的线程本地变量数据</td></tr><tr><td>COM 描述符</td><td>.NET 程序的入口点（托管程序）</td></tr></tbody></table><p>如果想在PE文件种寻找特定类型的数据 就需要从该结构开始</p><p><strong>该结构每个字段后的偏移都是基于 IMAGE_NT_HEADERS 头的</strong></p><h1 id="节表项-IMAGE-SECTION-HEADER"><a href="#节表项-IMAGE-SECTION-HEADER" class="headerlink" title="节表项 IMAGE_SECTION_HEADER"></a>节表项 IMAGE_SECTION_HEADER</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_IMAGE_SECTION_HEADER</span> &#123;</span><br><span class="line">  BYTE  Name[IMAGE_SIZEOF_SHORT_NAME];<span class="comment">// 8个字节节名</span></span><br><span class="line">  <span class="keyword">union</span> &#123;</span><br><span class="line">    DWORD PhysicalAddress;</span><br><span class="line">    DWORD VirtualSize;<span class="comment">// 节区的尺寸</span></span><br><span class="line">  &#125; Misc;</span><br><span class="line">  DWORD VirtualAddress;<span class="comment">// 节区的RVA地址</span></span><br><span class="line">  DWORD SizeOfRawData;<span class="comment">// 在文件中对齐后的尺寸</span></span><br><span class="line">  DWORD PointerToRawData;<span class="comment">// 在文件中的偏移</span></span><br><span class="line">  DWORD PointerToRelocations;<span class="comment">// 在OBJ文件中使用</span></span><br><span class="line">  DWORD PointerToLinenumbers;<span class="comment">// 行号表的位置(供调试使用)</span></span><br><span class="line">  WORD  NumberOfRelocations;<span class="comment">// 在OBJ文件中使用</span></span><br><span class="line">  WORD  NumberOfLinenumbers;<span class="comment">// 行号表中行号的数量</span></span><br><span class="line">  DWORD Characteristics;<span class="comment">// 节的属性</span></span><br><span class="line">&#125; IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;</span><br></pre></td></tr></table></figure><p><strong>该偏移是基于 IMAGE_SECTION_HEADER 头的</strong></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;PE-学习笔记-一&quot;&gt;&lt;a href=&quot;#PE-学习笔记-一&quot; class=&quot;headerlink&quot; title=&quot;PE 学习笔记(一)&quot;&gt;&lt;/a&gt;PE 学习笔记(一)&lt;/h1&gt;&lt;p&gt;先来几张图片放在最前面&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2025/05/29/PElearn/PE%E7%BB%93%E6%9E%841.jpeg&quot; alt=&quot;PE结构1&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="PE" scheme="http://example.com/tags/PE/"/>
    
  </entry>
  
</feed>
